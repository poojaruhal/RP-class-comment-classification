filename,comment_amount,code_amount,ratio,classComment,methodComment,methodBody,constructorComment,constructorBody,fieldComment,fieldBody,classCommentLineLength,classCommentSymbolLength
ErrorHandlingTest.java,18,116,0.15517241379310345," @author crazybob@google.com (Bob Lee) | suppress compiler error to test",,,,,,,1,72
MethodInterceptionTest.java,17,366,0.04644808743169399," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
MembersInjectorTest.java,30,334,0.08982035928143713," @author jessewilson@google.com (Jesse Wilson) |
   * Tests that member injections could happen in parallel.
   *
   * <p>Additional check that when member injection happen other threads would wait for it to finish
   * to provide proper resolution order semantics.
   | Callback for member injection. Uses a static type to be referable by getInstance(). |
   * Tests that member injections could happen in parallel.
   *
   * <p>Additional check that when member injection happen other threads would wait for it to finish
   * to provide proper resolution order semantics.
   | Member injection callback that injects itself. ","/**
 * Verifies that member injection injecting itself would get a non initialized instance.
 */
 
","{
    final RecursiveMemberInjection rmi = new RecursiveMemberInjection();
    Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(RecursiveMemberInjection.class).toInstance(rmi);
        }
    });
    assertTrue(""Member injection should happen"", rmi.called);
} 
",,,,,11,608
ProvisionListenerTest.java,48,804,0.05970149253731343,"
 * Tests for {@link Binder#bindListener(Matcher, ProvisionListener...)}
 *
 * @author sameb@google.com (Sam Berlin)
 | TODO(sameb): Add some tests for private modules & child injectors.",,,,,,,4,179
OptionalBindingTest.java,27,244,0.11065573770491803,"
 * This test verifies the ways things are injected (ie. getInstance(), injectMembers(), bind to
 * instance, and bind to provider instance) for all states of optional bindings (fields, methods,
 * multiple-argument methods, provider fields, provider methods, constructors).
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Test for bug 107, where we weren't doing optional injection properly for indirect injections.
 */
 
","{
    Indirect indirect = Guice.createInjector().getInstance(Indirect.class);
    assertNotNull(indirect.hasOptionalInjections);
    indirect.hasOptionalInjections.assertNothingInjected();
} 
",,,,,5,317
AllTests.java,31,115,0.26956521739130435," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
LoggerInjectionTest.java,5,61,0.08196721311475409,"
 * Test built-in injection of loggers.
 *
 * @author jessewilson
 ",,,,,,,3,60
TypeListenerTest.java,43,677,0.06351550960118169," @author jessewilson@google.com (Jesse Wilson) ","/**
 * We had a bug where we weren't notifying of types encountered for member injection when those
 * types had no members to be injected. Constructed types are always injected because they always
 * have at least one injection point: the class constructor.
 */
 
","{
    final AtomicInteger notificationCount = new AtomicInteger();
    Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bindListener(onlyAbcd, new TypeListener() {

                @Override
                public <I> void hear(TypeLiteral<I> type, TypeEncounter<I> encounter) {
                    notificationCount.incrementAndGet();
                }
            });
            bind(C.class).toInstance(new C());
        }
    });
    assertEquals(1, notificationCount.get());
} 
",,,,,1,47
NullableInjectionPointTest.java,7,236,0.029661016949152543," @author jessewilson@google.com (Jesse Wilson) ","/**
 * Provider.getInstance() is allowed to return null via direct calls to getInstance().
 */
 
/**
 * We haven't decided on what the desired behaviour of this test should be...
 */
 
/**
 * Tests for a regression where dependency objects were not updated properly and OptionalBinder
 * was rejecting nulls from its dependencies.
 */
 
","{
    assertNull(createInjector().getInstance(Foo.class));
} 
{
    try {
        Guice.createInjector(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Foo.class).toInstance(null);
            }
        });
        fail();
    } catch (CreationException expected) {
        assertContains(expected.getMessage(), ""Binding to null instances is not allowed."", ""at "" + getClass().getName(), getDeclaringSourcePart(getClass()));
    }
} 
{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Foo.class).toProvider(Providers.<Foo>of(null));
            OptionalBinder.newOptionalBinder(binder(), Foo.class);
        }

        @Provides
        @Named(""throughProvidesMethod"")
        Foo provideFoo(Optional<Foo> foo) {
            return foo.orNull();
        }
    });
    assertNull(injector.getInstance(Key.get(Foo.class, Names.named(""throughProvidesMethod""))));
} 
",,,,,1,47
ProviderInjectionTest.java,33,156,0.21153846153846154," @author crazybob@google.com (Bob Lee) ","/**
 * Test for bug 155.
 */
 
/**
 * When custom providers are used at injector creation time, they should be injected before use.
 * In this testcase, we verify that a provider for List.class is injected before it is used.
 */
 
/**
 * This test ensures that regardless of binding order, instances are injected before they are
 * used. It injects mutable Count objects and records their value at the time that they're
 * injected.
 */
 
","{
    Module m = new AbstractModule() {

        @Override
        protected void configure() {
            bind(Bar.class).toProvider(new Provider<Bar>() {

                @SuppressWarnings(""unused"")
                @Inject
                void cantBeCalled(Baz baz) {
                    fail(""Can't have called this method since Baz is not bound."");
                }

                @Override
                public Bar get() {
                    return new Bar() {
                    };
                }
            });
        }
    };
    try {
        Guice.createInjector(m);
        fail(""Should have thrown a CreationException"");
    } catch (CreationException expected) {
    }
} 
{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        public void configure() {
            // should bind String to ""[true]""
            bind(String.class).toProvider(new Provider<String>() {

                private String value;

                @Inject
                void initialize(List list) {
                    value = list.toString();
                }

                @Override
                public String get() {
                    return value;
                }
            });
            // should bind List to [true]
            bind(List.class).toProvider(new Provider<List>() {

                @Inject
                Boolean injectedYet = Boolean.FALSE;

                @Override
                public List get() {
                    return Arrays.asList(injectedYet);
                }
            });
            // should bind Boolean to true
            bind(Boolean.class).toInstance(Boolean.TRUE);
        }
    });
    assertEquals(""Providers not injected before use"", ""[true]"", injector.getInstance(String.class));
} 
{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            // instance injection
            bind(Count.class).annotatedWith(named(""a"")).toInstance(new Count(0) {

                @Inject
                void initialize(@Named(""b"") Count bCount) {
                    value = bCount.value + 1;
                }
            });
            // provider injection
            bind(Count.class).annotatedWith(named(""b"")).toProvider(new Provider<Count>() {

                Count count;

                @Inject
                void initialize(@Named(""c"") Count cCount) {
                    count = new Count(cCount.value + 2);
                }

                @Override
                public Count get() {
                    return count;
                }
            });
            // field and method injection, fields first
            bind(Count.class).annotatedWith(named(""c"")).toInstance(new Count(0) {

                @Inject
                @Named(""d"")
                Count dCount;

                @Inject
                void initialize(@Named(""e"") Count eCount) {
                    value = dCount.value + eCount.value + 4;
                }
            });
            // static injection
            requestStaticInjection(StaticallyInjectable.class);
            bind(Count.class).annotatedWith(named(""d"")).toInstance(new Count(8));
            bind(Count.class).annotatedWith(named(""e"")).toInstance(new Count(16));
        }
    });
    assertEquals(28, injector.getInstance(Key.get(Count.class, named(""c""))).value);
    assertEquals(30, injector.getInstance(Key.get(Count.class, named(""b""))).value);
    assertEquals(31, injector.getInstance(Key.get(Count.class, named(""a""))).value);
    assertEquals(28, StaticallyInjectable.cCountAtInjectionTime);
} 
",,,,,1,39
TypeLiteralTest.java,22,156,0.14102564102564102," @author crazybob@google.com (Bob Lee) ","/**
 * Unlike Key, TypeLiteral retains full type information and differentiates between {@code
 * int.class} and {@code Integer.class}.
 */
 
","{
    Class[] primitives = new Class[] { boolean.class, byte.class, short.class, int.class, long.class, float.class, double.class, char.class, void.class };
    Class[] wrappers = new Class[] { Boolean.class, Byte.class, Short.class, Integer.class, Long.class, Float.class, Double.class, Character.class, Void.class };
    for (int t = 0; t < primitives.length; t++) {
        @SuppressWarnings(""unchecked"")
        TypeLiteral primitiveTl = TypeLiteral.get(primitives[t]);
        @SuppressWarnings(""unchecked"")
        TypeLiteral wrapperTl = TypeLiteral.get(wrappers[t]);
        assertFalse(primitiveTl.equals(wrapperTl));
        assertEquals(primitives[t], primitiveTl.getType());
        assertEquals(wrappers[t], wrapperTl.getType());
        assertEquals(primitives[t], primitiveTl.getRawType());
        assertEquals(wrappers[t], wrapperTl.getRawType());
    }
} 
",,,,,1,39
KeyTest.java,20,281,0.0711743772241993," @author crazybob@google.com (Bob Lee) ","/**
 * Key canonicalizes {@link int.class} to {@code Integer.class}, and won't expose wrapper types.
 */
 
/**
 * Test for issue 186
 */
 
","{
    Class[] primitives = new Class[] { boolean.class, byte.class, short.class, int.class, long.class, float.class, double.class, char.class, void.class };
    Class[] wrappers = new Class[] { Boolean.class, Byte.class, Short.class, Integer.class, Long.class, Float.class, Double.class, Character.class, Void.class };
    for (int t = 0; t < primitives.length; t++) {
        @SuppressWarnings(""unchecked"")
        Key primitiveKey = Key.get(primitives[t]);
        @SuppressWarnings(""unchecked"")
        Key wrapperKey = Key.get(wrappers[t]);
        assertEquals(primitiveKey, wrapperKey);
        assertEquals(wrappers[t], primitiveKey.getRawType());
        assertEquals(wrappers[t], wrapperKey.getRawType());
        assertEquals(wrappers[t], primitiveKey.getTypeLiteral().getType());
        assertEquals(wrappers[t], wrapperKey.getTypeLiteral().getType());
    }
    Key<Integer> integerKey = Key.get(Integer.class);
    Key<Integer> integerKey2 = Key.get(Integer.class, Named.class);
    Key<Integer> integerKey3 = Key.get(Integer.class, Names.named(""int""));
    Class<Integer> intClassLiteral = int.class;
    assertEquals(integerKey, Key.get(intClassLiteral));
    assertEquals(integerKey2, Key.get(intClassLiteral, Named.class));
    assertEquals(integerKey3, Key.get(intClassLiteral, Names.named(""int"")));
    Type intType = int.class;
    assertEquals(integerKey, Key.get(intType));
    assertEquals(integerKey2, Key.get(intType, Named.class));
    assertEquals(integerKey3, Key.get(intType, Names.named(""int"")));
    TypeLiteral<Integer> intTypeLiteral = TypeLiteral.get(int.class);
    assertEquals(integerKey, Key.get(intTypeLiteral));
    assertEquals(integerKey2, Key.get(intTypeLiteral, Named.class));
    assertEquals(integerKey3, Key.get(intTypeLiteral, Names.named(""int"")));
} 
{
    ParameterizedType listOfTType = (ParameterizedType) getClass().getDeclaredMethod(""parameterizedWithVariable"", List.class).getGenericParameterTypes()[0];
    TypeLiteral<?> listOfT = TypeLiteral.get(listOfTType);
    try {
        Key.get(listOfT);
        fail(""Guice should not allow keys for java.util.List<T>"");
    } catch (ConfigurationException e) {
        assertContains(e.getMessage(), ""java.util.List<T> cannot be used as a key; It is not fully specified."");
    }
    TypeVariable tType = (TypeVariable) listOfTType.getActualTypeArguments()[0];
    TypeLiteral<?> t = TypeLiteral.get(tType);
    try {
        Key.get(t);
        fail(""Guice should not allow keys for T"");
    } catch (ConfigurationException e) {
        assertContains(e.getMessage(), ""T cannot be used as a key; It is not fully specified."");
    }
} 
",,,,,1,39
RequestInjectionTest.java,31,201,0.15422885572139303," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
ProvidesIntoTest.java,20,373,0.05361930294906166,"
 * Tests the various @ProvidesInto annotations.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,87
ProvidersTest.java,7,125,0.056,"
 * Unit tests for {@link Providers}.
 *
 * @author Kevin Bourrillion (kevinb9n@gmail.com)
 ",,,,,,,3,85
OverrideModuleTest.java,21,732,0.028688524590163935," @author sberlin@gmail.com (Sam Berlin) ",,,,,,,1,40
TypesTest.java,23,159,0.14465408805031446," @author jessewilson@google.com (Jesse Wilson) ","/**
 * Ensure that owning types are required when necessary, and forbidden otherwise.
 */
 
","{
    try {
        Types.newParameterizedType(Owning.class, String.class);
        fail();
    } catch (IllegalArgumentException expected) {
        assertContains(expected.getMessage(), ""No owner type for enclosed "" + Owning.class);
    }
    try {
        Types.newParameterizedTypeWithOwner(Object.class, Set.class, String.class);
        fail(""Expected IllegalArgumentException"");
    } catch (IllegalArgumentException expected) {
        assertContains(expected.getMessage(), ""Owner type for unenclosed "" + Set.class);
    }
} 
",,,,,1,47
NoopOverrideTest.java,16,11,1.4545454545454546," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
TypeConversionTest.java,16,470,0.03404255319148936," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
JndiProvider.java,16,25,0.64,,"/**
 * Creates a JNDI provider for the given type and name.
 */
 
","{
    return new JndiProvider<T>(type, name);
} 
",,,,,1,0
ClientServiceWithGuice.java,18,55,0.32727272727272727," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
JndiProviderClient.java,17,22,0.7727272727272727,,,,,,,,1,0
ClientServiceWithFactories.java,18,53,0.33962264150943394," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
ClientServiceWithDependencyInjection.java,18,54,0.3333333333333333," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
ClientServiceWithGuiceDefaults.java,18,51,0.35294117647058826," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
UniqueAnnotationsTest.java,16,14,1.1428571428571428," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
WeakKeySetUtils.java,21,68,0.3088235294117647,"
 * Utilities for verifying com.google.inject.internal.WeakKeySet is not leaking memory.
 *
 * @author dweis@google.com (Daniel Weis)
 ",,,,,,,3,128
LineNumbersTest.java,18,133,0.13533834586466165," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
Collector.java,20,31,0.6451612903225806,,,,,,,,1,0
SpiUtils.java,85,1133,0.07502206531332745,"
 * Utilities for testing the Multibinder & MapBinder extension SPI.
 *
 * @author sameb@google.com (Sam Berlin)
 | The kind of test we should perform. A live Injector, a raw Elements (Module) test, or both. | The kind of binding. | The result of the binding. ","/**
 * Asserts that MapBinderBinding visitors for work correctly.
 *
 * @param <T> The type of the binding
 * @param mapKey The key the map belongs to.
 * @param keyType the TypeLiteral of the key of the map
 * @param valueType the TypeLiteral of the value of the map
 * @param modules The modules that define the mapbindings
 * @param visitType The kind of test we should perform. A live Injector, a raw Elements (Module)
 *     test, or both.
 * @param allowDuplicates If duplicates are allowed.
 * @param expectedMapBindings The number of other mapbinders we expect to see.
 * @param results The kind of bindings contained in the mapbinder.
 */
 
/**
 * Asserts that MultibinderBinding visitors work correctly.
 *
 * @param <T> The type of the binding
 * @param setKey The key the set belongs to.
 * @param elementType the TypeLiteral of the element
 * @param modules The modules that define the multibindings
 * @param visitType The kind of test we should perform. A live Injector, a raw Elements (Module)
 *     test, or both.
 * @param allowDuplicates If duplicates are allowed.
 * @param expectedMultibindings The number of other multibinders we expect to see.
 * @param results The kind of bindings contained in the multibinder.
 */
 
/**
 * Asserts that OptionalBinderBinding visitors for work correctly.
 *
 * @param <T> The type of the binding
 * @param keyType The key OptionalBinder is binding
 * @param modules The modules that define the bindings
 * @param visitType The kind of test we should perform. A live Injector, a raw Elements (Module)
 *     test, or both.
 * @param expectedOtherOptionalBindings the # of other optional bindings we expect to see.
 * @param expectedDefault the expected default binding, or null if none
 * @param expectedActual the expected actual binding, or null if none
 * @param expectedUserLinkedActual the user binding that is the actual binding, used if neither
 *     the default nor actual are set and a user binding existed for the type.
 */
 
/**
 * Returns the subset of elements that have keys, indexed by them.
 */
 
","{
    if (visitType == null) {
        fail(""must test something"");
    }
    if (visitType == BOTH || visitType == INJECTOR) {
        mapInjectorTest(mapKey, keyType, valueType, modules, allowDuplicates, expectedMapBindings, results);
    }
    if (visitType == BOTH || visitType == MODULE) {
        mapModuleTest(mapKey, keyType, valueType, modules, allowDuplicates, expectedMapBindings, results);
    }
} 
{
    if (visitType == null) {
        fail(""must test something"");
    }
    if (visitType == BOTH || visitType == INJECTOR) {
        setInjectorTest(setKey, elementType, modules, allowDuplicates, expectedMultibindings, results);
    }
    if (visitType == BOTH || visitType == MODULE) {
        setModuleTest(setKey, elementType, modules, allowDuplicates, expectedMultibindings, results);
    }
} 
{
    if (visitType == null) {
        fail(""must test something"");
    }
    // expect twice as many bindings because of java.util.Optional
    expectedOtherOptionalBindings *= 2;
    if (visitType == BOTH || visitType == INJECTOR) {
        optionalInjectorTest(keyType, modules, expectedOtherOptionalBindings, expectedDefault, expectedActual, expectedUserLinkedActual);
    }
    if (visitType == BOTH || visitType == MODULE) {
        optionalModuleTest(keyType, modules, expectedOtherOptionalBindings, expectedDefault, expectedActual, expectedUserLinkedActual);
    }
} 
{
    ImmutableMap.Builder<Key<?>, Binding<?>> builder = ImmutableMap.builder();
    for (Element element : elements) {
        if (element instanceof Binding) {
            builder.put(((Binding) element).getKey(), (Binding) element);
        }
    }
    return builder.build();
} 
",,,,,4,253
RealElementTest.java,16,27,0.5925925925925926," Tests for {@link com.google.inject.internal.RealElement}. ",,,,,,,1,59
ProxyFactoryTest.java,16,147,0.10884353741496598," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
WeakKeySetTest.java,52,454,0.1145374449339207,"
 * Tests for {@link WeakKeySet}.
 *
 * <p>Multibinding specific tests can be found in MultibinderTest and MapBinderTest.
 *
 * @author dweis@google.com (Daniel Weis)
 ",,,,,,,5,157
MoreTypesTest.java,16,39,0.41025641025641024," @author schmitt@google.com (Peter Schmitt) ",,,,,,,1,44
MapBinderTest.java,94,1351,0.0695780903034789," @author dpb@google.com (David P. Baker) | Our implementation maintains order, but doesn't guarantee it in the API spec. | A simple module with a MapBinder with two entries. ","/**
 * Check that the dependencies are correct.
 */
 
/**
 * Check that the dependencies are correct in the Tool Stage.
 */
 
/**
 * With overrides, we should get the union of all map bindings.
 */
 
/**
 * With overrides, we should get the union of all map bindings.
 */
 
/**
 * Ensure there are no initialization race conditions in basic map injection.
 */
 
/**
 * Ensure there are no initialization race conditions in provider multimap injection.
 */
 
/**
 * Will find and return the {@link com.google.inject.spi.Element} that is a {@link
 * ProviderMapEntry} with a key that matches the one supplied by the user in {@code k}.
 *
 * <p>Will return {@code null} if it cannot be found.
 */
 
/**
 * Will find and return the {@link com.google.inject.spi.Element} that is an {@link
 * InstanceBinding} and binds {@code vToFind}.
 */
 
/**
 * Given an {@link Iterable} of elements, return the one that is a {@link MapBinderBinding}, or
 * {@code null} if it cannot be found.
 */
 
","{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            MapBinder<Integer, String> mapBinder = MapBinder.newMapBinder(binder(), Integer.class, String.class);
            mapBinder.addBinding(1).toInstance(""A"");
            mapBinder.addBinding(2).to(Key.get(String.class, Names.named(""b"")));
            bindConstant().annotatedWith(Names.named(""b"")).to(""B"");
        }
    });
    Binding<Map<Integer, String>> binding = injector.getBinding(new Key<Map<Integer, String>>() {
    });
    HasDependencies withDependencies = (HasDependencies) binding;
    Set<Dependency<?>> actualDependencies = withDependencies.getDependencies();
    // We expect two dependencies, because the dependencies are annotated with
    // Element, which has a uniqueId, it's difficult to directly compare them.
    // Instead we will manually compare all the fields except the uniqueId
    assertEquals(2, actualDependencies.size());
    for (Dependency<?> dependency : actualDependencies) {
        Key<?> key = dependency.getKey();
        assertEquals(new TypeLiteral<String>() {
        }, key.getTypeLiteral());
        Annotation annotation = dependency.getKey().getAnnotation();
        assertTrue(annotation instanceof Element);
        Element element = (Element) annotation;
        assertEquals("""", element.setName());
        assertEquals(Element.Type.MAPBINDER, element.type());
        assertEquals(""java.lang.Integer"", element.keyType());
    }
    Set<String> elements = Sets.newHashSet();
    elements.addAll(recurseForDependencies(injector, withDependencies));
    assertEquals(ImmutableSet.of(""A"", ""B""), elements);
} 
{
    Injector injector = Guice.createInjector(Stage.TOOL, new AbstractModule() {

        @Override
        protected void configure() {
            MapBinder<Integer, String> mapBinder = MapBinder.newMapBinder(binder(), Integer.class, String.class);
            mapBinder.addBinding(1).toInstance(""A"");
            mapBinder.addBinding(2).to(Key.get(String.class, Names.named(""b"")));
            bindConstant().annotatedWith(Names.named(""b"")).to(""B"");
        }
    });
    Binding<Map<Integer, String>> binding = injector.getBinding(new Key<Map<Integer, String>>() {
    });
    HasDependencies withDependencies = (HasDependencies) binding;
    Set<Dependency<?>> actualDependencies = withDependencies.getDependencies();
    // We expect two dependencies, because the dependencies are annotated with
    // Element, which has a uniqueId, it's difficult to directly compare them.
    // Instead we will manually compare all the fields except the uniqueId
    assertEquals(2, actualDependencies.size());
    for (Dependency<?> dependency : actualDependencies) {
        Key<?> key = dependency.getKey();
        assertEquals(new TypeLiteral<String>() {
        }, key.getTypeLiteral());
        Annotation annotation = dependency.getKey().getAnnotation();
        assertTrue(annotation instanceof Element);
        Element element = (Element) annotation;
        assertEquals("""", element.setName());
        assertEquals(Element.Type.MAPBINDER, element.type());
        assertEquals(""java.lang.Integer"", element.keyType());
    }
} 
{
    Module ab = new AbstractModule() {

        @Override
        protected void configure() {
            MapBinder<String, String> multibinder = MapBinder.newMapBinder(binder(), String.class, String.class);
            multibinder.addBinding(""a"").toInstance(""A"");
            multibinder.addBinding(""b"").toInstance(""B"");
        }
    };
    Module cd = new AbstractModule() {

        @Override
        protected void configure() {
            MapBinder<String, String> multibinder = MapBinder.newMapBinder(binder(), String.class, String.class);
            multibinder.addBinding(""c"").toInstance(""C"");
            multibinder.addBinding(""d"").toInstance(""D"");
        }
    };
    Module ef = new AbstractModule() {

        @Override
        protected void configure() {
            MapBinder<String, String> multibinder = MapBinder.newMapBinder(binder(), String.class, String.class);
            multibinder.addBinding(""e"").toInstance(""E"");
            multibinder.addBinding(""f"").toInstance(""F"");
        }
    };
    Module abcd = Modules.override(ab).with(cd);
    Injector injector = Guice.createInjector(abcd, ef);
    assertEquals(mapOf(""a"", ""A"", ""b"", ""B"", ""c"", ""C"", ""d"", ""D"", ""e"", ""E"", ""f"", ""F""), injector.getInstance(Key.get(mapOfString)));
    assertMapVisitor(Key.get(mapOfString), stringType, stringType, setOf(abcd, ef), BOTH, false, 0, instance(""a"", ""A""), instance(""b"", ""B""), instance(""c"", ""C""), instance(""d"", ""D""), instance(""e"", ""E""), instance(""f"", ""F""));
} 
{
    Module abc = new AbstractModule() {

        @Override
        protected void configure() {
            MapBinder<String, String> multibinder = MapBinder.newMapBinder(binder(), String.class, String.class);
            multibinder.addBinding(""a"").toInstance(""A"");
            multibinder.addBinding(""b"").toInstance(""B"");
            multibinder.addBinding(""c"").toInstance(""C"");
            multibinder.permitDuplicates();
        }
    };
    Module cd = new AbstractModule() {

        @Override
        protected void configure() {
            MapBinder<String, String> multibinder = MapBinder.newMapBinder(binder(), String.class, String.class);
            multibinder.addBinding(""c"").toInstance(""C"");
            multibinder.addBinding(""d"").toInstance(""D"");
            multibinder.permitDuplicates();
        }
    };
    Module ef = new AbstractModule() {

        @Override
        protected void configure() {
            MapBinder<String, String> multibinder = MapBinder.newMapBinder(binder(), String.class, String.class);
            multibinder.addBinding(""e"").toInstance(""E"");
            multibinder.addBinding(""f"").toInstance(""F"");
            multibinder.permitDuplicates();
        }
    };
    Module abcd = Modules.override(abc).with(cd);
    Injector injector = Guice.createInjector(abcd, ef);
    assertEquals(mapOf(""a"", ""A"", ""b"", ""B"", ""c"", ""C"", ""d"", ""D"", ""e"", ""E"", ""f"", ""F""), injector.getInstance(Key.get(mapOfString)));
    assertMapVisitor(Key.get(mapOfString), stringType, stringType, setOf(abcd, ef), BOTH, true, 0, instance(""a"", ""A""), instance(""b"", ""B""), instance(""c"", ""C""), instance(""d"", ""D""), instance(""e"", ""E""), instance(""f"", ""F""));
} 
{
    final AtomicReference<Map<String, String>> injectedMap = new AtomicReference<Map<String, String>>();
    final Object anObject = new Object() {

        @Inject
        void initialize(Map<String, String> map) {
            injectedMap.set(map);
        }
    };
    Module abc = new AbstractModule() {

        @Override
        protected void configure() {
            requestInjection(anObject);
            MapBinder<String, String> multibinder = MapBinder.newMapBinder(binder(), String.class, String.class);
            multibinder.addBinding(""a"").toInstance(""A"");
            multibinder.addBinding(""b"").toInstance(""B"");
            multibinder.addBinding(""c"").toInstance(""C"");
        }
    };
    Guice.createInjector(abc);
    assertEquals(mapOf(""a"", ""A"", ""b"", ""B"", ""c"", ""C""), injectedMap.get());
} 
{
    final AtomicReference<Map<String, Set<Provider<String>>>> injectedMultimap = new AtomicReference<Map<String, Set<Provider<String>>>>();
    final Object anObject = new Object() {

        @Inject
        void initialize(Map<String, Set<Provider<String>>> multimap) {
            injectedMultimap.set(multimap);
        }
    };
    Module abc = new AbstractModule() {

        @Override
        protected void configure() {
            requestInjection(anObject);
            MapBinder<String, String> multibinder = MapBinder.newMapBinder(binder(), String.class, String.class);
            multibinder.permitDuplicates();
            multibinder.addBinding(""a"").toInstance(""A"");
            multibinder.addBinding(""b"").toInstance(""B"");
            multibinder.addBinding(""c"").toInstance(""C"");
        }
    };
    Guice.createInjector(abc);
    Map<String, String> map = Maps.transformValues(injectedMultimap.get(), stringProvidersSet -> Iterables.getOnlyElement(stringProvidersSet).get());
    assertEquals(mapOf(""a"", ""A"", ""b"", ""B"", ""c"", ""C""), map);
} 
{
    for (com.google.inject.spi.Element element : elements) {
        if (element instanceof ProviderInstanceBinding) {
            javax.inject.Provider<?> usp = ((ProviderInstanceBinding<?>) element).getUserSuppliedProvider();
            if (usp instanceof ProviderMapEntry) {
                ProviderMapEntry<?, ?> pme = (ProviderMapEntry<?, ?>) usp;
                // Check if the key from the ProviderMapEntry matches the one we're looking for
                if (kToFind.equals(pme.getKey())) {
                    return element;
                }
            }
        }
    }
    // No matching ProviderMapEntry found
    return null;
} 
{
    for (com.google.inject.spi.Element element : elements) {
        if (element instanceof InstanceBinding) {
            Object instanceFromBinding = ((InstanceBinding<?>) element).getInstance();
            if (vToFind.equals(instanceFromBinding)) {
                return element;
            }
        }
    }
    // No matching binding found
    return null;
} 
{
    final Collector collector = new Collector();
    for (com.google.inject.spi.Element element : elements) {
        element.acceptVisitor(new DefaultElementVisitor<Void>() {

            @Override
            public <T> Void visit(Binding<T> binding) {
                binding.acceptTargetVisitor(collector);
                return null;
            }
        });
    }
    return collector.mapbinding;
} 
",,,,,1,174
CycleDetectingLockTest.java,44,175,0.25142857142857145,,,,,,,,1,0
OptionalBinderTest.java,44,1187,0.03706823925863521," @author sameb@google.com (Sam Berlin) ","/**
 * Doubly-installed modules should not conflict, even when one is overridden.
 */
 
/**
 * Unscoped bindings should not conflict, whether they were bound with no explicit scope, or
 * explicitly bound in {@link Scopes#NO_SCOPE}.
 */
 
/**
 * Ensure key hash codes are fixed at injection time, not binding time.
 */
 
/**
 * Ensure bindings do not rehash their keys once returned from {@link Elements#getElements}.
 */
 
","{
    Module m = new AbstractModule() {

        @Override
        protected void configure() {
            OptionalBinder<String> b = OptionalBinder.newOptionalBinder(binder(), String.class);
            b.setDefault().toInstance(""A"");
            b.setBinding().toInstance(""B"");
        }
    };
    assertEquals(""B"", Guice.createInjector(m, m).getInstance(Key.get(String.class)));
    Injector injector = Guice.createInjector(m, Modules.override(m).with(m));
    assertEquals(""B"", injector.getInstance(Key.get(String.class)));
    assertOptionalVisitor(stringKey, setOf(m, Modules.override(m).with(m)), VisitType.BOTH, 0, instance(""A""), instance(""B""), null);
} 
{
    Module m = new AbstractModule() {

        @Override
        protected void configure() {
            OptionalBinder<Integer> b = OptionalBinder.newOptionalBinder(binder(), Integer.class);
            b.setDefault().to(Key.get(Integer.class, named(""foo"")));
            b.setDefault().to(Key.get(Integer.class, named(""foo""))).in(Scopes.NO_SCOPE);
            b.setBinding().to(Key.get(Integer.class, named(""foo"")));
            b.setBinding().to(Key.get(Integer.class, named(""foo""))).in(Scopes.NO_SCOPE);
        }

        @Provides
        @Named(""foo"")
        int provideInt() {
            return 5;
        }
    };
    assertEquals(5, Guice.createInjector(m).getInstance(Integer.class).intValue());
} 
{
    Module m = new AbstractModule() {

        @Override
        protected void configure() {
            OptionalBinder<List<String>> b = OptionalBinder.newOptionalBinder(binder(), listOfStrings);
            List<String> list = Lists.newArrayList();
            b.setDefault().toInstance(list);
            b.setBinding().toInstance(list);
            list.add(""A"");
            list.add(""B"");
        }
    };
    Injector injector = Guice.createInjector(m);
    for (Entry<Key<?>, Binding<?>> entry : injector.getAllBindings().entrySet()) {
        Key<?> bindingKey = entry.getKey();
        Key<?> clonedKey;
        if (bindingKey.getAnnotation() != null) {
            clonedKey = Key.get(bindingKey.getTypeLiteral(), bindingKey.getAnnotation());
        } else if (bindingKey.getAnnotationType() != null) {
            clonedKey = Key.get(bindingKey.getTypeLiteral(), bindingKey.getAnnotationType());
        } else {
            clonedKey = Key.get(bindingKey.getTypeLiteral());
        }
        assertEquals(bindingKey, clonedKey);
        assertEquals(""Incorrect hashcode for "" + bindingKey + "" -> "" + entry.getValue(), bindingKey.hashCode(), clonedKey.hashCode());
    }
} 
{
    final List<String> list = Lists.newArrayList();
    Module m = new AbstractModule() {

        @Override
        protected void configure() {
            OptionalBinder<List<String>> b = OptionalBinder.newOptionalBinder(binder(), listOfStrings);
            b.setDefault().toInstance(list);
            list.add(""A"");
            list.add(""B"");
        }
    };
    InstanceBinding<?> binding = Elements.getElements(m).stream().filter(InstanceBinding.class::isInstance).map(InstanceBinding.class::cast).collect(onlyElement());
    Key<?> keyBefore = binding.getKey();
    assertEquals(listOfStrings, keyBefore.getTypeLiteral());
    list.add(""C"");
    Key<?> keyAfter = binding.getKey();
    assertSame(keyBefore, keyAfter);
} 
",,,,,1,39
MultibinderTest.java,99,1296,0.0763888888888889," @author jessewilson@google.com (Jesse Wilson) ","/**
 * We just want to make sure that multibinder's binding depends on each of its values. We don't
 * really care about the underlying structure of those bindings, which are implementation details.
 */
 
/**
 * We just want to make sure that multibinder's binding depends on each of its values. We don't
 * really care about the underlying structure of those bindings, which are implementation details.
 */
 
/**
 * Our implementation maintains order, but doesn't guarantee it in the API spec. TODO: specify the
 * iteration order?
 */
 
/**
 * With overrides, we should get the union of all multibindings.
 */
 
/**
 * With overrides, we should get the union of all multibindings.
 */
 
/**
 * Doubly-installed modules should not conflict, even when one is overridden.
 */
 
/**
 * Unscoped bindings should not conflict, whether they were bound with no explicit scope, or
 * explicitly bound in {@link Scopes#NO_SCOPE}.
 */
 
/**
 * Ensure key hash codes are fixed at injection time, not binding time.
 */
 
/**
 * Ensure bindings do not rehash their keys once returned from {@link Elements#getElements}.
 */
 
","{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);
            multibinder.addBinding().toInstance(""A"");
            multibinder.addBinding().to(Key.get(String.class, Names.named(""b"")));
            bindConstant().annotatedWith(Names.named(""b"")).to(""B"");
        }
    });
    Binding<Set<String>> binding = injector.getBinding(new Key<Set<String>>() {
    });
    HasDependencies withDependencies = (HasDependencies) binding;
    Set<String> elements = Sets.newHashSet();
    for (Dependency<?> dependency : withDependencies.getDependencies()) {
        elements.add((String) injector.getInstance(dependency.getKey()));
    }
    assertEquals(ImmutableSet.of(""A"", ""B""), elements);
} 
{
    Injector injector = Guice.createInjector(Stage.TOOL, new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);
            multibinder.addBinding().toInstance(""A"");
            multibinder.addBinding().to(Key.get(String.class, Names.named(""b"")));
            bindConstant().annotatedWith(Names.named(""b"")).to(""B"");
        }
    });
    Binding<Set<String>> binding = injector.getBinding(new Key<Set<String>>() {
    });
    HasDependencies withDependencies = (HasDependencies) binding;
    InstanceBinding<?> instanceBinding = null;
    LinkedKeyBinding<?> linkedBinding = null;
    // The non-tool stage test can test this by calling injector.getInstance to ensure
    // the right values are returned -- in tool stage we can't do that.  It's also a
    // little difficult to validate the dependencies & bindings, because they're
    // bindings created internally within Multibinder.
    // To workaround this, we just validate that the dependencies lookup to a single
    // InstanceBinding whose value is ""A"" and another LinkedBinding whose target is
    // the Key of @Named(""b"") String=B
    for (Dependency<?> dependency : withDependencies.getDependencies()) {
        Binding<?> b = injector.getBinding(dependency.getKey());
        if (b instanceof InstanceBinding) {
            if (instanceBinding != null) {
                fail(""Already have an instance binding of: "" + instanceBinding + "", and now want to add: "" + b);
            } else {
                instanceBinding = (InstanceBinding) b;
            }
        } else if (b instanceof LinkedKeyBinding) {
            if (linkedBinding != null) {
                fail(""Already have a linked binding of: "" + linkedBinding + "", and now want to add: "" + b);
            } else {
                linkedBinding = (LinkedKeyBinding) b;
            }
        } else {
            fail(""Unexpected dependency of: "" + dependency);
        }
    }
    assertNotNull(instanceBinding);
    assertNotNull(linkedBinding);
    assertEquals(""A"", instanceBinding.getInstance());
    assertEquals(Key.get(String.class, Names.named(""b"")), linkedBinding.getLinkedKey());
} 
{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);
            multibinder.addBinding().toInstance(""leonardo"");
            multibinder.addBinding().toInstance(""donatello"");
            install(new AbstractModule() {

                @Override
                protected void configure() {
                    Multibinder.newSetBinder(binder(), String.class).addBinding().toInstance(""michaelangelo"");
                }
            });
        }
    }, new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder.newSetBinder(binder(), String.class).addBinding().toInstance(""raphael"");
        }
    });
    List<String> inOrder = ImmutableList.copyOf(injector.getInstance(Key.get(setOfString)));
    assertEquals(ImmutableList.of(""leonardo"", ""donatello"", ""michaelangelo"", ""raphael""), inOrder);
} 
{
    Module ab = new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);
            multibinder.addBinding().toInstance(""A"");
            multibinder.addBinding().toInstance(""B"");
        }
    };
    Module cd = new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);
            multibinder.addBinding().toInstance(""C"");
            multibinder.addBinding().toInstance(""D"");
        }
    };
    Module ef = new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);
            multibinder.addBinding().toInstance(""E"");
            multibinder.addBinding().toInstance(""F"");
        }
    };
    Module abcd = Modules.override(ab).with(cd);
    Injector injector = Guice.createInjector(abcd, ef);
    assertEquals(ImmutableSet.of(""A"", ""B"", ""C"", ""D"", ""E"", ""F""), injector.getInstance(Key.get(setOfString)));
    assertSetVisitor(Key.get(setOfString), stringType, setOf(abcd, ef), BOTH, false, 0, instance(""A""), instance(""B""), instance(""C""), instance(""D""), instance(""E""), instance(""F""));
} 
{
    Module abc = new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);
            multibinder.addBinding().toInstance(""A"");
            multibinder.addBinding().toInstance(""B"");
            multibinder.addBinding().toInstance(""C"");
            multibinder.permitDuplicates();
        }
    };
    Module cd = new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);
            multibinder.addBinding().toInstance(""C"");
            multibinder.addBinding().toInstance(""D"");
            multibinder.permitDuplicates();
        }
    };
    Module ef = new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);
            multibinder.addBinding().toInstance(""E"");
            multibinder.addBinding().toInstance(""F"");
            multibinder.permitDuplicates();
        }
    };
    Module abcd = Modules.override(abc).with(cd);
    Injector injector = Guice.createInjector(abcd, ef);
    assertEquals(ImmutableSet.of(""A"", ""B"", ""C"", ""D"", ""E"", ""F""), injector.getInstance(Key.get(setOfString)));
    assertSetVisitor(Key.get(setOfString), stringType, setOf(abcd, ef), BOTH, true, 0, instance(""A""), instance(""B""), instance(""C""), instance(""D""), instance(""E""), instance(""F""));
} 
{
    Module ab = new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<String> multibinder = Multibinder.newSetBinder(binder(), String.class);
            multibinder.addBinding().toInstance(""A"");
            multibinder.addBinding().toInstance(""B"");
        }
    };
    // Guice guarantees this assertion, as the same module cannot be installed twice.
    assertEquals(ImmutableSet.of(""A"", ""B""), Guice.createInjector(ab, ab).getInstance(Key.get(setOfString)));
    // Guice will only guarantee this assertion if Multibinder ensures the bindings match.
    Injector injector = Guice.createInjector(ab, Modules.override(ab).with(ab));
    assertEquals(ImmutableSet.of(""A"", ""B""), injector.getInstance(Key.get(setOfString)));
} 
{
    Module singleBinding = new AbstractModule() {

        @Override
        protected void configure() {
            bind(Integer.class).to(Key.get(Integer.class, named(""A"")));
            bind(Integer.class).to(Key.get(Integer.class, named(""A""))).in(Scopes.NO_SCOPE);
        }

        @Provides
        @Named(""A"")
        int provideInteger() {
            return 5;
        }
    };
    Module multibinding = new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<Integer> multibinder = Multibinder.newSetBinder(binder(), Integer.class);
            multibinder.addBinding().to(Key.get(Integer.class, named(""A"")));
            multibinder.addBinding().to(Key.get(Integer.class, named(""A""))).in(Scopes.NO_SCOPE);
        }
    };
    assertEquals(5, (int) Guice.createInjector(singleBinding).getInstance(Integer.class));
    assertEquals(ImmutableSet.of(5), Guice.createInjector(singleBinding, multibinding).getInstance(Key.get(setOfInteger)));
} 
{
    Module ab = new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<List<String>> multibinder = Multibinder.newSetBinder(binder(), listOfStrings);
            List<String> list = Lists.newArrayList();
            multibinder.addBinding().toInstance(list);
            list.add(""A"");
            list.add(""B"");
        }
    };
    Injector injector = Guice.createInjector(ab);
    for (Entry<Key<?>, Binding<?>> entry : injector.getAllBindings().entrySet()) {
        Key<?> bindingKey = entry.getKey();
        Key<?> clonedKey;
        if (bindingKey.getAnnotation() != null) {
            clonedKey = Key.get(bindingKey.getTypeLiteral(), bindingKey.getAnnotation());
        } else if (bindingKey.getAnnotationType() != null) {
            clonedKey = Key.get(bindingKey.getTypeLiteral(), bindingKey.getAnnotationType());
        } else {
            clonedKey = Key.get(bindingKey.getTypeLiteral());
        }
        assertEquals(bindingKey, clonedKey);
        assertEquals(""Incorrect hashcode for "" + bindingKey + "" -> "" + entry.getValue(), bindingKey.hashCode(), clonedKey.hashCode());
    }
} 
{
    final List<String> list = Lists.newArrayList();
    Module ab = new AbstractModule() {

        @Override
        protected void configure() {
            Multibinder<List<String>> multibinder = Multibinder.newSetBinder(binder(), listOfStrings);
            multibinder.addBinding().toInstance(list);
            list.add(""A"");
            list.add(""B"");
        }
    };
    InstanceBinding<?> binding = Elements.getElements(ab).stream().filter(InstanceBinding.class::isInstance).map(InstanceBinding.class::cast).collect(onlyElement());
    Key<?> keyBefore = binding.getKey();
    assertEquals(listOfStrings, keyBefore.getTypeLiteral());
    list.add(""C"");
    Key<?> keyAfter = binding.getKey();
    assertSame(keyBefore, keyAfter);
} 
",,,,,1,47
InternalProvisionExceptionTest.java,16,25,0.64,,,,,,,,1,0
TypeLiteralTypeResolutionTest.java,23,289,0.07958477508650519,"
 * This test checks that TypeLiteral can perform type resolution on its members.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Ensure the cache doesn't cache too much
 */
 
","{
    TypeLiteral<?> resolver = TypeLiteral.get(newParameterizedTypeWithOwner(getClass(), HasLists.class, String.class, Short.class));
    assertEquals(listOf(String.class), resolver.getReturnType(HasLists.class.getMethod(""listS"")).getType());
    assertEquals(listOf(Short.class), resolver.getReturnType(HasLists.class.getMethod(""listT"")).getType());
} 
",,,,,3,128
ReflectionTest.java,16,60,0.26666666666666666," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
BoundProviderTest.java,16,72,0.2222222222222222," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
TypeLiteralInjectionTest.java,20,85,0.23529411764705882,"
 * Demonstrates type reification.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,3,81
BinderTest.java,94,1351,0.0695780903034789," @author crazybob@google.com (Bob Lee) ","/**
 * Although {@code String[].class} isn't equal to {@code new GenericArrayTypeImpl(String.class)},
 * Guice should treat these two types interchangeably.
 */
 
/**
 * Binding something to two different things should give an error.
 */
 
/**
 * Binding an @ImplementedBy thing to something else should also fail.
 */
 
/**
 * See issue 614, Problem One https://github.com/google/guice/issues/614
 */
 
/**
 * See issue 614, Problem Two https://github.com/google/guice/issues/id=614
 */
 
/**
 * Untargetted bindings should follow @ImplementedBy and @ProvidedBy annotations if they exist.
 * Otherwise the class should be constructed directly.
 */
 
","{
    final String[] strings = new String[] { ""A"" };
    final Integer[] integers = new Integer[] { 1 };
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(String[].class).toInstance(strings);
            bind(new TypeLiteral<Integer[]>() {
            }).toInstance(integers);
        }
    });
    assertSame(integers, injector.getInstance(Key.get(new TypeLiteral<Integer[]>() {
    })));
    assertSame(integers, injector.getInstance(new Key<Integer[]>() {
    }));
    assertSame(integers, injector.getInstance(Integer[].class));
    assertSame(strings, injector.getInstance(Key.get(new TypeLiteral<String[]>() {
    })));
    assertSame(strings, injector.getInstance(new Key<String[]>() {
    }));
    assertSame(strings, injector.getInstance(String[].class));
    try {
        Guice.createInjector(new AbstractModule() {

            @Override
            protected void configure() {
                bind(String[].class).toInstance(new String[] { ""A"" });
                bind(new TypeLiteral<String[]>() {
                }).toInstance(new String[] { ""B"" });
            }
        });
        fail();
    } catch (CreationException expected) {
        assertContains(expected.getMessage(), ""1) A binding to java.lang.String[] was already configured at "" + getClass().getName(), ""at "" + getClass().getName(), getDeclaringSourcePart(getClass()));
        assertContains(expected.getMessage(), ""1 error"");
    }
    // passes because duplicates are ignored
    injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(String[].class).toInstance(strings);
            bind(new TypeLiteral<String[]>() {
            }).toInstance(strings);
        }
    });
    assertSame(strings, injector.getInstance(Key.get(new TypeLiteral<String[]>() {
    })));
    assertSame(strings, injector.getInstance(new Key<String[]>() {
    }));
    assertSame(strings, injector.getInstance(String[].class));
} 
{
    try {
        Guice.createInjector(new ParentModule());
        fail();
    } catch (CreationException expected) {
        assertContains(expected.getMessage(), ""1) A binding to java.lang.String was already configured at "" + ConstantModule.class.getName(), asModuleChain(ParentModule.class, FooModule.class, ConstantModule.class), ""at "" + ConstantModule.class.getName(), getDeclaringSourcePart(getClass()), asModuleChain(ParentModule.class, BarModule.class, ConstantModule.class));
        assertContains(expected.getMessage(), ""1 error"");
    }
} 
{
    try {
        Guice.createInjector(new AbstractModule() {

            @Override
            protected void configure() {
                bind(HasImplementedBy1.class);
                bind(HasImplementedBy1.class).toInstance(new HasImplementedBy1() {
                });
            }
        });
        fail();
    } catch (CreationException expected) {
        expected.printStackTrace();
        assertContains(expected.getMessage(), ""1) A binding to "" + HasImplementedBy1.class.getName() + "" was already configured at "" + getClass().getName(), ""at "" + getClass().getName(), getDeclaringSourcePart(getClass()));
        assertContains(expected.getMessage(), ""1 error"");
    }
} 
{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(HasImplementedByThatNeedsAnotherImplementedBy.class);
            bind(HasImplementedBy1.class).toInstance(new HasImplementedBy1() {
            });
        }
    });
    // just validate it doesn't throw.
    injector.getAllBindings();
    // Also validate that we're using the explicit (and not @ImplementedBy) implementation
    assertFalse(injector.getInstance(HasImplementedBy1.class) instanceof ImplementsHasImplementedBy1);
} 
{
    Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(HasImplementedByThatWantsExplicit.class);
            bind(JustAnInterface.class).toInstance(new JustAnInterface() {
            });
        }
    });
} 
{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(HasProvidedBy1.class);
            bind(HasImplementedBy1.class);
            bind(HasProvidedBy2.class);
            bind(HasImplementedBy2.class);
            bind(JustAClass.class);
        }
    });
    assertNotNull(injector.getInstance(HasProvidedBy1.class));
    assertNotNull(injector.getInstance(HasImplementedBy1.class));
    assertNotSame(HasProvidedBy2.class, injector.getInstance(HasProvidedBy2.class).getClass());
    assertSame(ExtendsHasImplementedBy2.class, injector.getInstance(HasImplementedBy2.class).getClass());
    assertSame(JustAClass.class, injector.getInstance(JustAClass.class).getClass());
} 
",,,,,1,39
EagerSingletonTest.java,35,142,0.24647887323943662," @author jessewilson@google.com (Jesse Wilson) ","/**
 * Creates a copy of a class in a child classloader.
 */
 
","{
    // To create a copy of a class we create a new child class loader with the same data as our
    // parent and override loadClass to always load a new copy of cls.
    try {
        return new URLClassLoader(getClassPathUrls(), EagerSingletonTest.class.getClassLoader()) {

            @Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                // This means for every class besides cls we delegate to our parent (so things like
                // @Singleton and Object are well defined), but for this one class we load a new one in
                // this loader.
                if (name.equals(cls.getName())) {
                    Class<?> c = findLoadedClass(name);
                    if (c == null) {
                        return super.findClass(name);
                    }
                    return c;
                }
                return super.loadClass(name);
            }
        }.loadClass(cls.getName());
    } catch (ClassNotFoundException cnfe) {
        throw new AssertionError(cnfe);
    }
} 
",,,,,1,47
MatcherTest.java,16,134,0.11940298507462686,,,,,,,,1,0
BinderTestSuite.java,20,729,0.027434842249657063," @author jessewilson@google.com (Jesse Wilson) | When Guice creates a value, directly or via a provider | This scope hands out each value exactly twice ",,,,,"/**
 * negative to throw, 101... for eager singletons, 201... for everything else
 */
 
","Field nextId
",1,152
PrivateModuleTest.java,33,590,0.05593220338983051," @author jessewilson@google.com (Jesse Wilson) | A second class, so we can see another name in the source list. ","/**
 * Ensure that when we've got errors in different private modules, Guice presents all errors in a
 * unified message.
 */
 
","{
    try {
        Guice.createInjector(new PrivateModule() {

            @Override
            public void configure() {
                bind(C.class);
            }
        }, new PrivateModule() {

            @Override
            public void configure() {
                bind(AB.class);
            }
        });
        fail();
    } catch (CreationException expected) {
        assertContains(expected.getMessage(), ""1) No implementation for "" + C.class.getName() + "" was bound."", ""at "" + getClass().getName(), getDeclaringSourcePart(getClass()), ""2) No implementation for "" + String.class.getName(), ""Named(value="" + Annotations.memberValueString(""a"") + "") was bound."", ""for field at "" + AB.class.getName() + "".a(PrivateModuleTest.java:"", ""3) No implementation for "" + String.class.getName(), ""Named(value="" + Annotations.memberValueString(""b"") + "") was bound."", ""for field at "" + AB.class.getName() + "".b(PrivateModuleTest.java:"", ""3 errors"");
    }
} 
",,,,,1,112
SuiteUtils.java,15,22,0.6818181818181818,,,,,,,,1,0
BindingAnnotationTest.java,16,152,0.10526315789473684," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
ElementsTest.java,29,1319,0.021986353297952996," @author jessewilson@google.com (Jesse Wilson) | Binder fidelity tests|end[AOP]| Business logic tests|
   * By extending this interface rather than FailingElementVisitor, the source of the error doesn't
   * need to contain the string {@code ElementsTest.java}.
   ","/**
 * Ensures the module performs the commands consistent with {@code visitors}.
 */
 
","{
    List<Element> elements = Elements.getElements(module);
    assertEquals(elements.size(), visitors.length);
    checkElements(elements, visitors);
} 
",,,,,3,260
ProviderMethodsTest.java,37,931,0.0397422126745435," @author crazybob@google.com (Bob Lee) ","/**
 * If the user installs provider methods for the module manually, that shouldn't cause a double
 * binding of the provider methods' types.
 */
 
","{
    Module installsSelf = new AbstractModule() {

        @Override
        protected void configure() {
            install(this);
            bind(Integer.class).toInstance(5);
        }

        @Provides
        public String provideString(Integer count) {
            return ""A"" + count;
        }
    };
    Injector injector = Guice.createInjector(installsSelf);
    assertEquals(""A5"", injector.getInstance(String.class));
} 
",,,,,1,39
BindingTargetVisitorTest.java,20,13,1.5384615384615385,"
 * Simple little test that should compile. Ensures that wildcards on the generics are correct.
 *
 * @author phopkins@gmail.com
 ",,,,,,,3,123
FailingBindingScopingVisitor.java,15,22,0.6818181818181818,,,,,,,,1,0
ModuleRewriterTest.java,23,83,0.27710843373493976," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
ElementApplyToTest.java,17,8,2.125," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
InjectorSpiTest.java,14,343,0.04081632653061224," @author sberlin@gmail.com (Sam Berlin) ",,,,,,,1,40
ModuleSourceTest.java,4,105,0.0380952380952381," Tests for {@link ModuleSource}. ",,,,,,,1,33
ToolStageInjectorTest.java,0,181,0.0,,,,,,,,1,0
ElementSourceTest.java,16,148,0.10810810810810811," Tests for {@link ElementSource}. ",,,,,,,1,34
SpiBindingsTest.java,22,446,0.04932735426008968," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
MessageTest.java,2,19,0.10526315789473684," Tests for {@link Message}. ",,,,,,,1,28
FailingTargetVisitor.java,15,9,1.6666666666666667,,,,,,,,1,0
InjectionPointTest.java,40,350,0.11428571428571428," @author jessewilson@google.com (Jesse Wilson) ","/**
 * This test serves two purposes: 1) It makes sure that the bridge methods javax generates don't
 * stop us from injecting superclass methods in the case of javax.inject.Inject. This would happen
 * prior to java8 (where javac didn't copy annotations from the superclass into the subclass
 * method when it generated the bridge methods).
 *
 * <p>2) It makes sure that the methods we're going to inject have the correct generic types.
 * Java8 copies the annotations from super to subclasses, but it doesn't copy the generic type
 * information. Guice would naively consider the subclass an injectable method and eject the
 * superclass from the 'overrideIndex', leaving only a class with improper generic types.
 */
 
/**
 * Asserts that each injection point has the specified dependencies, in the given order.
 */
 
","{
    Set<InjectionPoint> points;
    points = InjectionPoint.forInstanceMethodsAndFields(RestrictedSuper.class);
    assertPointDependencies(points, new TypeLiteral<Provider<String>>() {
    });
    assertEquals(points.toString(), 2, points.size());
    assertPoints(points, RestrictedSuper.class, ""jInject"", ""gInject"");
    points = InjectionPoint.forInstanceMethodsAndFields(ExposedSub.class);
    assertPointDependencies(points, new TypeLiteral<Provider<String>>() {
    });
    assertEquals(points.toString(), 2, points.size());
    assertPoints(points, RestrictedSuper.class, ""jInject"", ""gInject"");
} 
{
    for (InjectionPoint point : points) {
        assertEquals(literals.length, point.getDependencies().size());
        for (Dependency<?> dep : point.getDependencies()) {
            assertEquals(literals[dep.getParameterIndex()], dep.getKey().getTypeLiteral());
        }
    }
} 
",,,,,1,47
HasDependenciesTest.java,17,78,0.21794871794871795," @author jessewilson@google.com (Jesse Wilson) ","/**
 * When an instance implements HasDependencies, the injected dependencies aren't used.
 */
 
","{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(A.class).toInstance(new AWithDependencies());
        }
    });
    InstanceBinding<?> binding = (InstanceBinding<?>) injector.getBinding(A.class);
    assertEquals(ImmutableSet.<Dependency<?>>of(Dependency.get(Key.get(Integer.class))), binding.getDependencies());
} 
",,,,,1,47
ModuleAnnotatedMethodScannerTest.java,21,484,0.04338842975206612," Tests for {@link ModuleAnnotatedMethodScanner} usage. ",,,,,,,1,55
FailingElementVisitor.java,15,8,1.875,,,,,,,,1,0
ParentInjectorTest.java,15,312,0.04807692307692308," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
BoundInstanceInjectionTest.java,16,107,0.14953271028037382," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
RequireAtInjectOnConstructorsTest.java,22,204,0.10784313725490197,"
 * Tests for {@link Binder#requireAtInjectOnConstructors()}
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,99
BindingTest.java,37,534,0.06928838951310862,"end[AOP]|
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * This test ensures that the asEagerSingleton() scoping applies to the key,
 * not to what the key is linked to.
 */
 
","{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Integer.class).toProvider(Counter.class).asEagerSingleton();
            bind(Number.class).toProvider(Counter.class).asEagerSingleton();
        }
    });
    assertNotSame(injector.getInstance(Integer.class), injector.getInstance(Number.class));
} 
",,,,,2,49
DuplicateBindingsTest.java,48,570,0.08421052631578947,"
 * A suite of tests for duplicate bindings.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,83
JitBindingsTest.java,59,705,0.08368794326241134,"
 * Some tests for {@link Binder#requireExplicitBindings()}
 *
 * @author sberlin@gmail.com (Sam Berlin)
 ",,,,,,,3,99
SerializationTest.java,16,35,0.45714285714285713," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
CircularDependencyTest.java,51,634,0.0804416403785489,"
 * @author crazybob@google.com (Bob Lee)
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * As reported by issue 349, we give a lousy trace when a class is circularly dependent on itself
 * in multiple ways.
 */
 
/**
 * Tests that ProviderInternalFactory can detect circular dependencies before it gets to
 * Scopes.SINGLETON. This is especially important because the failure in Scopes.SINGLETON doesn't
 * have enough context to provide a decent error message.
 */
 
/**
 * When Scope Providers call their unscoped Provider's get() methods are called, it's possible
 * that the result is a circular proxy designed for one specific parameter (not for all possible
 * parameters). But custom scopes typically cache the results without checking to see if the
 * result is a proxy. This leads to caching a result that is unsuitable for reuse for other
 * parameters.
 *
 * <p>This means that custom proxies have to do an {@code if(Scopes.isCircularProxy(..))} in order
 * to avoid exceptions.
 */
 
","{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            binder.bind(A.class).to(E.class);
            binder.bind(B.class).to(E.class);
        }
    });
    injector.getInstance(A.class);
} 
{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Number.class).to(Integer.class);
        }

        @Provides
        @Singleton
        Integer provideInteger(List list) {
            return 2;
        }

        @Provides
        List provideList(Integer integer) {
            return new ArrayList();
        }
    });
    try {
        injector.getInstance(Number.class);
        fail();
    } catch (ProvisionException expected) {
        assertContains(expected.getMessage(), ""Tried proxying "" + Integer.class.getName() + "" to support a circular dependency, "", ""but it is not an interface."");
    }
} 
{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bindScope(SimpleSingleton.class, new BasicSingleton());
            bind(H.class).to(HImpl.class);
            bind(I.class).to(IImpl.class);
            bind(J.class).to(JImpl.class);
        }
    });
    // The reason this happens is because the Scope gets these requests, in order:
    // entry: Key<IImpl> (1 - from getInstance call)
    // entry: Key<HImpl>
    // entry: Key<IImpl> (2 - circular dependency from HImpl)
    // result of 2nd Key<IImpl> - a com.google.inject.$Proxy, because it's a circular proxy
    // result of Key<HImpl> - an HImpl
    // entry: Key<JImpl>
    // entry: Key<IImpl> (3 - another circular dependency, this time from JImpl)
    // At this point, if the first Key<Impl> result was cached, our cache would have
    // Key<IImpl> caching to an instanceof of I, but not an an instanceof of IImpl.
    // If returned this, it would result in cglib giving a ClassCastException or
    // java reflection giving an IllegalArgumentException when filling in parameters
    // for the constructor, because JImpl wants an IImpl, not an I.
    try {
        injector.getInstance(IImpl.class);
        fail();
    } catch (ProvisionException pe) {
        assertContains(Iterables.getOnlyElement(pe.getErrorMessages()).getMessage(), ""Tried proxying "" + IImpl.class.getName() + "" to support a circular dependency, but it is not an interface."");
    }
} 
",,,,,2,79
IntegrationTest.java,36,348,0.10344827586206896," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
InjectorTest.java,17,352,0.048295454545454544,,,,,,,,1,0
SuperclassTest.java,16,32,0.5," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
ScopesTest.java,88,1105,0.07963800904977375," @author crazybob@google.com (Bob Lee) |
   * Tests that different injectors should not affect each other.
   *
   * <p>This creates a second thread to work in parallel, to create two instances of {@link S} as
   * the same time. If the lock if not granular enough (i.e. JVM-wide) then they would block each
   * other creating a deadlock and await timeout.
   |
   * Tests that injector can create two singletons with circular dependency in parallel.
   *
   * <p>This creates two threads to work in parallel, to create instances of {@link G} and {@link
   * H}. Creation is synchronized by injection of {@link S}, first thread would block until second
   * would be inside a singleton creation as well.
   *
   * <p>Both instances are created by sibling injectors, that share singleton scope. Verifies that
   * exactly one circular proxy object is created.
   |
   * Check that circular dependencies on non-interfaces are correctly resolved in multi-threaded
   * case. And that an error message constructed is a good one.
   *
   * <p>I0 -> I1 -> I2 -> J1 and J0 -> J1 -> J2 -> K1 and K0 -> K1 -> K2, where I1, J1 and K1 are
   * created in parallel.
   *
   * <p>Creation is synchronized by injection of {@link S}, first thread would block until second
   * would be inside a singleton creation as well.
   *
   * <p>Verifies that provision results in an error, that spans two threads and has a dependency
   * cycle.
   | Test for https://github.com/google/guice/issues/1032| suppress compiler error for testing|
   * Tests that different injectors should not affect each other.
   *
   * <p>This creates a second thread to work in parallel, to create two instances of {@link S} as
   * the same time. If the lock if not granular enough (i.e. JVM-wide) then they would block each
   * other creating a deadlock and await timeout.
   |
   * Tests that injector can create two singletons with circular dependency in parallel.
   *
   * <p>This creates two threads to work in parallel, to create instances of {@link G} and {@link
   * H}. Creation is synchronized by injection of {@link S}, first thread would block until second
   * would be inside a singleton creation as well.
   *
   * <p>Both instances are created by sibling injectors, that share singleton scope. Verifies that
   * exactly one circular proxy object is created.
   |
   * Check that circular dependencies on non-interfaces are correctly resolved in multi-threaded
   * case. And that an error message constructed is a good one.
   *
   * <p>I0 -> I1 -> I2 -> J1 and J0 -> J1 -> J2 -> K1 and K0 -> K1 -> K2, where I1, J1 and K1 are
   * created in parallel.
   *
   * <p>Creation is synchronized by injection of {@link S}, first thread would block until second
   * would be inside a singleton creation as well.
   *
   * <p>Verifies that provision results in an error, that spans two threads and has a dependency
   * cycle.
   | Test for https://github.com/google/guice/issues/1032|
   * Should only be created by {@link SBarrierProvider}.
   *
   * <p>{@code S} stands for synchronization.
   *
   * @see SBarrierProvider
   |
   * Tests that different injectors should not affect each other.
   *
   * <p>This creates a second thread to work in parallel, to create two instances of {@link S} as
   * the same time. If the lock if not granular enough (i.e. JVM-wide) then they would block each
   * other creating a deadlock and await timeout.
   |
   * Tests that injector can create two singletons with circular dependency in parallel.
   *
   * <p>This creates two threads to work in parallel, to create instances of {@link G} and {@link
   * H}. Creation is synchronized by injection of {@link S}, first thread would block until second
   * would be inside a singleton creation as well.
   *
   * <p>Both instances are created by sibling injectors, that share singleton scope. Verifies that
   * exactly one circular proxy object is created.
   |
   * Check that circular dependencies on non-interfaces are correctly resolved in multi-threaded
   * case. And that an error message constructed is a good one.
   *
   * <p>I0 -> I1 -> I2 -> J1 and J0 -> J1 -> J2 -> K1 and K0 -> K1 -> K2, where I1, J1 and K1 are
   * created in parallel.
   *
   * <p>Creation is synchronized by injection of {@link S}, first thread would block until second
   * would be inside a singleton creation as well.
   *
   * <p>Verifies that provision results in an error, that spans two threads and has a dependency
   * cycle.
   | Test for https://github.com/google/guice/issues/1032|
   * Provides all the instances of S simultaneously using {@link CyclicBarrier} with {@code
   * nThreads}. Intended to be used for threads synchronization during injection.
   |
   * Tests that different injectors should not affect each other.
   *
   * <p>This creates a second thread to work in parallel, to create two instances of {@link S} as
   * the same time. If the lock if not granular enough (i.e. JVM-wide) then they would block each
   * other creating a deadlock and await timeout.
   |
   * Tests that injector can create two singletons with circular dependency in parallel.
   *
   * <p>This creates two threads to work in parallel, to create instances of {@link G} and {@link
   * H}. Creation is synchronized by injection of {@link S}, first thread would block until second
   * would be inside a singleton creation as well.
   *
   * <p>Both instances are created by sibling injectors, that share singleton scope. Verifies that
   * exactly one circular proxy object is created.
   |
   * Check that circular dependencies on non-interfaces are correctly resolved in multi-threaded
   * case. And that an error message constructed is a good one.
   *
   * <p>I0 -> I1 -> I2 -> J1 and J0 -> J1 -> J2 -> K1 and K0 -> K1 -> K2, where I1, J1 and K1 are
   * created in parallel.
   *
   * <p>Creation is synchronized by injection of {@link S}, first thread would block until second
   * would be inside a singleton creation as well.
   *
   * <p>Verifies that provision results in an error, that spans two threads and has a dependency
   * cycle.
   | Test for https://github.com/google/guice/issues/1032| Uses Scope's public API to add a 'marker' into the provisioned instance's scope. ",,,"/**
 * Relies on Guice implementation to inject S first and H later, which provides a barrier .
 */
 
/**
 * Relies on Guice implementation to inject S first and G later, which provides a barrier .
 */
 
/**
 * Relies on Guice implementation to inject S first, which provides a barrier .
 */
 
/**
 * Relies on Guice implementation to inject S first, which provides a barrier .
 */
 
/**
 * Relies on Guice implementation to inject S first, which provides a barrier .
 */
 
/**
 * Relies on Guice implementation to inject S first, which provides a barrier .
 */
 
/**
 * Relies on Guice implementation to inject S first, which provides a barrier .
 */
 
/**
 * Relies on Guice implementation to inject S first, which provides a barrier .
 */
 
/**
 * Relies on Guice implementation to inject S first, which provides a barrier .
 */
 
/**
 * Relies on Guice implementation to inject S first, which provides a barrier .
 */
 
/**
 * Relies on Guice implementation to inject S first, which provides a barrier .
 */
 
","{
    this.h = h;
} 
{
    this.g = g;
} 
{
} 
{
} 
{
} 
{
} 
{
} 
{
} 
{
} 
{
} 
{
} 
",,,118,6027
GenericInjectionTest.java,21,162,0.12962962962962962," @author crazybob@google.com (Bob Lee) ","/**
 * Although we may not have intended to support this behaviour, this test passes under Guice 1.0.
 * The workaround is to add an explicit binding for the parameterized type. See {@link
 * #testExplicitBindingOfGenericType()}.
 */
 
","{
    Parameterized<String> parameterized = Guice.createInjector().getInstance(Key.get(new TypeLiteral<Parameterized<String>>() {
    }));
    assertNotNull(parameterized);
} 
",,,,,1,39
Asserts.java,54,157,0.34394904458598724," @author jessewilson@google.com (Jesse Wilson) ","/**
 * Returns the String that would appear in an error message for this chain of classes as modules.
 */
 
/**
 * Returns the source file appears in error messages based on {@link
 * #getIncludeStackTraceOption()} value.
 */
 
/**
 * Returns true if {@link #getIncludeStackTraceOption()} returns {@link
 * IncludeStackTraceOption#OFF}.
 */
 
/**
 * Returns true if {@link #getIncludeStackTraceOption()} returns {@link
 * IncludeStackTraceOption#COMPLETE}.
 */
 
/**
 * Fails unless {@code expected.equals(actual)}, {@code actual.equals(expected)} and their hash
 * codes are equal. This is useful for testing the equals method itself.
 */
 
/**
 * Fails unless {@code text} includes all {@code substrings}, in order, no duplicates
 */
 
/**
 * Fails unless {@code text} includes all {@code substrings}, in order, and optionally {@code
 * allowDuplicates}.
 */
 
/**
 * Fails unless {@code object} doesn't equal itself when reserialized.
 */
 
/**
 * Fails unless {@code object} has the same toString value when reserialized.
 */
 
","{
    return Joiner.on("" -> "").appendTo(new StringBuilder("" (via modules: ""), Iterables.transform(ImmutableList.copyOf(classes), Class::getName)).append("")"").toString();
} 
{
    if (getIncludeStackTraceOption() == IncludeStackTraceOption.OFF) {
        return "".configure(Unknown Source"";
    }
    return "".configure("" + clazz.getSimpleName() + "".java:"";
} 
{
    return getIncludeStackTraceOption() == IncludeStackTraceOption.OFF;
} 
{
    return getIncludeStackTraceOption() == IncludeStackTraceOption.COMPLETE;
} 
{
    assertNotNull(expected);
    assertNotNull(actual);
    assertEquals(""expected.equals(actual)"", actual, expected);
    assertEquals(""actual.equals(expected)"", expected, actual);
    assertEquals(""hashCode"", expected.hashCode(), actual.hashCode());
} 
{
    assertContains(text, false, substrings);
} 
{
    /*if[NO_AOP]
    // when we strip out bytecode manipulation, we lose the ability to generate some source lines.
    if (text.contains(""(Unknown Source)"")) {
      return;
    }
    end[NO_AOP]*/
    int startingFrom = 0;
    for (String substring : substrings) {
        int index = text.indexOf(substring, startingFrom);
        assertTrue(String.format(""Expected \""%s\"" to contain substring \""%s\"""", text, substring), index >= startingFrom);
        startingFrom = index + substring.length();
    }
    if (!allowDuplicates) {
        String lastSubstring = substrings[substrings.length - 1];
        assertTrue(String.format(""Expected \""%s\"" to contain substring \""%s\"" only once),"", text, lastSubstring), text.indexOf(lastSubstring, startingFrom) == -1);
    }
} 
{
    Object reserialized = reserialize(object);
    assertEquals(object, reserialized);
    assertEquals(object.hashCode(), reserialized.hashCode());
} 
{
    Object reserialized = reserialize(object);
    assertEquals(object.toString(), reserialized.toString());
} 
",,,,,1,47
ModulesTest.java,17,56,0.30357142857142855," @author jessewilson@google.com (Jesse Wilson) ","/**
 * The module returned by Modules.combine shouldn't show up in binder sources.
 */
 
","{
    final Module m1 = newModule(1);
    final Module m2 = newModule(2L);
    final Module combined1 = Modules.combine(m1, m2);
    Module skipSourcesModule = new AbstractModule() {

        @Override
        protected void configure() {
            install(combined1);
        }
    };
    // returns skipSourcesModule
    final Module combined2 = Modules.combine(skipSourcesModule);
    Injector injector = Guice.createInjector(combined2);
    ElementSource source = (ElementSource) injector.getBinding(Integer.class).getSource();
    assertEquals(3, source.getModuleClassNames().size());
    assertEquals(ImmutableList.of(m1.getClass().getName(), combined1.getClass().getName(), skipSourcesModule.getClass().getName()), source.getModuleClassNames());
    StackTraceElement stackTraceElement = (StackTraceElement) source.getDeclaringSource();
    assertEquals(skipSourcesModule.getClass().getName(), stackTraceElement.getClassName());
} 
",,,,,1,47
ProvisionExceptionsTest.java,26,160,0.1625,"
 * Tests that ProvisionExceptions are readable and clearly indicate to the user what went wrong with
 * their code.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,4,153
NamedEquivalanceTest.java,23,227,0.1013215859030837,"
 * Tests that {@code javax.inject.Named} and {@code com.google.inject.name.Named} are completely
 * interchangeable: bindings for one can be used to inject the other.
 *
 * @author cgdecker@gmail.com (Colin Decker)
 ",,,,,,,4,208
NamesTest.java,16,83,0.1927710843373494," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
ModuleTest.java,19,827,0.022974607013301087,"
 * Tests relating to modules.
 *
 * @author kevinb
 ",,,,,,,3,46
ProvisionExceptionTest.java,31,404,0.07673267326732673," @author jessewilson@google.com (Jesse Wilson) | The only way to trigger an exception with _multiple_ user controlled throwables is by|
   * In Scala, fields automatically get accessor methods with the same name. So we don't do
   * misplaced-binding annotation detection if the offending method has a matching field.
   ","/**
 * There's a pass-through of user code in the scope. We want exceptions thrown by Guice to be
 * limited to a single exception, even if it passes through user code.
 */
 
/**
 * This test demonstrates that if the user throws a ProvisionException, we wrap it to add context.
 */
 
","{
    try {
        Guice.createInjector(new AbstractModule() {

            @Override
            protected void configure() {
                bind(B.class).in(Scopes.SINGLETON);
            }
        }).getInstance(A.class);
        fail();
    } catch (ProvisionException e) {
        assertTrue(e.getCause() instanceof UnsupportedOperationException);
        assertFalse(e.getMessage().contains(""custom provider""));
        assertContains(e.getMessage(), ""Error injecting constructor"", ""for the 1st parameter of com.google.inject.ProvisionExceptionTest$C.setD"", ""for field at com.google.inject.ProvisionExceptionTest$B.c"", ""for the 1st parameter of com.google.inject.ProvisionExceptionTest$A"");
    }
} 
{
    try {
        Guice.createInjector().getInstance(F.class);
        fail();
    } catch (ProvisionException e) {
        assertContains(e.getMessage(), ""1) User Exception"", ""at "" + F.class.getName() + "".<init>(ProvisionExceptionTest.java:"");
    }
} 
",,,,,3,316
BindingOrderTest.java,17,73,0.2328767123287671,,,,,,,,1,0
PerformanceComparison.java,24,225,0.10666666666666667,"
 * A semi-useless microbenchmark. Spring and Guice constuct the same object graph a bunch of times,
 * and we see who can construct the most per second. As of this writing Guice is more than 50X
 * faster. Also useful for comparing pure Java configuration options.
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,5,300
ImplicitBindingTest.java,72,314,0.22929936305732485," @author crazybob@google.com (Bob Lee) | An enum cannot be implemented by anything, so it should not be possible to have a successful| Valid JITable binding","/**
 * When we're building the binding for A, we temporarily insert that binding to support circular
 * dependencies. And so we can successfully create a binding for B. But later, when the binding
 * for A ultimately fails, we need to clean up the dependent binding for B.
 *
 * <p>The test loops through linked bindings & bindings with constructor & member injections, to
 * make sure that all are cleaned up and traversed. It also makes sure we don't touch explicit
 * bindings.
 */
 
/**
 * Regression test for https://github.com/google/guice/issues/319
 *
 * <p>The bug is that a class that asks for a provider for itself during injection time, where any
 * one of the other types required to fulfill the object creation was bound in a child
 * constructor, explodes when the injected Provider is called.
 *
 * <p>It works just fine when the other types are bound in a main injector.
 */
 
/**
 * Ensure that when we cleanup failed JIT bindings, we don't break. The test here requires a
 * sequence of JIT bindings:
 *
 * <ol>
 * <li> A-> B
 * <li> B -> C, A
 * <li> C -> A, D
 * <li> D not JITable
 * </ol>
 *
 * <p>The problem was that C cleaned up A's binding and then handed control back to B, which tried
 * to continue processing A.. but A was removed from the jitBindings Map, so it attempts to create
 * a new JIT binding for A, but we haven't yet finished constructing the first JIT binding for A,
 * so we get a recursive computation exception from ComputingConcurrentHashMap.
 *
 * <p>We also throw in a valid JIT binding, E, to guarantee that if something fails in this flow,
 * it can be recreated later if it's not from a failed sequence.
 */
 
","{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Valid.class);
            bind(Valid2.class);
        }
    });
    // Capture good bindings.
    Binding v1 = injector.getBinding(Valid.class);
    Binding v2 = injector.getBinding(Valid2.class);
    Binding jv1 = injector.getBinding(JitValid.class);
    Binding jv2 = injector.getBinding(JitValid2.class);
    // Then validate that a whole series of invalid bindings are erased.
    assertFailure(injector, Invalid.class);
    assertFailure(injector, InvalidLinked.class);
    assertFailure(injector, InvalidLinkedImpl.class);
    assertFailure(injector, InvalidLinked2.class);
    assertFailure(injector, InvalidLinked2Impl.class);
    assertFailure(injector, InvalidProvidedBy.class);
    assertFailure(injector, InvalidProvidedByProvider.class);
    assertFailure(injector, InvalidProvidedBy2.class);
    assertFailure(injector, InvalidProvidedBy2Provider.class);
    assertFailure(injector, Invalid2.class);
    // Validate we didn't do anything to the valid explicit bindings.
    assertSame(v1, injector.getBinding(Valid.class));
    assertSame(v2, injector.getBinding(Valid2.class));
    // Validate that we didn't erase the valid JIT bindings
    assertSame(jv1, injector.getBinding(JitValid.class));
    assertSame(jv2, injector.getBinding(JitValid2.class));
} 
{
    final Module testModule = new AbstractModule() {

        @Override
        protected void configure() {
            bind(String.class).toProvider(TestStringProvider.class);
        }
    };
    // Verify it works when the type is setup in the parent.
    Injector parentSetupRootInjector = Guice.createInjector(testModule);
    Injector parentSetupChildInjector = parentSetupRootInjector.createChildInjector();
    assertEquals(TestStringProvider.TEST_VALUE, parentSetupChildInjector.getInstance(RequiresProviderForSelfWithOtherType.class).getValue());
    // Verify it works when the type is setup in the child, not the parent.
    // If it still occurs, the bug will explode here.
    Injector childSetupRootInjector = Guice.createInjector();
    Injector childSetupChildInjector = childSetupRootInjector.createChildInjector(testModule);
    assertEquals(TestStringProvider.TEST_VALUE, childSetupChildInjector.getInstance(RequiresProviderForSelfWithOtherType.class).getValue());
} 
{
    Injector injector = Guice.createInjector();
    try {
        injector.getInstance(A.class);
        fail(""Expected failure"");
    } catch (ConfigurationException expected) {
        Message msg = Iterables.getOnlyElement(expected.getErrorMessages());
        Asserts.assertContains(msg.getMessage(), ""No implementation for "" + D.class.getName() + "" (with no qualifier annotation) was bound, and could not find an injectable"" + "" constructor"");
    }
    // Assert that we've removed all the bindings.
    assertNull(injector.getExistingBinding(Key.get(A.class)));
    assertNull(injector.getExistingBinding(Key.get(B.class)));
    assertNull(injector.getExistingBinding(Key.get(C.class)));
    assertNull(injector.getExistingBinding(Key.get(D.class)));
    // Confirm that we didn't prevent 'E' from working.
    assertNotNull(injector.getBinding(Key.get(E.class)));
} 
",,,,,1,156
Jsr330Test.java,21,443,0.04740406320541761,,"/**
 * This test verifies that we can compile bindings to provider instances whose compile-time type
 * implements javax.inject.Provider but not com.google.inject.Provider. For binary compatibility,
 * we don't (and won't) support binding to instances of javax.inject.Provider.
 */
 
","{
    Injector injector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(B.class).toProvider(BProvider.class);
            bind(B.class).annotatedWith(Names.named(""1"")).toProvider(BProvider.class);
            bind(B.class).annotatedWith(Names.named(""2"")).toProvider(Key.get(BProvider.class));
            bind(B.class).annotatedWith(Names.named(""3"")).toProvider(TypeLiteral.get(BProvider.class));
        }
    });
    injector.getInstance(Key.get(B.class));
    injector.getInstance(Key.get(B.class, Names.named(""1"")));
    injector.getInstance(Key.get(B.class, Names.named(""2"")));
    injector.getInstance(Key.get(B.class, Names.named(""3"")));
} 
",,,,,1,0
GuiceTck.java,15,45,0.3333333333333333,,,,,,,,1,0
BytecodeGenTest.java,79,302,0.26158940397350994,"
 * This test is in a separate package so we can test package-level visibility with confidence.
 *
 * @author mcculls@gmail.com (Stuart McCulloch)
 | TODO(sameb): Figure out how to test FastClass naming tests.| This tests for a situation where a osgi bundle contains a version of guice.  When guice| This classloader simulates an OSGI environment where a bundle has a conflicting definition of| cglib (or guice).  This is sort of the opposite of the BridgeClassloader and is meant to test| Custom URL classloader with basic visibility rules | TODO(sameb): Figure out how to test FastClass naming tests.| This tests for a situation where a osgi bundle contains a version of guice.  When guice| This classloader simulates an OSGI environment where a bundle has a conflicting definition of| cglib (or guice).  This is sort of the opposite of the BridgeClassloader and is meant to test|
   * Note: this class must be marked as public or protected so that the Guice custom classloader
   * will intercept it. Private and implementation classes are not intercepted by the custom
   * classloader.
   *
   * @see com.google.inject.internal.BytecodeGen.Visibility
   | TODO(sameb): Figure out how to test FastClass naming tests.| This tests for a situation where a osgi bundle contains a version of guice.  When guice| This classloader simulates an OSGI environment where a bundle has a conflicting definition of| cglib (or guice).  This is sort of the opposite of the BridgeClassloader and is meant to test| its use.","/**
 * Classic parent-delegating classloaders are meant to override findClass. However,
 * non-delegating classloaders (as used in OSGi) instead override loadClass to provide support
 * for ""class-space"" separation.
 */
 
/**
 * Classic parent-delegating classloaders are meant to override findClass. However,
 * non-delegating classloaders (as used in OSGi) instead override loadClass to provide support
 * for ""class-space"" separation.
 */
 
","{
    synchronized (this) {
        // check our local cache to avoid duplicates
        final Class<?> clazz = findLoadedClass(name);
        if (clazz != null) {
            return clazz;
        }
    }
    if (name.startsWith(""java."")) {
        // standard bootdelegation of java.*
        return super.loadClass(name, resolve);
    } else if (!name.contains("".internal."") && !name.contains("".cglib."")) {
        /*
         * load public and test classes directly from the classpath - we don't
         * delegate to our parent because then the loaded classes would also be
         * able to see private internal Guice classes, as they are also loaded
         * by the parent classloader.
         */
        final Class<?> clazz = findClass(name);
        if (resolve) {
            resolveClass(clazz);
        }
        return clazz;
    }
    // hide internal non-test classes
    if (hideInternals) {
        throw new ClassNotFoundException();
    }
    return super.loadClass(name, resolve);
} 
{
    synchronized (this) {
        // check our local cache to avoid duplicates
        final Class<?> clazz = findLoadedClass(name);
        if (clazz != null) {
            return clazz;
        }
    }
    if (name.startsWith(""java."") || name.startsWith(""javax."") || name.equals(LogCreator.class.getName()) || (!name.startsWith(""com.google.inject."") && !name.contains("".cglib."") && !name.startsWith(""com.googlecode.guice""))) {
        // standard parent delegation
        return super.loadClass(name, resolve);
    } else {
        // load a new copy of the class
        final Class<?> clazz = findClass(name);
        if (resolve) {
            resolveClass(clazz);
        }
        return clazz;
    }
} 
",,,"/**
 * as loaded by another class loader
 */
 
","Field proxyTestClass
",10,1491
PackageVisibilityTestModule.java,0,17,0.0,,,,,,,,1,0
OSGiTestActivator.java,38,342,0.1111111111111111,"
 * Test Guice from inside an OSGi bundle activator.
 *
 * @author mcculls@gmail.com (Stuart McCulloch)
 | varying visibilities to test our code-generation support|if[AOP]|end[AOP]| registers all the class combinations| varying visibilities to test our code-generation support|if[AOP]|end[AOP]| applies method-interception to classes with enough visibility",,,,,,,4,349
OSGiContainerTest.java,47,83,0.5662650602409639,"
 * Run various tests inside one or more OSGi containers.
 *
 * @author mcculls@gmail.com (Stuart McCulloch)
 ",,,,,,,3,103
Provides.java,33,13,2.5384615384615383,"
 * Annotates methods of a {@link Module} to create a provider method binding. The method's return
 * type is bound to its returned value. Guice will pass dependencies to the method as parameters.
 *
 * @author crazybob@google.com (Bob Lee)
 * @since 2.0
 ",,,,,,,5,245
OutOfScopeException.java,22,12,1.8333333333333333,"
 * Thrown from {@link Provider#get} when an attempt is made to access a scoped object while the
 * scope in question is not currently active.
 *
 * @author kevinb@google.com (Kevin Bourrillion)
 * @since 2.0
 ",,,,,,,5,199
Exposed.java,22,10,2.2,"
 * Acccompanies a {@literal @}{@link com.google.inject.Provides Provides} method annotation in a
 * private module to indicate that the provided binding is exposed.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ",,,,,,,5,222
ProvisionException.java,63,141,0.44680851063829785,"
 * Indicates that there was a runtime failure while providing an instance.
 *
 *
 * @author kevinb@google.com (Kevin Bourrillion)
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns messages for the errors that caused this exception.
 */
 
","{
    return messages;
} 
","/**
 * Creates a ProvisionException containing {@code messages}.
 */
 
","{
    this.messages = ImmutableSet.copyOf(messages);
    checkArgument(!this.messages.isEmpty());
    initCause(Messages.getOnlyCause(this.messages));
} 
",,,6,182
ScopeAnnotation.java,29,8,3.625,"
 * Annotates annotations which are used for scoping. Only one such annotation may apply to a single
 * implementation class. You must also annotate scope annotations with {@code @Retention(RUNTIME)}.
 * For example:
 *
 * <pre>
 *   {@code @}Retention(RUNTIME)
 *   {@code @}Target(TYPE, METHOD)
 *   {@code @}ScopeAnnotation
 *   public {@code @}interface SessionScoped {}
 * </pre>
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,12,405
ConfigurationException.java,32,34,0.9411764705882353,"
 * Thrown when a programming error such as a misplaced annotation, illegal binding, or unsupported
 * scope is found. Clients should catch this exception, log it, and stop execution.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns a copy of this configuration exception with the specified partial value.
 */
 
/**
 * Returns messages for the errors that caused this exception.
 */
 
/**
 * Returns a value that was only partially computed due to this exception. The caller can use this
 * while collecting additional configuration problems.
 *
 * @return the partial value, or {@code null} if none was set. The type of the partial value is
 *     specified by the throwing method.
 */
 
","{
    checkState(this.partialValue == null, ""Can't clobber existing partial value %s with %s"", this.partialValue, partialValue);
    ConfigurationException result = new ConfigurationException(messages);
    result.partialValue = partialValue;
    return result;
} 
{
    return messages;
} 
{
    return (E) partialValue;
} 
","/**
 * Creates a ConfigurationException containing {@code messages}.
 */
 
","{
    this.messages = com.google.common.collect.ImmutableSet.copyOf(messages);
    initCause(Messages.getOnlyCause(this.messages));
} 
",,,5,240
CreationException.java,23,22,1.0454545454545454,"
 * Thrown when errors occur while creating a {@link Injector}. Includes a list of encountered
 * errors. Clients should catch this exception, log it, and stop execution.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Returns messages for the errors that caused this exception.
 */
 
","{
    return messages;
} 
","/**
 * Creates a CreationException containing {@code messages}.
 */
 
","{
    this.messages = ImmutableSet.copyOf(messages);
    checkArgument(!this.messages.isEmpty());
    initCause(Messages.getOnlyCause(this.messages));
} 
",,,4,207
Stage.java,31,6,5.166666666666667,"
 * The stage we're running in.
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,3,70
Inject.java,43,14,3.0714285714285716,"
 * Annotates members of your implementation class (constructors, methods and fields) into which the
 * {@link Injector} should inject values. The Injector fulfills injection requests for:
 *
 * <ul>
 * <li>Every instance it constructs. The class being constructed must have exactly one of its
 *     constructors marked with {@code @Inject} or must have a constructor taking no parameters. The
 *     Injector then proceeds to perform field and method injections.
 * <li>Pre-constructed instances passed to {@link Injector#injectMembers}, {@link
 *     com.google.inject.binder.LinkedBindingBuilder#toInstance(Object)} and {@link
 *     com.google.inject.binder.LinkedBindingBuilder#toProvider(javax.inject.Provider)}. In this
 *     case all constructors are, of course, ignored.
 * <li>Static fields and methods of classes which any {@link Module} has specifically requested
 *     static injection for, using {@link Binder#requestStaticInjection}.
 * </ul>
 *
 * In all cases, a member can be injected regardless of its Java access specifier (private, default,
 * protected, public).
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,19,1094
PrivateModule.java,125,111,1.1261261261261262,"
 * A module whose configuration information is hidden from its environment by default. Only bindings
 * that are explicitly exposed will be available to other modules and to the users of the injector.
 * This module may expose the bindings it creates and the bindings of the modules it installs.
 *
 * <p>A private module can be nested within a regular module or within another private module using
 * {@link Binder#install install()}. Its bindings live in a new environment that inherits bindings,
 * type converters, scopes, and interceptors from the surrounding (""parent"") environment. When you
 * nest multiple private modules, the result is a tree of environments where the injector's
 * environment is the root.
 *
 * <p>Guice EDSL bindings can be exposed with {@link #expose(Class) expose()}. {@literal @}{@link
 * com.google.inject.Provides Provides} bindings can be exposed with the {@literal @}{@link Exposed}
 * annotation:
 *
 * <pre>
 * public class FooBarBazModule extends PrivateModule {
 *   protected void configure() {
 *     bind(Foo.class).to(RealFoo.class);
 *     expose(Foo.class);
 *
 *     install(new TransactionalBarModule());
 *     expose(Bar.class).annotatedWith(Transactional.class);
 *
 *     bind(SomeImplementationDetail.class);
 *     install(new MoreImplementationDetailsModule());
 *   }
 *
 *   {@literal @}Provides {@literal @}Exposed
 *   public Baz provideBaz() {
 *     return new SuperBaz();
 *   }
 * }
 * </pre>
 *
 * <p>Private modules are implemented using {@link Injector#createChildInjector(Module[]) parent
 * injectors}. When it can satisfy their dependencies, just-in-time bindings will be created in the
 * root environment. Such bindings are shared among all environments in the tree.
 *
 * <p>The scope of a binding is constrained to its environment. A singleton bound in a private
 * module will be unique to its environment. But a binding for the same type in a different private
 * module will yield a different instance.
 *
 * <p>A shared binding that injects the {@code Injector} gets the root injector, which only has
 * access to bindings in the root environment. An explicit binding that injects the {@code Injector}
 * gets access to all bindings in the child environment.
 *
 * <p>To promote a just-in-time binding to an explicit binding, bind it:
 *
 * <pre>
 *   bind(FooImpl.class);
 * </pre>
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Creates bindings and other configurations private to this module. Use {@link #expose(Class)
 * expose()} to make the bindings in this module available externally.
 */
 
/**
 * Makes the binding for {@code key} available to other modules and the injector.
 */
 
/**
 * Makes a binding for {@code type} available to other modules and the injector. Use {@link
 * AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 * binding annotation.
 */
 
/**
 * Makes a binding for {@code type} available to other modules and the injector. Use {@link
 * AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 * binding annotation.
 */
 
/**
 * Returns the current binder.
 */
 
/**
 * @see Binder#bindScope(Class, Scope)
 */
 
/**
 * @see Binder#bind(Key)
 */
 
/**
 * @see Binder#bind(TypeLiteral)
 */
 
/**
 * @see Binder#bind(Class)
 */
 
/**
 * @see Binder#bindConstant()
 */
 
/**
 * @see Binder#install(Module)
 */
 
/**
 * @see Binder#addError(String, Object[])
 */
 
/**
 * @see Binder#addError(Throwable)
 */
 
/**
 * @see Binder#addError(Message)
 */
 
/**
 * @see Binder#requestInjection(Object)
 */
 
/**
 * @see Binder#requestStaticInjection(Class[])
 */
 
/**
 * @see Binder#bindInterceptor(com.google.inject.matcher.Matcher,
 *     com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[])
 */
 
/**
 * Instructs Guice to require a binding to the given key.
 */
 
/**
 * Instructs Guice to require a binding to the given type.
 */
 
/**
 * @see Binder#getProvider(Key)
 */
 
/**
 * @see Binder#getProvider(Class)
 */
 
/**
 * @see Binder#convertToTypes(com.google.inject.matcher.Matcher,
 *     com.google.inject.spi.TypeConverter)
 */
 
/**
 * @see Binder#currentStage()
 */
 
/**
 * @see Binder#getMembersInjector(Class)
 */
 
/**
 * @see Binder#getMembersInjector(TypeLiteral)
 */
 
/**
 * @see Binder#bindListener(com.google.inject.matcher.Matcher, com.google.inject.spi.TypeListener)
 */
 
/**
 * @see Binder#bindListener(Matcher, ProvisionListener...)
 * @since 4.0
 */
 
","configure 
{
    binder().expose(key);
} 
{
    return binder().expose(type);
} 
{
    return binder().expose(type);
} 
{
    checkState(binder != null, ""The binder can only be used inside configure()"");
    return binder;
} 
{
    binder().bindScope(scopeAnnotation, scope);
} 
{
    return binder().bind(key);
} 
{
    return binder().bind(typeLiteral);
} 
{
    return binder().bind(clazz);
} 
{
    return binder().bindConstant();
} 
{
    binder().install(module);
} 
{
    binder().addError(message, arguments);
} 
{
    binder().addError(t);
} 
{
    binder().addError(message);
} 
{
    binder().requestInjection(instance);
} 
{
    binder().requestStaticInjection(types);
} 
{
    binder().bindInterceptor(classMatcher, methodMatcher, interceptors);
} 
{
    binder().getProvider(key);
} 
{
    binder().getProvider(type);
} 
{
    return binder().getProvider(key);
} 
{
    return binder().getProvider(type);
} 
{
    binder().convertToTypes(typeMatcher, converter);
} 
{
    return binder().currentStage();
} 
{
    return binder().getMembersInjector(type);
} 
{
    return binder().getMembersInjector(type);
} 
{
    binder().bindListener(typeMatcher, listener);
} 
{
    binder().bindListener(bindingMatcher, listeners);
} 
",,,"/**
 * Like abstract module, the binder of the current private module
 */
 
","Field binder
",54,2320
ClassMapKey.java,20,13,1.5384615384615385,"
 * Allows {@literal @}{@link ProvidesIntoMap} to specify a class map key.
 *
 * @since 4.0
 ",,,,,,,3,86
MultibindingsScanner.java,37,32,1.15625,"
 * Scans a module for annotations that signal multibindings, mapbindings, and optional bindings.
 *
 * @since 4.0
 * @deprecated This functionality is installed by default. All references to this can be safely
 *     removed. This class will be removed in Guice 4.4
 ","/**
 * Returns a module that, when installed, will scan all modules for methods with the annotations
 * {@literal @}{@link ProvidesIntoMap}, {@literal @}{@link ProvidesIntoSet}, and
 * {@literal @}{@link ProvidesIntoOptional}.
 *
 * <p>This is a convenience method, equivalent to doing {@code
 * binder().scanModulesForAnnotatedMethods(MultibindingsScanner.scanner())}.
 *
 * @deprecated This functionality is now installed by default. All references/installations can be
 *     eliminated.
 */
 
/**
 * @deprecated This method returns an empty scanner since the preexisting functionality is
 *     installed by default.
 */
 
","{
    return Modules.EMPTY_MODULE;
} 
{
    return new ModuleAnnotatedMethodScanner() {

        @Override
        public Set<? extends Class<? extends Annotation>> annotationClasses() {
            return ImmutableSet.of();
        }

        @Override
        public <T> Key<T> prepareMethod(Binder binder, Annotation annotation, Key<T> key, InjectionPoint injectionPoint) {
            throw new IllegalStateException(""Unexpected annotation: "" + annotation);
        }
    };
} 
",,,,,5,257
Multibinder.java,74,456,0.16228070175438597,"
 * An API to bind multiple values separately, only to later inject them as a complete collection.
 * Multibinder is intended for use in your application's module:
 *
 * <pre><code>
 * public class SnacksModule extends AbstractModule {
 *   protected void configure() {
 *     Multibinder&lt;Snack&gt; multibinder
 *         = Multibinder.newSetBinder(binder(), Snack.class);
 *     multibinder.addBinding().toInstance(new Twix());
 *     multibinder.addBinding().toProvider(SnickersProvider.class);
 *     multibinder.addBinding().to(Skittles.class);
 *   }
 * }</code></pre>
 *
 * <p>With this binding, a {@link Set}{@code <Snack>} can now be injected:
 *
 * <pre><code>
 * class SnackMachine {
 *   {@literal @}Inject
 *   public SnackMachine(Set&lt;Snack&gt; snacks) { ... }
 * }</code></pre>
 *
 * If desired, {@link Collection}{@code <Provider<Snack>>} can also be injected.
 *
 * <p>Contributing multibindings from different modules is supported. For example, it is okay for
 * both {@code CandyModule} and {@code ChipsModule} to create their own {@code Multibinder<Snack>},
 * and to each contribute bindings to the set of snacks. When that set is injected, it will contain
 * elements from both modules.
 *
 * <p>The set's iteration order is consistent with the binding order. This is convenient when
 * multiple elements are contributed by the same module because that module can order its bindings
 * appropriately. Avoid relying on the iteration order of elements contributed by different modules,
 * since there is no equivalent mechanism to order modules.
 *
 * <p>The set is unmodifiable. Elements can only be added to the set by configuring the multibinder.
 * Elements can never be removed from the set.
 *
 * <p>Elements are resolved at set injection time. If an element is bound to a provider, that
 * provider's get method will be called each time the set is injected (unless the binding is also
 * scoped).
 *
 * <p>Annotations are be used to create different sets of the same element type. Each distinct
 * annotation gets its own independent collection of elements.
 *
 * <p><strong>Elements must be distinct.</strong> If multiple bound elements have the same value,
 * set injection will fail.
 *
 * <p><strong>Elements must be non-null.</strong> If any set element is null, set injection will
 * fail.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 * itself bound with no binding annotation.
 */
 
/**
 * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 * itself bound with no binding annotation.
 */
 
/**
 * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 * itself bound with {@code annotation}.
 */
 
/**
 * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 * itself bound with {@code annotation}.
 */
 
/**
 * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 * itself bound with {@code annotationType}.
 */
 
/**
 * Returns a new multibinder that collects instances of the key's type in a {@link Set} that is
 * itself bound with the annotation (if any) of the key.
 *
 * @since 4.0
 */
 
/**
 * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 * itself bound with {@code annotationType}.
 */
 
/**
 * Configures the bound set to silently discard duplicate elements. When multiple equal values are
 * bound, the one that gets included is arbitrary. When multiple modules contribute elements to
 * the set, this configuration option impacts all of them.
 *
 * @return this multibinder
 * @since 3.0
 */
 
/**
 * Returns a binding builder used to add a new element in the set. Each bound element must have a
 * distinct value. Bound providers will be evaluated each time the set is injected.
 *
 * <p>It is an error to call this method without also calling one of the {@code to} methods on the
 * returned binding builder.
 *
 * <p>Scoping elements independently is supported. Use the {@code in} method to specify a binding
 * scope.
 */
 
","{
    return newSetBinder(binder, Key.get(type));
} 
{
    return newSetBinder(binder, Key.get(type));
} 
{
    return newSetBinder(binder, Key.get(type, annotation));
} 
{
    return newSetBinder(binder, Key.get(type, annotation));
} 
{
    return newSetBinder(binder, Key.get(type, annotationType));
} 
{
    return new Multibinder<T>(newRealSetBinder(binder.skipSources(Multibinder.class), key));
} 
{
    return newSetBinder(binder, Key.get(type, annotationType));
} 
{
    delegate.permitDuplicates();
    return this;
} 
{
    return delegate.addBinding();
} 
",,,,,51,2277
StringMapKey.java,20,13,1.5384615384615385,"
 * Allows {@literal @}{@link ProvidesIntoMap} to specify a string map key.
 *
 * @since 4.0
 ",,,,,,,3,87
ProvidesIntoSet.java,35,11,3.1818181818181817,"
 * Annotates methods of a {@link Module} to add items to a {@link Multibinder}. The method's return
 * type and binding annotation determines what Set this will contribute to. For example,
 *
 * <pre>
 * {@literal @}ProvidesIntoSet
 * {@literal @}Named(""urls"")
 * String provideFooUrl(FooManager fm) { returm fm.getUrl(); }
 *
 * {@literal @}ProvidesIntoSet
 * {@literal @}Named(""urls"")
 * String provideBarUrl(BarManager bm) { return bm.getUrl(); }
 * </pre>
 *
 * will add two items to the {@code @Named(""urls"") Set<String>} set. The items are bound as
 * providers and will be evaluated at injection time.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 4.0
 ",,,,,,,18,632
OptionalBinderBinding.java,64,13,4.923076923076923,"
 * A binding for a OptionalBinder.
 *
 * <p>Although OptionalBinders may be injected through a variety of types {@code V}, {@code
 * Optional<V>}, {@code Optional<Provider<V>>}, etc..), an OptionalBinderBinding exists only on the
 * Binding associated with the {@code Optional<V>} key. Injectable types can be discovered using
 * {@link #getKey} (which will return the {@code Optional<V>} key), or{@link #getAlternateKeys}
 * (which will return the other keys that can inject this data). Other bindings can be validated to
 * be derived from this OptionalBinderBinding using {@link #containsElement}.
 *
 * @param <T> The fully qualified type of the optional binding, including Optional. For example:
 *     {@code Optional<String>}.
 * @since 4.0
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Returns the {@link Key} for this binding.
 */
 
/**
 * Returns the keys of other bindings that represent this OptionalBinder. This will return an
 * entry for {@code Optional<com.google.inject.Provider<V>>} and {@code
 * Optional<javax.inject.Provider<V>>}.
 *
 * @since 5.0
 */
 
/**
 * Returns the default binding (set by {@link OptionalBinder#setDefault}) if one exists or null if
 * no default binding is set. This will throw {@link UnsupportedOperationException} if it is
 * called on an element retrieved from {@link Elements#getElements}.
 *
 * <p>The Binding's type will always match the type Optional's generic type. For example, if
 * getKey returns a key of <code>Optional&lt;String></code>, then this will always return a <code>
 * Binding&lt;String></code>.
 */
 
/**
 * Returns the actual binding (set by {@link OptionalBinder#setBinding}) or null if not set. This
 * will throw {@link UnsupportedOperationException} if it is called on an element retrieved from
 * {@link Elements#getElements}.
 *
 * <p>The Binding's type will always match the type Optional's generic type. For example, if
 * getKey returns a key of <code>Optional&lt;String></code>, then this will always return a <code>
 * Binding&lt;String></code>.
 */
 
/**
 * Returns true if this OptionalBinder contains the given Element in order to build the optional
 * binding or uses the given Element in order to support building and injecting its data. This
 * will work for OptionalBinderBinding retrieved from an injector and {@link
 * Elements#getElements}. Usually this is only necessary if you are working with elements
 * retrieved from modules (without an Injector), otherwise {@link #getDefaultBinding} and {@link
 * #getActualBinding} are better options.
 */
 
","getKey 
getAlternateKeys 
getDefaultBinding 
getActualBinding 
containsElement 
",,,,,13,764
ProvidesIntoOptional.java,39,17,2.2941176470588234,"
 * Annotates methods of a {@link Module} to add items to a {@link Multibinder}. The method's return
 * type and binding annotation determines what Optional this will contribute to. For example,
 *
 * <pre>
 * {@literal @}ProvidesIntoOptional(DEFAULT)
 * {@literal @}Named(""url"")
 * String provideFooUrl(FooManager fm) { returm fm.getUrl(); }
 *
 * {@literal @}ProvidesIntoOptional(ACTUAL)
 * {@literal @}Named(""url"")
 * String provideBarUrl(BarManager bm) { return bm.getUrl(); }
 * </pre>
 *
 * will set the default value of {@code @Named(""url"") Optional<String>} to foo's URL, and then
 * override it to bar's URL.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 4.0
 | @since 4.0 ",,,,,,,19,653
MultibindingsTargetVisitor.java,32,7,4.571428571428571,"
 * A visitor for the multibinder extension.
 *
 * <p>If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 * {@link Multibinder}, {@link MapBinder} or {@link OptionalBinderBinding} will be visited through
 * this interface.
 *
 * @since 3.0
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Visits a binding created through {@link Multibinder}.
 */
 
/**
 * Visits a binding created through {@link MapBinder}.
 */
 
/**
 * Visits a binding created through {@link OptionalBinder}.
 *
 * @since 4.0
 */
 
","visit 
visit 
visit 
",,,,,8,304
MapBinder.java,180,978,0.18404907975460122,"
 * An API to bind multiple map entries separately, only to later inject them as a complete map.
 * MapBinder is intended for use in your application's module:
 *
 * <pre><code>
 * public class SnacksModule extends AbstractModule {
 *   protected void configure() {
 *     MapBinder&lt;String, Snack&gt; mapbinder
 *         = MapBinder.newMapBinder(binder(), String.class, Snack.class);
 *     mapbinder.addBinding(""twix"").toInstance(new Twix());
 *     mapbinder.addBinding(""snickers"").toProvider(SnickersProvider.class);
 *     mapbinder.addBinding(""skittles"").to(Skittles.class);
 *   }
 * }</code></pre>
 *
 * <p>With this binding, a {@link Map}{@code <String, Snack>} can now be injected:
 *
 * <pre><code>
 * class SnackMachine {
 *   {@literal @}Inject
 *   public SnackMachine(Map&lt;String, Snack&gt; snacks) { ... }
 * }</code></pre>
 *
 * <p>In addition to binding {@code Map<K, V>}, a mapbinder will also bind {@code Map<K,
 * Provider<V>>} for lazy value provision:
 *
 * <pre><code>
 * class SnackMachine {
 *   {@literal @}Inject
 *   public SnackMachine(Map&lt;String, Provider&lt;Snack&gt;&gt; snackProviders) { ... }
 * }</code></pre>
 *
 * <p>Contributing mapbindings from different modules is supported. For example, it is okay to have
 * both {@code CandyModule} and {@code ChipsModule} both create their own {@code MapBinder<String,
 * Snack>}, and to each contribute bindings to the snacks map. When that map is injected, it will
 * contain entries from both modules.
 *
 * <p>The map's iteration order is consistent with the binding order. This is convenient when
 * multiple elements are contributed by the same module because that module can order its bindings
 * appropriately. Avoid relying on the iteration order of elements contributed by different modules,
 * since there is no equivalent mechanism to order modules.
 *
 * <p>The map is unmodifiable. Elements can only be added to the map by configuring the MapBinder.
 * Elements can never be removed from the map.
 *
 * <p>Values are resolved at map injection time. If a value is bound to a provider, that provider's
 * get method will be called each time the map is injected (unless the binding is also scoped, or a
 * map of providers is injected).
 *
 * <p>Annotations are used to create different maps of the same key/value type. Each distinct
 * annotation gets its own independent map.
 *
 * <p><strong>Keys must be distinct.</strong> If the same key is bound more than once, map injection
 * will fail. However, use {@link #permitDuplicates()} in order to allow duplicate keys; extra
 * bindings to {@code Map<K, Set<V>>} and {@code Map<K, Set<Provider<V>>} will be added.
 *
 * <p><strong>Keys must be non-null.</strong> {@code addBinding(null)} will throw an unchecked
 * exception.
 *
 * <p><strong>Values must be non-null to use map injection.</strong> If any value is null, map
 * injection will fail (although injecting a map of providers will not).
 *
 * @author dpb@google.com (David P. Baker)
 ","/**
 * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 * Map} that is itself bound with no binding annotation.
 */
 
/**
 * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 * Map} that is itself bound with no binding annotation.
 */
 
/**
 * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 * Map} that is itself bound with {@code annotation}.
 */
 
/**
 * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 * Map} that is itself bound with {@code annotation}.
 */
 
/**
 * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 * Map} that is itself bound with {@code annotationType}.
 */
 
/**
 * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 * Map} that is itself bound with {@code annotationType}.
 */
 
/**
 * Configures the {@code MapBinder} to handle duplicate entries.
 *
 * <p>When multiple equal keys are bound, the value that gets included in the map is arbitrary.
 *
 * <p>In addition to the {@code Map<K, V>} and {@code Map<K, Provider<V>>} maps that are normally
 * bound, a {@code Map<K, Set<V>>} and {@code Map<K, Set<Provider<V>>>} are <em>also</em> bound,
 * which contain all values bound to each key.
 *
 * <p>When multiple modules contribute elements to the map, this configuration option impacts all
 * of them.
 *
 * @return this map binder
 * @since 3.0
 */
 
/**
 * Returns a binding builder used to add a new entry in the map. Each key must be distinct (and
 * non-null). Bound providers will be evaluated each time the map is injected.
 *
 * <p>It is an error to call this method without also calling one of the {@code to} methods on the
 * returned binding builder.
 *
 * <p>Scoping elements independently is supported. Use the {@code in} method to specify a binding
 * scope.
 */
 
","{
    return new MapBinder<K, V>(newMapRealBinder(binder.skipSources(MapBinder.class), keyType, valueType));
} 
{
    return newMapBinder(binder, TypeLiteral.get(keyType), TypeLiteral.get(valueType));
} 
{
    return new MapBinder<K, V>(newRealMapBinder(binder.skipSources(MapBinder.class), keyType, valueType, annotation));
} 
{
    return newMapBinder(binder, TypeLiteral.get(keyType), TypeLiteral.get(valueType), annotation);
} 
{
    return new MapBinder<K, V>(newRealMapBinder(binder.skipSources(MapBinder.class), keyType, valueType, annotationType));
} 
{
    return newMapBinder(binder, TypeLiteral.get(keyType), TypeLiteral.get(valueType), annotationType);
} 
{
    delegate.permitDuplicates();
    return this;
} 
{
    return delegate.addBinding(key);
} 
",,,,,62,2869
MapBinderBinding.java,98,19,5.157894736842105,"
 * A binding for a MapBinder.
 *
 * <p>Although MapBinders may be injected through a variety of generic types ({@code Map<K, V>},
 * {@code Map<K, Provider<V>>}, {@code Map<K, Set<V>>}, {@ocde Map<K, Set<Provider<V>>}, and even
 * {@code Set<Map.Entry<K, Provider<V>>}), a MapBinderBinding exists only on the Binding associated
 * with the Map&lt;K, V> key. Injectable map types can be discovered using {@link #getMapKey} (which
 * will return the {@code Map<K, V>} key), or{@link #getAlternateMapKeys} (which will return the
 * other keys that can inject this data). Other bindings can be validated to be derived from this
 * MapBinderBinding using {@link #containsElement(Element)}.
 *
 * @param <T> The fully qualified type of the map, including Map. For example: {@code
 *     MapBinderBinding<Map<String, Snack>>}
 * @since 3.0
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Returns the {@link Key} for the map.
 */
 
/**
 * Returns the keys of other bindings that represent this map. This will return an entry for
 * {@code Map<K, com.google.inject.Provider<V>>}, {@code Map<K, javax.inject.Provider<V>>}, {@code
 * Map<K, Set<com.google.inject.Provider<V>>>}, {@code Map<K, Set<javax.inject.Provider<V>>>},
 * {@code Map<K, Collection<com.google.inject.Provider<V>>>}, {@code Map<K,
 * Collection<javax.inject.Provider<V>>>}, and {@code Map<K, Set<V>}.
 *
 * @since 5.0
 */
 
/**
 * Returns the TypeLiteral describing the keys of the map.
 *
 * <p>The TypeLiteral will always match the type Map's generic type. For example, if getMapKey
 * returns a key of <code>Map&lt;String, Snack></code>, then this will always return a <code>
 * TypeLiteral&lt;String></code>.
 */
 
/**
 * Returns the TypeLiteral describing the values of the map.
 *
 * <p>The TypeLiteral will always match the type Map's generic type. For example, if getMapKey
 * returns a key of <code>Map&lt;String, Snack></code>, then this will always return a <code>
 * TypeLiteral&lt;Snack></code>.
 */
 
/**
 * Returns all entries in the Map. The returned list of Map.Entries contains the key and a binding
 * to the value. Duplicate keys or values will exist as separate Map.Entries in the returned list.
 * This is only supported on bindings returned from an injector. This will throw {@link
 * UnsupportedOperationException} if it is called on an element retrieved from {@link
 * Elements#getElements}.
 *
 * <p>The elements will always match the type Map's generic type. For example, if getMapKey
 * returns a key of <code>Map&lt;String, Snack></code>, then this will always return a list of
 * type <code>List&lt;Map.Entry&lt;String, Binding&lt;Snack>>></code>.
 */
 
/**
 * Similar to {@link #getEntries()}, but can be used on a MapBinderBinding retrieved from {@link
 * Elements#getElements}.
 *
 * <p>One way to use this is to pass in the results of {@link Elements#getElements} as the {@code
 * elements} parameter.
 *
 * <p>This differs from {@link #getEntries()} in that it will return duplicates if they are
 * present in the {@code elements} passed in. This does not run the normal Guice de-duplication
 * that {@link #getEntries()} does.
 *
 * @throws IllegalArgumentException if the provided elements contain partial map entries. If the
 *     elements come from {@link Elements#getElements} on a module with a MapBinder, there will be
 *     a 1:1 relationship and no exception will be thrown.
 * @since 4.2
 */
 
/**
 * Returns true if the MapBinder permits duplicates. This is only supported on bindings returned
 * from an injector. This will throw {@link UnsupportedOperationException} if it is called on a
 * MapBinderBinding retrieved from {@link Elements#getElements}.
 */
 
/**
 * Returns true if this MapBinder contains the given Element in order to build the map or uses the
 * given Element in order to support building and injecting the map. This will work for
 * MapBinderBindings retrieved from an injector and {@link Elements#getElements}. Usually this is
 * only necessary if you are working with elements retrieved from modules (without an Injector),
 * otherwise {@link #getEntries} and {@link #permitsDuplicates} are better options.
 *
 * <p>If you need to introspect the details of the map, such as the keys, values or if it permits
 * duplicates, it is necessary to pass the elements through an Injector and use {@link
 * #getEntries()} and {@link #permitsDuplicates()}.
 */
 
","getMapKey 
getAlternateMapKeys 
getKeyTypeLiteral 
getValueTypeLiteral 
getEntries 
getEntries 
permitsDuplicates 
containsElement 
",,,,,14,847
MultibinderBinding.java,70,16,4.375,"
 * A binding for a Multibinder.
 *
 * <p>Although Multibinders may be injected through a variety of generic types ({@code Set<V>} and
 * {@code Collection<Provider<V>>}), a MultibinderBinding exists only on the Binding associated with
 * the {@code Set<V>} key. Injectable types can be discovered using {@link #getSetKey} (which will
 * return the {@code Set<V>} key), or{@link #getAlternateSetKeys} (which will return the other keys
 * that can inject this data). Other bindings can be validated to be derived from this
 * MultibinderBinding using {@link #containsElement(Element)}.
 *
 * @param <T> The fully qualified type of the set, including Set. For example: {@code
 *     MultibinderBinding<Set<Boolean>>}
 * @since 3.0
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Returns the key for the set.
 */
 
/**
 * Returns the keys of other bindings that represent this set. This will return an entry for
 * {@code Collection<com.google.inject.Provider<V>>} and {@code
 * Collection<javax.inject.Provider<V>>}.
 *
 * @since 5.0
 */
 
/**
 * Returns the TypeLiteral that describes the type of elements in the set.
 *
 * <p>The elements will always match the type Set's generic type. For example, if getSetKey
 * returns a key of <code>Set&lt;String></code>, then this will always return a <code>
 * TypeLiteral&lt;String></code>.
 */
 
/**
 * Returns all bindings that make up the set. This is only supported on bindings returned from an
 * injector. This will throw {@link UnsupportedOperationException} if it is called on an element
 * retrieved from {@link Elements#getElements}.
 *
 * <p>The elements will always match the type Set's generic type. For example, if getSetKey
 * returns a key of <code>Set&lt;String></code>, then this will always return a list of type
 * <code>List&lt;Binding&lt;String>></code>.
 */
 
/**
 * Returns true if the multibinder permits duplicates. This is only supported on bindings returned
 * from an injector. This will throw {@link UnsupportedOperationException} if it is called on a
 * MultibinderBinding retrieved from {@link Elements#getElements}.
 */
 
/**
 * Returns true if this Multibinder uses the given Element. This will be true for bindings that
 * derive the elements of the set and other bindings that Multibinder uses internally. This will
 * work for MultibinderBindings retrieved from an injector and {@link Elements#getElements}.
 * Usually this is only necessary if you are working with elements retrieved from modules (without
 * an Injector), otherwise {@link #getElements} and {@link #permitsDuplicates} are better options.
 *
 * <p>If you need to introspect the details of the set, such as the values or if it permits
 * duplicates, it is necessary to pass the elements through an Injector and use {@link
 * #getElements()} and {@link #permitsDuplicates()}.
 */
 
","getSetKey 
getAlternateSetKeys 
getElementTypeLiteral 
getElements 
permitsDuplicates 
containsElement 
",,,,,13,744
ProvidesIntoMap.java,42,11,3.8181818181818183,"
 * Annotates methods of a {@link Module} to add items to a {@link MapBinder}. The method's return
 * type, binding annotation and additional key annotation determines what Map this will contribute
 * to. For example,
 *
 * <pre>
 * {@literal @}ProvidesIntoMap
 * {@literal @}StringMapKey(""Foo"")
 * {@literal @}Named(""plugins"")
 * Plugin provideFooUrl(FooManager fm) { return fm.getPlugin(); }
 *
 * {@literal @}ProvidesIntoMap
 * {@literal @}StringMapKey(""Bar"")
 * {@literal @}Named(""plugins"")
 * Plugin provideBarUrl(BarManager bm) { return bm.getPlugin(); }
 * </pre>
 *
 * will add two items to the {@code @Named(""plugins"") Map<String, Plugin>} map. The key 'Foo' will
 * map to the provideFooUrl method, and the key 'Bar' will map to the provideBarUrl method. The
 * values are bound as providers and will be evaluated at injection time.
 *
 * <p>Because the key is specified as an annotation, only Strings, Classes, enums, primitive types
 * and annotation instances are supported as keys.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 4.0
 ",,,,,,,25,1004
MapKey.java,20,13,1.5384615384615385,"
 * Allows users define customized key type annotations for map bindings by annotating an annotation
 * of a {@code Map}'s key type. The custom key annotation can be applied to methods also annotated
 * with {@literal @}{@link ProvidesIntoMap}.
 *
 * <p>A {@link StringMapKey} and {@link ClassMapKey} are provided for convenience with maps whose
 * keys are strings or classes. For maps with enums or primitive types as keys, you must provide
 * your own MapKey annotation, such as this one for an enum:
 *
 * <pre>
 * {@literal @}MapKey(unwrapValue = true)
 * {@literal @}Retention(RUNTIME)
 * public {@literal @}interface MyCustomEnumKey {
 *   MyCustomEnum value();
 * }
 * </pre>
 *
 * You can also use the whole annotation as the key, if {@code unwrapValue=false}. When unwrapValue
 * is false, the annotation type will be the key type for the injected map and the annotation
 * instances will be the key values. If {@code unwrapValue=true}, the value() type will be the key
 * type for injected map and the value() instances will be the keys values.
 *
 * @since 4.0
 ",,,,,,,22,1029
OptionalBinder.java,110,582,0.18900343642611683,"
 * An API to bind optional values, optionally with a default value. OptionalBinder fulfills two
 * roles:
 *
 * <ol>
 *   <li>It allows a framework to define an injection point that may or may not be bound by users.
 *   <li>It allows a framework to supply a default value that can be changed by users.
 * </ol>
 *
 * <p>When an OptionalBinder is added, it will always supply the bindings: {@code Optional<T>} and
 * {@code Optional<Provider<T>>}. Both {@link java.util.Optional java.util.Optional} and {@link
 * com.google.common.base.Optional com.google.common.base.Optional} are bound for compatibility. If
 * {@link #setBinding} or {@link #setDefault} are called, it will also bind {@code T}.
 *
 * <p>{@code setDefault} is intended for use by frameworks that need a default value. User code can
 * call {@code setBinding} to override the default. <b>Warning: Even if setBinding is called, the
 * default binding will still exist in the object graph. If it is a singleton, it will be
 * instantiated in {@code Stage.PRODUCTION}.</b>
 *
 * <p>If setDefault or setBinding are linked to Providers, the Provider may return {@code null}. If
 * it does, {@code Optional<T>} will be bound to an absent Optional. Binding setBinding to a
 * Provider that returns null will not cause OptionalBinder to fall back to the setDefault binding.
 *
 * <p>If neither setDefault nor setBinding are called, it will try to link to a user-supplied
 * binding of the same type. If no binding exists, the optionals will be absent. Otherwise, if a
 * user-supplied binding of that type exists, or if setBinding or setDefault are called, the
 * optionals will return present if they are bound to a non-null value.
 *
 * <p>Values are resolved at injection time. If a value is bound to a provider, that provider's get
 * method will be called each time the optional is injected (unless the binding is also scoped, or
 * an optional of provider is injected).
 *
 * <p>Annotations are used to create different optionals of the same key/value type. Each distinct
 * annotation gets its own independent binding.
 *
 * <pre><code>
 * public class FrameworkModule extends AbstractModule {
 *   protected void configure() {
 *     OptionalBinder.newOptionalBinder(binder(), Renamer.class);
 *   }
 * }</code></pre>
 *
 * <p>With this module, an {@code Optional<Renamer>} can now be injected. With no other bindings,
 * the optional will be absent. Users can specify bindings in one of two ways:
 *
 * <p>Option 1:
 *
 * <pre><code>
 * public class UserRenamerModule extends AbstractModule {
 *   protected void configure() {
 *     bind(Renamer.class).to(ReplacingRenamer.class);
 *   }
 * }</code></pre>
 *
 * <p>or Option 2:
 *
 * <pre><code>
 * public class UserRenamerModule extends AbstractModule {
 *   protected void configure() {
 *     OptionalBinder.newOptionalBinder(binder(), Renamer.class)
 *         .setBinding().to(ReplacingRenamer.class);
 *   }
 * }</code></pre>
 *
 * With both options, the {@code Optional<Renamer>} will be present and supply the ReplacingRenamer.
 *
 * <p>Default values can be supplied using:
 *
 * <pre><code>
 * public class FrameworkModule extends AbstractModule {
 *   protected void configure() {
 *     OptionalBinder.newOptionalBinder(binder(), Key.get(String.class, LookupUrl.class))
 *         .setDefault().toInstance(DEFAULT_LOOKUP_URL);
 *   }
 * }</code></pre>
 *
 * With the above module, code can inject an {@code @LookupUrl String} and it will supply the
 * DEFAULT_LOOKUP_URL. A user can change this value by binding
 *
 * <pre><code>
 * public class UserLookupModule extends AbstractModule {
 *   protected void configure() {
 *     OptionalBinder.newOptionalBinder(binder(), Key.get(String.class, LookupUrl.class))
 *         .setBinding().toInstance(CUSTOM_LOOKUP_URL);
 *   }
 * }</code></pre>
 *
 * ... which will override the default value.
 *
 * <p>If one module uses setDefault the only way to override the default is to use setBinding. It is
 * an error for a user to specify the binding without using OptionalBinder if setDefault or
 * setBinding are called. For example,
 *
 * <pre><code>
 * public class FrameworkModule extends AbstractModule {
 *   protected void configure() {
 *     OptionalBinder.newOptionalBinder(binder(), Key.get(String.class, LookupUrl.class))
 *         .setDefault().toInstance(DEFAULT_LOOKUP_URL);
 *   }
 * }
 * public class UserLookupModule extends AbstractModule {
 *   protected void configure() {
 *     bind(Key.get(String.class, LookupUrl.class)).toInstance(CUSTOM_LOOKUP_URL);
 *   }
 * }</code></pre>
 *
 * ... would generate an error, because both the framework and the user are trying to bind
 * {@code @LookupUrl String}.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 4.0
 ","/**
 * Returns a binding builder used to set the default value that will be injected. The binding set
 * by this method will be ignored if {@link #setBinding} is called.
 *
 * <p>It is an error to call this method without also calling one of the {@code to} methods on the
 * returned binding builder.
 */
 
/**
 * Returns a binding builder used to set the actual value that will be injected. This overrides
 * any binding set by {@link #setDefault}.
 *
 * <p>It is an error to call this method without also calling one of the {@code to} methods on the
 * returned binding builder.
 */
 
","{
    return delegate.setDefault();
} 
{
    return delegate.setBinding();
} 
",,,,,110,4539
Modules.java,102,309,0.3300970873786408,"
 * Static utility methods for creating and working with instances of {@link Module}.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 | See the EDSL example at {@link Modules#override(Module[]) override()}. ","/**
 * Returns a builder that creates a module that overlays override modules over the given modules.
 * If a key is bound in both sets of modules, only the binding from the override modules is kept.
 * If a single {@link PrivateModule} is supplied or all elements are from a single {@link
 * PrivateBinder}, then this will overwrite the private bindings. Otherwise, private bindings will
 * not be overwritten unless they are exposed. This can be used to replace the bindings of a
 * production module with test bindings:
 *
 * <pre>
 * Module functionalTestModule
 *     = Modules.override(new ProductionModule()).with(new TestModule());
 * </pre>
 *
 * <p>Prefer to write smaller modules that can be reused and tested without overrides.
 *
 * @param modules the modules whose bindings are open to be overridden
 */
 
/**
 * @deprecated there's no reason to use {@code Modules.override()} without any arguments.
 */
 
/**
 * Returns a builder that creates a module that overlays override modules over the given modules.
 * If a key is bound in both sets of modules, only the binding from the override modules is kept.
 * If a single {@link PrivateModule} is supplied or all elements are from a single {@link
 * PrivateBinder}, then this will overwrite the private bindings. Otherwise, private bindings will
 * not be overwritten unless they are exposed. This can be used to replace the bindings of a
 * production module with test bindings:
 *
 * <pre>
 * Module functionalTestModule
 *     = Modules.override(getProductionModules()).with(getTestModules());
 * </pre>
 *
 * <p>Prefer to write smaller modules that can be reused and tested without overrides.
 *
 * @param modules the modules whose bindings are open to be overridden
 */
 
/**
 * Returns a new module that installs all of {@code modules}.
 *
 * <p>Although sometimes helpful, this method is rarely necessary. Most Guice APIs accept multiple
 * arguments or (like {@code install()}) can be called repeatedly. Where possible, external APIs
 * that require a single module should similarly be adapted to permit multiple modules.
 */
 
/**
 * @deprecated there's no need to ""combine"" one module; just install it directly.
 */
 
/**
 * @deprecated this method call is effectively a no-op, just remove it.
 */
 
/**
 * Returns a new module that installs all of {@code modules}.
 *
 * <p>Although sometimes helpful, this method is rarely necessary. Most Guice APIs accept multiple
 * arguments or (like {@code install()}) can be called repeatedly. Where possible, external APIs
 * that require a single module should similarly be adapted to permit multiple modules.
 */
 
/**
 * See the EDSL example at {@link Modules#override(Module[]) override()}.
 */
 
/**
 * @deprecated there's no reason to use {@code .with()} without any arguments.
 */
 
/**
 * See the EDSL example at {@link Modules#override(Module[]) override()}.
 */
 
/**
 * Returns a module that will configure the injector to require explicit bindings.
 */
 
/**
 * Returns a module that will configure the injector to require {@literal @}{@link Inject} on
 * constructors.
 *
 * @see Binder#requireAtInjectOnConstructors
 */
 
/**
 * Returns a module that will configure the injector to require an exactly matching binding
 * annotation.
 *
 * @see Binder#requireExactBindingAnnotations
 */
 
/**
 * Returns a module that will configure the injector to disable circular proxies.
 */
 
","{
    return override(Arrays.asList(modules));
} 
{
    return override(Arrays.asList());
} 
{
    return new RealOverriddenModuleBuilder(modules);
} 
{
    return combine(ImmutableSet.copyOf(modules));
} 
{
    return module;
} 
{
    return EMPTY_MODULE;
} 
{
    return new CombinedModule(modules);
} 
with 
with 
with 
{
    return new RequireExplicitBindingsModule();
} 
{
    return new RequireAtInjectOnConstructorsModule();
} 
{
    return new RequireExactBindingAnnotationsModule();
} 
{
    return new DisableCircularProxiesModule();
} 
",,,,,5,217
Providers.java,51,155,0.32903225806451614,"
 * Static utility methods for creating and working with instances of {@link Provider}.
 *
 * @author Kevin Bourrillion (kevinb9n@gmail.com)
 * @since 2.0
 ","/**
 * Returns a provider which always provides {@code instance}. This should not be necessary to use
 * in your application, but is helpful for several types of unit tests.
 *
 * @param instance the instance that should always be provided. This is also permitted to be null,
 *     to enable aggressive testing, although in real life a Guice-supplied Provider will never
 *     return null.
 */
 
/**
 * Returns a Guice-friendly {@code com.google.inject.Provider} for the given JSR-330 {@code
 * javax.inject.Provider}. The converse method is unnecessary, since Guice providers directly
 * implement the JSR-330 interface.
 *
 * @since 3.0
 */
 
","{
    return new ConstantProvider<T>(instance);
} 
{
    if (provider instanceof Provider) {
        return (Provider<T>) provider;
    }
    final javax.inject.Provider<T> delegate = checkNotNull(provider, ""provider"");
    // Ensure that we inject all injection points from the delegate provider.
    Set<InjectionPoint> injectionPoints = InjectionPoint.forInstanceMethodsAndFields(provider.getClass());
    if (injectionPoints.isEmpty()) {
        return new GuicifiedProvider<T>(delegate);
    } else {
        Set<Dependency<?>> mutableDeps = Sets.newHashSet();
        for (InjectionPoint ip : injectionPoints) {
            mutableDeps.addAll(ip.getDependencies());
        }
        final Set<Dependency<?>> dependencies = ImmutableSet.copyOf(mutableDeps);
        return new GuicifiedProviderWithDependencies<T>(dependencies, delegate);
    }
} 
",,,,,4,147
Types.java,80,393,0.2035623409669211,"
 * Static methods for working with types.
 *
 * @author crazybob@google.com (Bob Lee)
 * @since 2.0
 ","/**
 * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType}. The
 * returned type does not have an owner type.
 *
 * @return a {@link java.io.Serializable serializable} parameterized type.
 */
 
/**
 * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType} and
 * enclosed by {@code ownerType}.
 *
 * @return a {@link java.io.Serializable serializable} parameterized type.
 */
 
/**
 * Returns an array type whose elements are all instances of {@code componentType}.
 *
 * @return a {@link java.io.Serializable serializable} generic array type.
 */
 
/**
 * Returns a type that represents an unknown type that extends {@code bound}. For example, if
 * {@code bound} is {@code CharSequence.class}, this returns {@code ? extends CharSequence}. If
 * {@code bound} is {@code Object.class}, this returns {@code ?}, which is shorthand for {@code ?
 * extends Object}.
 */
 
/**
 * Returns a type that represents an unknown supertype of {@code bound}. For example, if {@code
 * bound} is {@code String.class}, this returns {@code ? super String}.
 */
 
/**
 * Returns a type modelling a {@link List} whose elements are of type {@code elementType}.
 *
 * @return a {@link java.io.Serializable serializable} parameterized type.
 */
 
/**
 * Returns a type modelling a {@link Collection} whose elements are of type {@code elementType}.
 *
 * @return a {@link java.io.Serializable serializable} parameterized type.
 */
 
/**
 * Returns a type modelling a {@link Set} whose elements are of type {@code elementType}.
 *
 * @return a {@link java.io.Serializable serializable} parameterized type.
 */
 
/**
 * Returns a type modelling a {@link Map} whose keys are of type {@code keyType} and whose values
 * are of type {@code valueType}.
 *
 * @return a {@link java.io.Serializable serializable} parameterized type.
 */
 
/**
 * Returns a type modelling a {@link Provider} that provides elements of type {@code elementType}.
 *
 * @return a {@link java.io.Serializable serializable} parameterized type.
 */
 
/**
 * Returns a type modelling a {@link javax.inject.Provider} that provides elements of type {@code
 * elementType}.
 *
 * @return a {@link java.io.Serializable serializable} parameterized type.
 */
 
","{
    return newParameterizedTypeWithOwner(null, rawType, typeArguments);
} 
{
    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);
} 
{
    return new GenericArrayTypeImpl(componentType);
} 
{
    return new WildcardTypeImpl(new Type[] { bound }, MoreTypes.EMPTY_TYPE_ARRAY);
} 
{
    return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { bound });
} 
{
    return newParameterizedType(List.class, elementType);
} 
{
    return newParameterizedType(Collection.class, elementType);
} 
{
    return newParameterizedType(Set.class, elementType);
} 
{
    return newParameterizedType(Map.class, keyType, valueType);
} 
{
    return newParameterizedType(Provider.class, providedType);
} 
{
    return Types.newParameterizedType(javax.inject.Provider.class, type);
} 
",,,,,4,93
AnnotatedConstantBindingBuilder.java,22,6,3.6666666666666665,"
 * See the EDSL examples at {@link com.google.inject.Binder}.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
","annotatedWith 
annotatedWith 
",,,,,3,101
AnnotatedBindingBuilder.java,22,6,3.6666666666666665,"
 * See the EDSL examples at {@link com.google.inject.Binder}.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
","annotatedWith 
annotatedWith 
",,,,,3,101
AnnotatedElementBuilder.java,23,6,3.8333333333333335,"
 * See the EDSL examples at {@link com.google.inject.Binder}.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
","annotatedWith 
annotatedWith 
",,,,,4,121
LinkedBindingBuilder.java,52,20,2.6,"
 * See the EDSL examples at {@link com.google.inject.Binder}.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 *
 * @see com.google.inject.Injector#injectMembers
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 *
 * @see com.google.inject.Injector#injectMembers
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 *
 * @see com.google.inject.Injector#injectMembers
 * @since 4.0
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 *
 * @since 3.0
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 *
 * @since 3.0
 */
 
","to 
to 
to 
toInstance 
toProvider 
toProvider 
toProvider 
toProvider 
toProvider 
toConstructor 
toConstructor 
",,,,,3,101
ScopedBindingBuilder.java,27,8,3.375,"
 * See the EDSL examples at {@link com.google.inject.Binder}.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
/**
 * See the EDSL examples at {@link com.google.inject.Binder}.
 */
 
/**
 * Instructs the {@link com.google.inject.Injector} to eagerly initialize this singleton-scoped
 * binding upon creation. Useful for application initialization logic. See the EDSL examples at
 * {@link com.google.inject.Binder}.
 */
 
","in 
in 
asEagerSingleton 
",,,,,3,101
ConstantBindingBuilder.java,31,14,2.2142857142857144," Binds to a constant value. ","/**
 * Binds constant to the given value.
 */
 
/**
 * Binds constant to the given value.
 */
 
/**
 * Binds constant to the given value.
 */
 
/**
 * Binds constant to the given value.
 */
 
/**
 * Binds constant to the given value.
 */
 
/**
 * Binds constant to the given value.
 */
 
/**
 * Binds constant to the given value.
 */
 
/**
 * Binds constant to the given value.
 */
 
/**
 * Binds constant to the given value.
 *
 * @since 3.0
 */
 
/**
 * Binds constant to the given value.
 */
 
/**
 * Binds constant to the given value.
 */
 
","to 
to 
to 
to 
to 
to 
to 
to 
to 
to 
to 
",,,,,1,28
AbstractModule.java,104,102,1.0196078431372548,"
 * A support class for {@link Module}s which reduces repetition and results in a more readable
 * configuration. Simply extend this class, implement {@link #configure()}, and call the inherited
 * methods which mirror those found in {@link Binder}. For example:
 *
 * <pre>
 * public class MyModule extends AbstractModule {
 *   protected void configure() {
 *     bind(Service.class).to(ServiceImpl.class).in(Singleton.class);
 *     bind(CreditCardPaymentService.class);
 *     bind(PaymentService.class).to(CreditCardPaymentService.class);
 *     bindConstant().annotatedWith(Names.named(""port"")).to(8080);
 *   }
 * }
 * </pre>
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Configures a {@link Binder} via the exposed methods.
 */
 
/**
 * Gets direct access to the underlying {@code Binder}.
 */
 
/**
 * @see Binder#bindScope(Class, Scope)
 */
 
/**
 * @see Binder#bind(Key)
 */
 
/**
 * @see Binder#bind(TypeLiteral)
 */
 
/**
 * @see Binder#bind(Class)
 */
 
/**
 * @see Binder#bindConstant()
 */
 
/**
 * @see Binder#install(Module)
 */
 
/**
 * @see Binder#addError(String, Object[])
 */
 
/**
 * @see Binder#addError(Throwable)
 */
 
/**
 * @see Binder#addError(Message)
 * @since 2.0
 */
 
/**
 * @see Binder#requestInjection(Object)
 * @since 2.0
 */
 
/**
 * @see Binder#requestStaticInjection(Class[])
 */
 
/**
 * @see Binder#bindInterceptor(com.google.inject.matcher.Matcher,
 *     com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[])
 */
 
/**
 * Adds a dependency from this module to {@code key}. When the injector is created, Guice will
 * report an error if {@code key} cannot be injected. Note that this requirement may be satisfied
 * by implicit binding, such as a public no-arguments constructor.
 *
 * @since 2.0
 */
 
/**
 * Adds a dependency from this module to {@code type}. When the injector is created, Guice will
 * report an error if {@code type} cannot be injected. Note that this requirement may be satisfied
 * by implicit binding, such as a public no-arguments constructor.
 *
 * @since 2.0
 */
 
/**
 * @see Binder#getProvider(Key)
 * @since 2.0
 */
 
/**
 * @see Binder#getProvider(Class)
 * @since 2.0
 */
 
/**
 * @see Binder#convertToTypes
 * @since 2.0
 */
 
/**
 * @see Binder#currentStage()
 * @since 2.0
 */
 
/**
 * @see Binder#getMembersInjector(Class)
 * @since 2.0
 */
 
/**
 * @see Binder#getMembersInjector(TypeLiteral)
 * @since 2.0
 */
 
/**
 * @see Binder#bindListener(com.google.inject.matcher.Matcher, com.google.inject.spi.TypeListener)
 * @since 2.0
 */
 
/**
 * @see Binder#bindListener(Matcher, ProvisionListener...)
 * @since 4.0
 */
 
","{
} 
{
    checkState(binder != null, ""The binder can only be used inside configure()"");
    return binder;
} 
{
    binder().bindScope(scopeAnnotation, scope);
} 
{
    return binder().bind(key);
} 
{
    return binder().bind(typeLiteral);
} 
{
    return binder().bind(clazz);
} 
{
    return binder().bindConstant();
} 
{
    binder().install(module);
} 
{
    binder().addError(message, arguments);
} 
{
    binder().addError(t);
} 
{
    binder().addError(message);
} 
{
    binder().requestInjection(instance);
} 
{
    binder().requestStaticInjection(types);
} 
{
    binder().bindInterceptor(classMatcher, methodMatcher, interceptors);
} 
{
    binder().getProvider(key);
} 
{
    binder().getProvider(type);
} 
{
    return binder().getProvider(key);
} 
{
    return binder().getProvider(type);
} 
{
    binder().convertToTypes(typeMatcher, converter);
} 
{
    return binder().currentStage();
} 
{
    return binder().getMembersInjector(type);
} 
{
    return binder().getMembersInjector(type);
} 
{
    binder().bindListener(typeMatcher, listener);
} 
{
    binder().bindListener(bindingMatcher, listener);
} 
",,,,,16,645
PrivateBinder.java,33,11,3.0,"
 * Returns a binder whose configuration information is hidden from its environment by default. See
 * {@link com.google.inject.PrivateModule PrivateModule} for details.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Makes the binding for {@code key} available to the enclosing environment
 */
 
/**
 * Makes a binding for {@code type} available to the enclosing environment. Use {@link
 * com.google.inject.binder.AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to
 * expose {@code type} with a binding annotation.
 */
 
/**
 * Makes a binding for {@code type} available to the enclosing environment. Use {@link
 * AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 * binding annotation.
 */
 
","expose 
expose 
expose 
",,,,,5,226
Provider.java,141,247,0.5708502024291497,"
 * An object capable of providing instances of type {@code T}. Providers are used in numerous ways
 * by Guice:
 *
 * <ul>
 * <li>When the default means for obtaining instances (an injectable or parameterless constructor)
 *     is insufficient for a particular binding, the module can specify a custom {@code Provider}
 *     instead, to control exactly how Guice creates or obtains instances for the binding.
 * <li>An implementation class may always choose to have a {@code Provider<T>} instance injected,
 *     rather than having a {@code T} injected directly. This may give you access to multiple
 *     instances, instances you wish to safely mutate and discard, instances which are out of scope
 *     (e.g. using a {@code @RequestScoped} object from within a {@code @SessionScoped} object), or
 *     instances that will be initialized lazily.
 * <li>A custom {@link Scope} is implemented as a decorator of {@code Provider<T>}, which decides
 *     when to delegate to the backing provider and when to provide the instance some other way.
 * <li>The {@link Injector} offers access to the {@code Provider<T>} it uses to fulfill requests for
 *     a given key, via the {@link Injector#getProvider} methods.
 * </ul>
 *
 * @param <T> the type of object this provides
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Provides an instance of {@code T}.
 *
 * @throws OutOfScopeException when an attempt is made to access a scoped object while the scope
 *     in question is not currently active
 * @throws ProvisionException if an instance cannot be provided. Such exceptions include messages
 *     and throwables to describe why provision failed.
 */
 
","get 
",,,,,20,1276
Module.java,175,290,0.603448275862069,"
 * A module contributes configuration information, typically interface bindings, which will be used
 * to create an {@link Injector}. A Guice-based application is ultimately composed of little more
 * than a set of {@code Module}s and some bootstrapping code.
 *
 * <p>Your Module classes can use a more streamlined syntax by extending {@link AbstractModule}
 * rather than implementing this interface directly.
 *
 * <p>In addition to the bindings configured via {@link #configure}, bindings will be created for
 * all methods annotated with {@literal @}{@link Provides}. Use scope and binding annotations on
 * these methods to configure the bindings.
 ","/**
 * Contributes bindings and other configurations for this module to {@code binder}.
 *
 * <p><strong>Do not invoke this method directly</strong> to install submodules. Instead use
 * {@link Binder#install(Module)}, which ensures that {@link Provides provider methods} are
 * discovered.
 */
 
","configure 
",,,,,10,635
Guice.java,55,319,0.1724137931034483,"
 * The entry point to the Guice framework. Creates {@link Injector}s from {@link Module}s.
 *
 * <p>Guice supports a model of development that draws clear boundaries between APIs,
 * Implementations of these APIs, Modules which configure these implementations, and finally
 * Applications which consist of a collection of Modules. It is the Application, which typically
 * defines your {@code main()} method, that bootstraps the Guice Injector using the {@code Guice}
 * class, as in this example:
 *
 * <pre>
 *     public class FooApplication {
 *       public static void main(String[] args) {
 *         Injector injector = Guice.createInjector(
 *             new ModuleA(),
 *             new ModuleB(),
 *             . . .
 *             new FooApplicationFlagsModule(args)
 *         );
 *
 *         // Now just bootstrap the application and you're done
 *         FooStarter starter = injector.getInstance(FooStarter.class);
 *         starter.runApplication();
 *       }
 *     }
 * </pre>
 ","/**
 * Creates an injector for the given set of modules. This is equivalent to calling {@link
 * #createInjector(Stage, Module...)} with Stage.DEVELOPMENT.
 *
 * @throws CreationException if one or more errors occur during injector construction
 */
 
/**
 * Creates an injector for the given set of modules. This is equivalent to calling {@link
 * #createInjector(Stage, Iterable)} with Stage.DEVELOPMENT.
 *
 * @throws CreationException if one or more errors occur during injector creation
 */
 
/**
 * Creates an injector for the given set of modules, in a given development stage.
 *
 * @throws CreationException if one or more errors occur during injector creation.
 */
 
/**
 * Creates an injector for the given set of modules, in a given development stage.
 *
 * @throws CreationException if one or more errors occur during injector construction
 */
 
","{
    return createInjector(Arrays.asList(modules));
} 
{
    return createInjector(Stage.DEVELOPMENT, modules);
} 
{
    return createInjector(stage, Arrays.asList(modules));
} 
{
    return new InternalInjectorCreator().stage(stage).addModules(modules).build();
} 
",,,,,24,956
Binder.java,180,978,0.18404907975460122,"
 * Collects configuration information (primarily <i>bindings</i>) which will be used to create an
 * {@link Injector}. Guice provides this object to your application's {@link Module} implementors so
 * they may each contribute their own bindings and other registrations.
 *
 * <h3>The Guice Binding EDSL</h3>
 *
 * Guice uses an <i>embedded domain-specific language</i>, or EDSL, to help you create bindings
 * simply and readably. This approach is great for overall usability, but it does come with a small
 * cost: <b>it is difficult to learn how to use the Binding EDSL by reading method-level
 * javadocs</b>. Instead, you should consult the series of examples below. To save space, these
 * examples omit the opening {@code binder}, just as you will if your module extends {@link
 * AbstractModule}.
 *
 * <pre>
 *     bind(ServiceImpl.class);</pre>
 *
 * This statement does essentially nothing; it ""binds the {@code ServiceImpl} class to itself"" and
 * does not change Guice's default behavior. You may still want to use this if you prefer your
 * {@link Module} class to serve as an explicit <i>manifest</i> for the services it provides. Also,
 * in rare cases, Guice may be unable to validate a binding at injector creation time unless it is
 * given explicitly.
 *
 * <pre>
 *     bind(Service.class).to(ServiceImpl.class);</pre>
 *
 * Specifies that a request for a {@code Service} instance with no binding annotations should be
 * treated as if it were a request for a {@code ServiceImpl} instance. This <i>overrides</i> the
 * function of any {@link ImplementedBy @ImplementedBy} or {@link ProvidedBy @ProvidedBy}
 * annotations found on {@code Service}, since Guice will have already ""moved on"" to {@code
 * ServiceImpl} before it reaches the point when it starts looking for these annotations.
 *
 * <pre>
 *     bind(Service.class).toProvider(ServiceProvider.class);</pre>
 *
 * In this example, {@code ServiceProvider} must extend or implement {@code Provider<Service>}. This
 * binding specifies that Guice should resolve an unannotated injection request for {@code Service}
 * by first resolving an instance of {@code ServiceProvider} in the regular way, then calling {@link
 * Provider#get get()} on the resulting Provider instance to obtain the {@code Service} instance.
 *
 * <p>The {@link Provider} you use here does not have to be a ""factory""; that is, a provider which
 * always <i>creates</i> each instance it provides. However, this is generally a good practice to
 * follow. You can then use Guice's concept of {@link Scope scopes} to guide when creation should
 * happen -- ""letting Guice work for you"".
 *
 * <pre>
 *     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);</pre>
 *
 * Like the previous example, but only applies to injection requests that use the binding annotation
 * {@code @Red}. If your module also includes bindings for particular <i>values</i> of the
 * {@code @Red} annotation (see below), then this binding will serve as a ""catch-all"" for any values
 * of {@code @Red} that have no exact match in the bindings.
 *
 * <pre>
 *     bind(ServiceImpl.class).in(Singleton.class);
 *     // or, alternatively
 *     bind(ServiceImpl.class).in(Scopes.SINGLETON);</pre>
 *
 * Either of these statements places the {@code ServiceImpl} class into singleton scope. Guice will
 * create only one instance of {@code ServiceImpl} and will reuse it for all injection requests of
 * this type. Note that it is still possible to bind another instance of {@code ServiceImpl} if the
 * second binding is qualified by an annotation as in the previous example. Guice is not overly
 * concerned with <i>preventing</i> you from creating multiple instances of your ""singletons"", only
 * with <i>enabling</i> your application to share only one instance if that's all you tell Guice you
 * need.
 *
 * <p><b>Note:</b> a scope specified in this way <i>overrides</i> any scope that was specified with
 * an annotation on the {@code ServiceImpl} class.
 *
 * <p>Besides {@link Singleton}/{@link Scopes#SINGLETON}, there are servlet-specific scopes
 * available in {@code com.google.inject.servlet.ServletScopes}, and your Modules can contribute
 * their own custom scopes for use here as well.
 *
 * <pre>
 *     bind(new TypeLiteral&lt;PaymentService&lt;CreditCard>>() {})
 *         .to(CreditCardPaymentService.class);</pre>
 *
 * This admittedly odd construct is the way to bind a parameterized type. It tells Guice how to
 * honor an injection request for an element of type {@code PaymentService<CreditCard>}. The class
 * {@code CreditCardPaymentService} must implement the {@code PaymentService<CreditCard>} interface.
 * Guice cannot currently bind or inject a generic type, such as {@code Set<E>}; all type parameters
 * must be fully specified.
 *
 * <pre>
 *     bind(Service.class).toInstance(new ServiceImpl());
 *     // or, alternatively
 *     bind(Service.class).toInstance(SomeLegacyRegistry.getService());</pre>
 *
 * In this example, your module itself, <i>not Guice</i>, takes responsibility for obtaining a
 * {@code ServiceImpl} instance, then asks Guice to always use this single instance to fulfill all
 * {@code Service} injection requests. When the {@link Injector} is created, it will automatically
 * perform field and method injection for this instance, but any injectable constructor on {@code
 * ServiceImpl} is simply ignored. Note that using this approach results in ""eager loading"" behavior
 * that you can't control.
 *
 * <pre>
 *     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre>
 *
 * Sets up a constant binding. Constant injections must always be annotated. When a constant
 * binding's value is a string, it is eligible for conversion to all primitive types, to {@link
 * Enum#valueOf(Class, String) all enums}, and to {@link Class#forName class literals}. Conversions
 * for other types can be configured using {@link #convertToTypes(Matcher, TypeConverter)
 * convertToTypes()}.
 *
 * <pre>
 *   {@literal @}Color(""red"") Color red; // A member variable (field)
 *    . . .
 *     red = MyModule.class.getDeclaredField(""red"").getAnnotation(Color.class);
 *     bind(Service.class).annotatedWith(red).to(RedService.class);</pre>
 *
 * If your binding annotation has parameters you can apply different bindings to different specific
 * values of your annotation. Getting your hands on the right instance of the annotation is a bit of
 * a pain -- one approach, shown above, is to apply a prototype annotation to a field in your module
 * class, so that you can read this annotation instance and give it to Guice.
 *
 * <pre>
 *     bind(Service.class)
 *         .annotatedWith(Names.named(""blue""))
 *         .to(BlueService.class);</pre>
 *
 * Differentiating by names is a common enough use case that we provided a standard annotation,
 * {@link com.google.inject.name.Named @Named}. Because of Guice's library support, binding by name
 * is quite easier than in the arbitrary binding annotation case we just saw. However, remember that
 * these names will live in a single flat namespace with all the other names used in your
 * application.
 *
 * <pre>
 *     Constructor<T> loneCtor = getLoneCtorFromServiceImplViaReflection();
 *     bind(ServiceImpl.class)
 *         .toConstructor(loneCtor);</pre>
 *
 * In this example, we directly tell Guice which constructor to use in a concrete class
 * implementation. It means that we do not need to place {@literal @}Inject on any of the
 * constructors and that Guice treats the provided constructor as though it were annotated so. It is
 * useful for cases where you cannot modify existing classes and is a bit simpler than using a
 * {@link Provider}.
 *
 * <p>The above list of examples is far from exhaustive. If you can think of how the concepts of one
 * example might coexist with the concepts from another, you can most likely weave the two together.
 * If the two concepts make no sense with each other, you most likely won't be able to do it. In a
 * few cases Guice will let something bogus slip by, and will then inform you of the problems at
 * runtime, as soon as you try to create your Injector.
 *
 * <p>The other methods of Binder such as {@link #bindScope}, {@link #bindInterceptor}, {@link
 * #install}, {@link #requestStaticInjection}, {@link #addError} and {@link #currentStage} are not
 * part of the Binding EDSL; you can learn how to use these in the usual way, from the method
 * documentation.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 * @author kevinb@google.com (Kevin Bourrillion)
 ","/**
 * Binds method interceptor[s] to methods matched by class and method matchers. A method is
 * eligible for interception if:
 *
 * <ul>
 * <li>Guice created the instance the method is on
 * <li>Neither the enclosing type nor the method is final
 * <li>And the method is package-private, protected, or public
 * </ul>
 *
 * @param classMatcher matches classes the interceptor should apply to. For example: {@code
 *     only(Runnable.class)}.
 * @param methodMatcher matches methods the interceptor should apply to. For example: {@code
 *     annotatedWith(Transactional.class)}.
 * @param interceptors to bind. The interceptors are called in the order they are given.
 */
 
/**
 * Binds a scope to an annotation.
 */
 
/**
 * See the EDSL examples at {@link Binder}.
 */
 
/**
 * See the EDSL examples at {@link Binder}.
 */
 
/**
 * See the EDSL examples at {@link Binder}.
 */
 
/**
 * See the EDSL examples at {@link Binder}.
 */
 
/**
 * Upon successful creation, the {@link Injector} will inject instance fields and methods of the
 * given object.
 *
 * @param type of instance
 * @param instance for which members will be injected
 * @since 2.0
 */
 
/**
 * Upon successful creation, the {@link Injector} will inject instance fields and methods of the
 * given object.
 *
 * @param instance for which members will be injected
 * @since 2.0
 */
 
/**
 * Upon successful creation, the {@link Injector} will inject static fields and methods in the
 * given classes.
 *
 * @param types for which static members will be injected
 */
 
/**
 * Uses the given module to configure more bindings.
 */
 
/**
 * Gets the current stage.
 */
 
/**
 * Records an error message which will be presented to the user at a later time. Unlike throwing
 * an exception, this enable us to continue configuring the Injector and discover more errors.
 * Uses {@link String#format(String, Object[])} to insert the arguments into the message.
 */
 
/**
 * Records an exception, the full details of which will be logged, and the message of which will
 * be presented to the user at a later time. If your Module calls something that you worry may
 * fail, you should catch the exception and pass it into this.
 */
 
/**
 * Records an error message to be presented to the user at a later time.
 *
 * @since 2.0
 */
 
/**
 * Returns the provider used to obtain instances for the given injection key. The returned
 * provider will not be valid until the {@link Injector} has been created. The provider will throw
 * an {@code IllegalStateException} if you try to use it beforehand.
 *
 * @since 2.0
 */
 
/**
 * Returns the provider used to obtain instances for the given injection key. The returned
 * provider will be attached to the injection point and will follow the nullability specified in
 * the dependency. Additionally, the returned provider will not be valid until the {@link
 * Injector} has been created. The provider will throw an {@code IllegalStateException} if you try
 * to use it beforehand.
 *
 * @since 4.0
 */
 
/**
 * Returns the provider used to obtain instances for the given injection type. The returned
 * provider will not be valid until the {@link Injector} has been created. The provider will throw
 * an {@code IllegalStateException} if you try to use it beforehand.
 *
 * @since 2.0
 */
 
/**
 * Returns the members injector used to inject dependencies into methods and fields on instances
 * of the given type {@code T}. The returned members injector will not be valid until the main
 * {@link Injector} has been created. The members injector will throw an {@code
 * IllegalStateException} if you try to use it beforehand.
 *
 * @param typeLiteral type to get members injector for
 * @since 2.0
 */
 
/**
 * Returns the members injector used to inject dependencies into methods and fields on instances
 * of the given type {@code T}. The returned members injector will not be valid until the main
 * {@link Injector} has been created. The members injector will throw an {@code
 * IllegalStateException} if you try to use it beforehand.
 *
 * @param type type to get members injector for
 * @since 2.0
 */
 
/**
 * Binds a type converter. The injector will use the given converter to convert string constants
 * to matching types as needed.
 *
 * @param typeMatcher matches types the converter can handle
 * @param converter converts values
 * @since 2.0
 */
 
/**
 * Registers a listener for injectable types. Guice will notify the listener when it encounters
 * injectable types matched by the given type matcher.
 *
 * @param typeMatcher that matches injectable types the listener should be notified of
 * @param listener for injectable types matched by typeMatcher
 * @since 2.0
 */
 
/**
 * Registers listeners for provisioned objects. Guice will notify the listeners just before and
 * after the object is provisioned. Provisioned objects that are also injectable (everything
 * except objects provided through Providers) can also be notified through TypeListeners
 * registered in {@link #bindListener}.
 *
 * @param bindingMatcher that matches bindings of provisioned objects the listener should be
 *     notified of
 * @param listeners for provisioned objects matched by bindingMatcher
 * @since 4.0
 */
 
/**
 * Returns a binder that uses {@code source} as the reference location for configuration errors.
 * This is typically a {@link StackTraceElement} for {@code .java} source but it could any binding
 * source, such as the path to a {@code .properties} file.
 *
 * @param source any object representing the source location and has a concise {@link
 *     Object#toString() toString()} value
 * @return a binder that shares its configuration with this binder
 * @since 2.0
 */
 
/**
 * Returns a binder that skips {@code classesToSkip} when identify the calling code. The caller's
 * {@link StackTraceElement} is used to locate the source of configuration errors.
 *
 * @param classesToSkip library classes that create bindings on behalf of their clients.
 * @return a binder that shares its configuration with this binder.
 * @since 2.0
 */
 
/**
 * Creates a new private child environment for bindings and other configuration. The returned
 * binder can be used to add and configuration information in this environment. See {@link
 * PrivateModule} for details.
 *
 * @return a binder that inherits configuration from this binder. Only exposed configuration on
 *     the returned binder will be visible to this binder.
 * @since 2.0
 */
 
/**
 * Instructs the Injector that bindings must be listed in a Module in order to be injected.
 * Classes that are not explicitly bound in a module cannot be injected. Bindings created through
 * a linked binding (<code>bind(Foo.class).to(FooImpl.class)</code>) are allowed, but the implicit
 * binding (<code>FooImpl</code>) cannot be directly injected unless it is also explicitly bound (
 * <code>bind(FooImpl.class)</code>).
 *
 * <p>Tools can still retrieve bindings for implicit bindings (bindings created through a linked
 * binding) if explicit bindings are required, however {@link Binding#getProvider} will fail.
 *
 * <p>By default, explicit bindings are not required.
 *
 * <p>If a parent injector requires explicit bindings, then all child injectors (and private
 * modules within that injector) also require explicit bindings. If a parent does not require
 * explicit bindings, a child injector or private module may optionally declare itself as
 * requiring explicit bindings. If it does, the behavior is limited only to that child or any
 * grandchildren. No siblings of the child will require explicit bindings.
 *
 * <p>In the absence of an explicit binding for the target, linked bindings in child injectors
 * create a binding for the target in the parent. Since this behavior can be surprising, it causes
 * an error instead if explicit bindings are required. To avoid this error, add an explicit
 * binding for the target, either in the child or the parent.
 *
 * @since 3.0
 */
 
/**
 * Prevents Guice from injecting dependencies that form a cycle, unless broken by a {@link
 * Provider}. By default, circular dependencies are not disabled.
 *
 * <p>If a parent injector disables circular dependencies, then all child injectors (and private
 * modules within that injector) also disable circular dependencies. If a parent does not disable
 * circular dependencies, a child injector or private module may optionally declare itself as
 * disabling circular dependencies. If it does, the behavior is limited only to that child or any
 * grandchildren. No siblings of the child will disable circular dependencies.
 *
 * @since 3.0
 */
 
/**
 * Requires that a {@literal @}{@link Inject} annotation exists on a constructor in order for
 * Guice to consider it an eligible injectable class. By default, Guice will inject classes that
 * have a no-args constructor if no {@literal @}{@link Inject} annotation exists on any
 * constructor.
 *
 * <p>If the class is bound using {@link LinkedBindingBuilder#toConstructor}, Guice will still
 * inject that constructor regardless of annotations.
 *
 * @since 4.0
 */
 
/**
 * Requires that Guice finds an exactly matching binding annotation. This disables the error-prone
 * feature in Guice where it can substitute a binding for <code>{@literal @}Named Foo</code> when
 * attempting to inject <code>{@literal @}Named(""foo"") Foo</code>.
 *
 * @since 4.0
 */
 
/**
 * Adds a scanner that will look in all installed modules for annotations the scanner can parse,
 * and binds them like {@literal @}Provides methods. Scanners apply to all modules installed in
 * the injector. Scanners installed in child injectors or private modules do not impact modules in
 * siblings or parents, however scanners installed in parents do apply to all child injectors and
 * private modules.
 *
 * @since 4.0
 */
 
","bindInterceptor 
bindScope 
bind 
bind 
bind 
bindConstant 
requestInjection 
requestInjection 
requestStaticInjection 
install 
currentStage 
addError 
addError 
addError 
getProvider 
getProvider 
getProvider 
getMembersInjector 
getMembersInjector 
convertToTypes 
bindListener 
bindListener 
withSource 
skipSources 
newPrivateBinder 
requireExplicitBindings 
disableCircularProxies 
requireAtInjectOnConstructors 
requireExactBindingAnnotations 
scanModulesForAnnotatedMethods 
",,,,,150,8319
Singleton.java,21,9,2.3333333333333335,"
 * Apply this to implementation classes when you want only one instance (per {@link Injector}) to be
 * reused for all injections for that binding.
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,4,185
ImplementedBy.java,21,10,2.1,"
 * A pointer to the default implementation of a type.
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,3,93
BindingProcessor.java,25,212,0.1179245283018868,"
 * Handles {@link Binder#bind} and {@link Binder#bindConstant} elements.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Handle ProviderMethods specially.
 */
 
","{
    InternalProviderInstanceBindingImpl<T> binding = new InternalProviderInstanceBindingImpl<T>(injector, key, source, provider, Scoping.scope(key, injector, provider, source, scoping), scoping);
    switch(binding.getInitializationTiming()) {
        case DELAYED:
            scheduleDelayedInitialization(binding);
            break;
        case EAGER:
            scheduleInitialization(binding);
            break;
        default:
            throw new AssertionError();
    }
    putBinding(binding);
    return true;
} 
",,,,,4,159
LinkedBindingImpl.java,15,77,0.19480519480519481,,,,,,,,1,0
MembersInjectorStore.java,37,95,0.3894736842105263,"
 * Members injectors by type.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Returns true if any type listeners are installed. Other code may take shortcuts when there
 * aren't any type listeners.
 */
 
/**
 * Returns a new complete members injector with injection listeners registered.
 */
 
/**
 * Purges a type literal from the cache. Use this only if the type is not actually valid for
 * binding and needs to be purged. (See issue 319 and
 * ImplicitBindingTest#testCircularJitBindingsLeaveNoResidue and
 * #testInstancesRequestingProvidersForThemselvesWithChildInjectors for examples of when this is
 * necessary.)
 *
 * <p>Returns true if the type was stored in the cache, false otherwise.
 */
 
/**
 * Creates a new members injector and attaches both injection listeners and method aspects.
 */
 
/**
 * Returns the injectors for the specified injection points.
 */
 
","{
    return !typeListenerBindings.isEmpty();
} 
{
    return (MembersInjectorImpl<T>) cache.get(key, errors);
} 
{
    return cache.remove(type);
} 
{
    int numErrorsBefore = errors.size();
    Set<InjectionPoint> injectionPoints;
    try {
        injectionPoints = InjectionPoint.forInstanceMethodsAndFields(type);
    } catch (ConfigurationException e) {
        errors.merge(e.getErrorMessages());
        injectionPoints = e.getPartialValue();
    }
    ImmutableList<SingleMemberInjector> injectors = getInjectors(injectionPoints, errors);
    errors.throwIfNewErrors(numErrorsBefore);
    EncounterImpl<T> encounter = new EncounterImpl<>(errors, injector.lookups);
    Set<TypeListener> alreadySeenListeners = Sets.newHashSet();
    for (TypeListenerBinding binding : typeListenerBindings) {
        TypeListener typeListener = binding.getListener();
        if (!alreadySeenListeners.contains(typeListener) && binding.getTypeMatcher().matches(type)) {
            alreadySeenListeners.add(typeListener);
            try {
                typeListener.hear(type, encounter);
            } catch (RuntimeException e) {
                errors.errorNotifyingTypeListener(binding, type, e);
            }
        }
    }
    encounter.invalidate();
    errors.throwIfNewErrors(numErrorsBefore);
    return new MembersInjectorImpl<T>(injector, type, encounter, injectors);
} 
{
    List<SingleMemberInjector> injectors = Lists.newArrayList();
    for (InjectionPoint injectionPoint : injectionPoints) {
        try {
            Errors errorsForMember = injectionPoint.isOptional() ? new Errors(injectionPoint) : errors.withSource(injectionPoint);
            SingleMemberInjector injector = injectionPoint.getMember() instanceof Field ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember) : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember);
            injectors.add(injector);
        } catch (ErrorsException ignoredForNow) {
        // ignored for now
        }
    }
    return ImmutableList.copyOf(injectors);
} 
",,,,,3,77
Annotations.java,64,274,0.23357664233576642,"
 * Annotation utilities.
 *
 * @author crazybob@google.com (Bob Lee)
 | NOTE: getKey/findBindingAnnotation are used by Gin which is abandoned.  So changing this API| will prevent Gin users from upgrading Guice version.| Checks for the presence of annotations. Caches results because Android doesn't. ","/**
 * Returns {@code true} if the given annotation type has no attributes.
 */
 
/**
 * Generates an Annotation for the annotation class. Requires that the annotation is all
 * optionals.
 */
 
/**
 * Implements {@link Annotation#equals}.
 */
 
/**
 * Implements {@link Annotation#hashCode}.
 */
 
/**
 * Implements {@link Annotation#toString}.
 */
 
/**
 * Returns true if the given annotation is retained at runtime.
 */
 
/**
 * Returns the scope annotation on {@code type}, or null if none is specified.
 */
 
/**
 * Returns the scoping annotation, or null if there isn't one.
 */
 
/**
 * Returns {@code value}, quoted if annotation implementations quote their member values. In Java
 * 9, annotations quote their string members.
 */
 
/**
 * Returns true if the given type has one of the desired annotations.
 */
 
/**
 * Adds an error if there is a misplaced annotations on {@code type}. Scoping annotations are not
 * allowed on abstract classes or interfaces.
 */
 
/**
 * Gets a key for the given type, member and annotations.
 */
 
/**
 * Returns the binding annotation on {@code member}, or null if there isn't one.
 */
 
/**
 * Returns true if annotations of the specified type are binding annotations.
 */
 
/**
 * If the annotation is an instance of {@code javax.inject.Named}, canonicalizes to
 * com.google.guice.name.Named. Returns the given annotation otherwise.
 */
 
/**
 * If the annotation is the class {@code javax.inject.Named}, canonicalizes to
 * com.google.guice.name.Named. Returns the given annotation class otherwise.
 */
 
/**
 * Returns the name the binding should use. This is based on the annotation. If the annotation has
 * an instance and is not a marker annotation, we ask the annotation for its toString. If it was a
 * marker annotation or just an annotation type, we use the annotation's name. Otherwise, the name
 * is the empty string.
 */
 
","{
    return annotationType.getDeclaredMethods().length == 0;
} 
{
    Preconditions.checkState(isAllDefaultMethods(annotationType), ""%s is not all default methods"", annotationType);
    return (T) cache.getUnchecked(annotationType);
} 
{
    if (!type.isInstance(other)) {
        return false;
    }
    for (Method method : type.getDeclaredMethods()) {
        String name = method.getName();
        if (!Arrays.deepEquals(new Object[] { method.invoke(other) }, new Object[] { members.get(name) })) {
            return false;
        }
    }
    return true;
} 
{
    int result = 0;
    for (Method method : type.getDeclaredMethods()) {
        String name = method.getName();
        Object value = members.get(name);
        result += (127 * name.hashCode()) ^ (Arrays.deepHashCode(new Object[] { value }) - 31);
    }
    return result;
} 
{
    StringBuilder sb = new StringBuilder().append(""@"").append(type.getName()).append(""("");
    JOINER.appendTo(sb, Maps.transformValues(members, arg -> {
        String s = Arrays.deepToString(new Object[] { arg });
        // cut off brackets
        return s.substring(1, s.length() - 1);
    }));
    return sb.append("")"").toString();
} 
{
    Retention retention = annotationType.getAnnotation(Retention.class);
    return retention != null && retention.value() == RetentionPolicy.RUNTIME;
} 
{
    return findScopeAnnotation(errors, implementation.getAnnotations());
} 
{
    Class<? extends Annotation> found = null;
    for (Annotation annotation : annotations) {
        Class<? extends Annotation> annotationType = annotation.annotationType();
        if (isScopeAnnotation(annotationType)) {
            if (found != null) {
                errors.duplicateScopeAnnotations(found, annotationType);
            } else {
                found = annotationType;
            }
        }
    }
    return found;
} 
{
    return QUOTE_MEMBER_VALUES ? ""\"""" + value + ""\"""" : value;
} 
{
    return cache.getUnchecked(annotated);
} 
{
    if (Classes.isConcrete(type)) {
        return;
    }
    Class<? extends Annotation> scopeAnnotation = findScopeAnnotation(errors, type);
    if (scopeAnnotation != null && // We let Dagger Components through to aid migrations.
    !containsComponentAnnotation(type.getAnnotations())) {
        errors.withSource(type).scopeAnnotationOnAbstractType(scopeAnnotation, type, source);
    }
} 
{
    int numErrorsBefore = errors.size();
    Annotation found = findBindingAnnotation(errors, member, annotations);
    errors.throwIfNewErrors(numErrorsBefore);
    return found == null ? Key.get(type) : Key.get(type, found);
} 
{
    Annotation found = null;
    for (Annotation annotation : annotations) {
        Class<? extends Annotation> annotationType = annotation.annotationType();
        if (isBindingAnnotation(annotationType)) {
            if (found != null) {
                errors.duplicateBindingAnnotations(member, found.annotationType(), annotationType);
            } else {
                found = annotation;
            }
        }
    }
    return found;
} 
{
    return bindingAnnotationChecker.hasAnnotations(annotationType);
} 
{
    if (annotation instanceof javax.inject.Named) {
        return Names.named(((javax.inject.Named) annotation).value());
    } else {
        return annotation;
    }
} 
{
    if (annotationType == javax.inject.Named.class) {
        return Named.class;
    } else {
        return annotationType;
    }
} 
{
    Annotation annotation = key.getAnnotation();
    Class<? extends Annotation> annotationType = key.getAnnotationType();
    if (annotation != null && !isMarker(annotationType)) {
        return key.getAnnotation().toString();
    } else if (key.getAnnotationType() != null) {
        return ""@"" + key.getAnnotationType().getName();
    } else {
        return """";
    }
} 
","/**
 * Constructs a new checker that looks for annotations of the given types.
 */
 
","{
    this.annotationTypes = annotationTypes;
} 
","/**
 * Returns true if the given class has one of the desired annotations.
 */
 
","Field hasAnnotations
",4,294
InternalFactory.java,20,67,0.29850746268656714,"
 * Creates objects which will be injected.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Creates an object to be injected.
 *
 * @param context of this injection
 * @param linked true if getting as a result of a linked binding
 * @throws com.google.inject.internal.InternalProvisionException if a value cannot be provided
 * @return instance that was created
 */
 
","get 
",,,,,3,82
ProvisionListenerStackCallback.java,25,105,0.23809523809523808,"
 * Intercepts provisions with a stack of listeners.
 *
 * @author sameb@google.com (Sam Berlin)
 | TODO(sameb): Can this be more InternalFactory-like?",,,,,,,4,144
Element.java,17,69,0.2463768115942029,"
 * An internal binding annotation applied to each element in a multibinding. All elements are
 * assigned a globally-unique id to allow different modules to contribute multibindings
 * independently.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,5,243
AbstractProcessor.java,23,38,0.6052631578947368,"
 * Abstract base class for creating an injector from module elements.
 *
 * <p>Extending classes must return {@code true} from any overridden {@code visit*()} methods, in
 * order for the element processor to remove the handled element.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,6,277
ProxyFactory.java,38,209,0.18181818181818182,"
 * Builds a construction proxy that can participate in AOP. This class manages applying type and
 * method matchers to come up with the set of intercepted methods.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 |
   * A callback filter that maps methods to unique IDs. We define equals and hashCode without using
   * any state related to the injector so that enhanced classes intercepting the same methods can be
   * shared between injectors (and child injectors, etc).
   | Constructs instances that participate in AOP. ","/**
 * Returns the interceptors that apply to the constructed type.
 */
 
","{
    return interceptors;
} 
",,,"/**
 * PUBLIC is default; it's used if all the methods we're intercepting are public. This impacts
 * which classloader we should use for loading the enhanced class
 */
 
","Field visibility
",9,514
RealMapBinder.java,180,978,0.18404907975460122,"
 * The actual mapbinder plays several roles:
 *
 * <p>As a MapBinder, it acts as a factory for LinkedBindingBuilders for each of the map's values.
 * It delegates to a {@link Multibinder} of entries (keys to value providers).
 *
 * <p>As a Module, it installs the binding to the map itself, as well as to a corresponding map
 * whose values are providers.
 *
 * <p>As a module, this implements equals() and hashcode() in order to trick Guice into executing
 * its configure() method only once. That makes it so that multiple mapbinders can be created for
 * the same target map, but only one is bound. Since the list of bindings is retrieved from the
 * injector itself (and not the mapbinder), each mapbinder has access to all contributions from all
 * equivalent mapbinders.
 *
 * <p>Rather than binding a single Map.Entry&lt;K, V&gt;, the map binder binds keys and values
 * independently. This allows the values to be properly scoped.
 | Note: We use valueTypeAndAnnotation effectively as a Pair<TypeLiteral, Annotation|Class>| Until the injector initializes us, we don't know what our dependencies are,| A factory for a {@code Map.Entry<K, Provider<V>>}. |
   * The BindingSelection contains some of the core state and logic for the MapBinder.
   *
   * <p>It lazily computes the value for keys for various permutations of Maps that are provided by
   * this module. It also builds up maps from {@code K} to {@code Binding<V>}, which is used by all
   * of the internal factories to actually provide the desired maps.
   *
   * <p>During initialization time there is only one BindingSelection. It is possible that multiple
   * different BindingSelections are constructed. Specifically, in the case of two different modules
   * each adding bindings to the same MapBinder. If that happens, we define the BindingSelection
   * held by the {@link RealMapProvider} to be the authoritative one. The logic for this exists in
   * {@link RealMultimapBinderProviderWithDependencies}. This is done to avoid confusion because the
   * BindingSelection contains mutable state.
   | Note: We use valueTypeAndAnnotation effectively as a Pair<TypeLiteral, Annotation|Class>| Until the injector initializes us, we don't know what our dependencies are,| A factory for a {@code Map.Entry<K, Provider<V>>}. |
   * Binds {@code Map<K, Set<V>>} and {{@code Map<K, Set<Provider<V>>>}.
   *
   * <p>This will only exist if permitDuplicates() is called.
   |
       * A simple class to hold a key and the associated bindings as an array.
       *
       * <p>Arrays are used for performance.
       | Note: We use valueTypeAndAnnotation effectively as a Pair<TypeLiteral, Annotation|Class>| Until the injector initializes us, we don't know what our dependencies are,| A factory for a {@code Map.Entry<K, Provider<V>>}. | VisibleForTesting| Note: We use valueTypeAndAnnotation effectively as a Pair<TypeLiteral, Annotation|Class>| Until the injector initializes us, we don't know what our dependencies are,| A factory for a {@code Map.Entry<K, Provider<V>>}. | A base class for ProviderWithDependencies that need equality based on a specific object. | Note: We use valueTypeAndAnnotation effectively as a Pair<TypeLiteral, Annotation|Class>| Until the injector initializes us, we don't know what our dependencies are,| A factory for a {@code Map.Entry<K, Provider<V>>}. |
   * A base class for ProviderWithDependencies that need equality based on a specific object.
   *
   * <p>This differs from {@link RealMapBinderProviderWithDependencies} in that it gets the {@code
   * bindingSelection} from the injector at initialization time, rather than in the constructor.
   * This is done to allow all the providers to operate on the same instance of the {@link
   * BindingSelection}.
   ","/**
 * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 * Map} that is itself bound with no binding annotation.
 */
 
/**
 * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 * Map} that is itself bound with {@code annotation}.
 */
 
/**
 * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a {@link
 * Map} that is itself bound with {@code annotationType}.
 */
 
/**
 * Given a Key<T> will return a Key<Provider<T>>
 */
 
/**
 * Adds a binding to the map for the given key.
 */
 
/**
 * This creates two bindings. One for the {@code Map.Entry<K, Provider<V>>} and another for {@code
 * V}.
 */
 
/**
 * Will initialize internal data structures.
 *
 * @return {@code true} if initialization was successful, {@code false} if there were errors
 */
 
/**
 * Returns true if the key indicates this is a value in the map.
 */
 
/**
 * Initialize the factory. BindingSelection is guaranteed to be initialized at this point and
 * this will be called prior to any provisioning.
 */
 
/**
 * This will get the authoritative {@link BindingSelection} from the map provider. This
 * guarantees that everyone has the same instance of the bindingSelection and sees consistent
 * state.
 */
 
/**
 * Initialize the factory. BindingSelection is guaranteed to be initialized at this point and
 * this will be called prior to any provisioning.
 */
 
","{
    binder = binder.skipSources(RealMapBinder.class);
    return newRealMapBinder(binder, keyType, valueType, Key.get(mapOf(keyType, valueType)), RealMultibinder.newRealSetBinder(binder, Key.get(entryOfProviderOf(keyType, valueType))));
} 
{
    binder = binder.skipSources(RealMapBinder.class);
    return newRealMapBinder(binder, keyType, valueType, Key.get(mapOf(keyType, valueType), annotation), RealMultibinder.newRealSetBinder(binder, Key.get(entryOfProviderOf(keyType, valueType), annotation)));
} 
{
    binder = binder.skipSources(RealMapBinder.class);
    return newRealMapBinder(binder, keyType, valueType, Key.get(mapOf(keyType, valueType), annotationType), RealMultibinder.newRealSetBinder(binder, Key.get(entryOfProviderOf(keyType, valueType), annotationType)));
} 
{
    return (Key<Provider<T>>) valueKey.ofType(Types.providerOf(valueKey.getTypeLiteral().getType()));
} 
{
    checkNotNull(key, ""key"");
    checkConfiguration(!bindingSelection.isInitialized(), ""MapBinder was already initialized"");
    RealMultibinder<Map.Entry<K, Provider<V>>> entrySetBinder = bindingSelection.getEntrySetBinder();
    Key<V> valueKey = Key.get(bindingSelection.getValueType(), new RealElement(entrySetBinder.getSetName(), MAPBINDER, bindingSelection.getKeyType().toString()));
    entrySetBinder.addBinding().toProvider(new ProviderMapEntry<K, V>(key, valueKey));
    return valueKey;
} 
{
    return binder.bind(getKeyForNewValue(key));
} 
{
    // Every one of our providers will call this method, so only execute the logic once.
    if (initializationState != InitializationState.UNINITIALIZED) {
        return initializationState != InitializationState.HAS_ERRORS;
    }
    // Multiple different modules can all contribute to the same MapBinder, and if any
    // one of them permits duplicates, then the map binder as a whole will permit duplicates.
    // Since permitDuplicates() may not have been called on this instance, we need to go
    // to the injector to see if permitDuplicates was set.
    permitsDuplicates = entrySetBinder.permitsDuplicates(injector);
    // We now build the Map<K, Set<Binding<V>>> from the entrySetBinder.
    // The entrySetBinder contains all of the ProviderMapEntrys, and once
    // we have those, it's easy to iterate through them to organize them by K.
    Map<K, ImmutableSet.Builder<Binding<V>>> bindingMultimapMutable = new LinkedHashMap<K, ImmutableSet.Builder<Binding<V>>>();
    Map<K, Binding<V>> bindingMapMutable = new LinkedHashMap<>();
    Multimap<K, Indexer.IndexedBinding> index = HashMultimap.create();
    Indexer indexer = new Indexer(injector);
    Multimap<K, Binding<V>> duplicates = null;
    ImmutableList.Builder<Map.Entry<K, Binding<V>>> entriesBuilder = ImmutableList.builder();
    // We get all of the Bindings that were put into the entrySetBinder
    for (Binding<Map.Entry<K, Provider<V>>> binding : injector.findBindingsByType(entrySetBinder.getElementTypeLiteral())) {
        if (entrySetBinder.containsElement(binding)) {
            // Protected by findBindingByType() and the fact that all providers are added by us
            // in addBinding(). It would theoretically be possible for someone to directly
            // add their own binding to the entrySetBinder, but they shouldn't do that.
            @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
            ProviderInstanceBinding<ProviderMapEntry<K, V>> entryBinding = (ProviderInstanceBinding) binding;
            // We added all these bindings initially, so we know they are ProviderMapEntrys
            @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
            ProviderMapEntry<K, V> entry = (ProviderMapEntry) entryBinding.getUserSuppliedProvider();
            K key = entry.getKey();
            Key<V> valueKey = entry.getValueKey();
            Binding<V> valueBinding = injector.getExistingBinding(valueKey);
            // Use the indexer to de-dupe user bindings. This is needed because of the
            // uniqueId in RealElement. The uniqueId intentionally circumvents the regular
            // Guice deduplication, so we need to re-implement our own here, ignoring
            // uniqueId.
            if (index.put(key, valueBinding.acceptTargetVisitor(indexer))) {
                entriesBuilder.add(Maps.immutableEntry(key, valueBinding));
                Binding<V> previous = bindingMapMutable.put(key, valueBinding);
                // Check if this is a duplicate binding
                if (previous != null && !permitsDuplicates) {
                    if (duplicates == null) {
                        // This is linked for both keys and values to maintain order
                        duplicates = LinkedHashMultimap.create();
                    }
                    // We add both the previous and the current value to the duplicates map.
                    // This is because if there are three duplicates, we will only execute this code
                    // for the second and third, but we want all three values to display a helpful
                    // error message. We rely on the multimap to dedupe repeated values.
                    duplicates.put(key, previous);
                    duplicates.put(key, valueBinding);
                }
                // Don't do extra work unless we need to
                if (permitsDuplicates) {
                    // Add the binding, creating a set builder if it's the first time we've seen it
                    bindingMultimapMutable.computeIfAbsent(key, k -> ImmutableSet.builder()).add(valueBinding);
                }
            }
        }
    }
    // It is safe to check if duplicates is non-null because if duplicates are allowed,
    // we don't build up this data structure
    if (duplicates != null) {
        initializationState = InitializationState.HAS_ERRORS;
        reportDuplicateKeysError(duplicates, errors);
        return false;
    }
    // Build all of the ImmutableSet.Builders,
    // transforming from Map<K, ImmutableSet.Builder<Binding<V>>> to
    // ImmutableMap<K, Set<Binding<V>>>
    ImmutableMap.Builder<K, Set<Binding<V>>> bindingsMultimapBuilder = ImmutableMap.builder();
    for (Map.Entry<K, ImmutableSet.Builder<Binding<V>>> entry : bindingMultimapMutable.entrySet()) {
        bindingsMultimapBuilder.put(entry.getKey(), entry.getValue().build());
    }
    mapBindings = ImmutableMap.copyOf(bindingMapMutable);
    multimapBindings = bindingsMultimapBuilder.build();
    entries = entriesBuilder.build();
    initializationState = InitializationState.INITIALIZED;
    return true;
} 
{
    return key.getAnnotation() instanceof RealElement && ((RealElement) key.getAnnotation()).setName().equals(entrySetBinder.getSetName()) && ((RealElement) key.getAnnotation()).type() == MAPBINDER && ((RealElement) key.getAnnotation()).keyType().equals(keyType.toString()) && key.getTypeLiteral().equals(valueType);
} 
doInitialize 
{
    Binding<Map<K, V>> mapBinding = injector.getExistingBinding(mapKey);
    ProviderInstanceBinding<Map<K, V>> providerInstanceBinding = (ProviderInstanceBinding<Map<K, V>>) mapBinding;
    @SuppressWarnings(""unchecked"")
    RealMapProvider<K, V> mapProvider = (RealMapProvider<K, V>) providerInstanceBinding.getUserSuppliedProvider();
    this.bindingSelection = mapProvider.getBindingSelection();
    if (bindingSelection.tryInitialize(injector, errors)) {
        doInitialize(injector, errors);
    }
} 
doInitialize 
",,,"/**
 * These are built during initialization and used by all factories to actually provide the
 * relevant maps. These contain all of the necessary information about the map binder.
 */
 
/**
 * Indicates if this Map permits duplicates. It is initialized during initialization by querying
 * the injector. This is done because multiple different modules can contribute to a MapBinder,
 * and any one could set permitDuplicates.
 */
 
/**
 * An array of all the injectors.
 *
 * <p>This is parallel to array of keys below
 */
 
","Field mapBindings
Field permitsDuplicates
Field injectors
",44,3683
InjectorShell.java,46,234,0.19658119658119658,"
 * A partially-initialized injector. See {@link InternalInjectorCreator}, which uses this to build a
 * tree of injectors in batch.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Synchronize on this before calling {@link #build}.
 */
 
/**
 * Creates and returns the injector shells for the current modules. Multiple shells will be
 * returned if any modules contain {@link Binder#newPrivateBinder private environments}. The
 * primary injector will be first in the returned list.
 */
 
/**
 * The Injector is a special case because we allow both parent and child injectors to both have a
 * binding for that key.
 */
 
/**
 * The Logger is a special case because it knows the injection point of the injected member. It's
 * the only binding that does this.
 */
 
","{
    return getState().lock();
} 
{
    checkState(stage != null, ""Stage not initialized"");
    checkState(privateElements == null || parent != null, ""PrivateElements with no parent"");
    checkState(state != null, ""no state. Did you remember to lock() ?"");
    // bind Singleton if this is a top-level injector
    if (parent == null) {
        modules.add(0, new RootModule());
    } else {
        modules.add(0, new InheritedScannersModule(parent.state));
    }
    elements.addAll(Elements.getElements(stage, modules));
    // Look for injector-changing options
    InjectorOptionsProcessor optionsProcessor = new InjectorOptionsProcessor(errors);
    optionsProcessor.process(null, elements);
    options = optionsProcessor.getOptions(stage, options);
    InjectorImpl injector = new InjectorImpl(parent, state, options);
    if (privateElements != null) {
        privateElements.initInjector(injector);
    }
    // add default type converters if this is a top-level injector
    if (parent == null) {
        TypeConverterBindingProcessor.prepareBuiltInConverters(injector);
    }
    stopwatch.resetAndLog(""Module execution"");
    new MessageProcessor(errors).process(injector, elements);
    /*if[AOP]*/
    new InterceptorBindingProcessor(errors).process(injector, elements);
    stopwatch.resetAndLog(""Interceptors creation"");
    /*end[AOP]*/
    new ListenerBindingProcessor(errors).process(injector, elements);
    List<TypeListenerBinding> typeListenerBindings = injector.state.getTypeListenerBindings();
    injector.membersInjectorStore = new MembersInjectorStore(injector, typeListenerBindings);
    List<ProvisionListenerBinding> provisionListenerBindings = injector.state.getProvisionListenerBindings();
    injector.provisionListenerStore = new ProvisionListenerCallbackStore(provisionListenerBindings);
    stopwatch.resetAndLog(""TypeListeners & ProvisionListener creation"");
    new ScopeBindingProcessor(errors).process(injector, elements);
    stopwatch.resetAndLog(""Scopes creation"");
    new TypeConverterBindingProcessor(errors).process(injector, elements);
    stopwatch.resetAndLog(""Converters creation"");
    bindStage(injector, stage);
    bindInjector(injector);
    bindLogger(injector);
    // Process all normal bindings, then UntargettedBindings.
    // This is necessary because UntargettedBindings can create JIT bindings
    // and need all their other dependencies set up ahead of time.
    new BindingProcessor(errors, initializer, bindingData).process(injector, elements);
    new UntargettedBindingProcessor(errors, bindingData).process(injector, elements);
    stopwatch.resetAndLog(""Binding creation"");
    new ModuleAnnotatedMethodScannerProcessor(errors).process(injector, elements);
    stopwatch.resetAndLog(""Module annotated method scanners creation"");
    List<InjectorShell> injectorShells = Lists.newArrayList();
    injectorShells.add(new InjectorShell(elements, injector));
    // recursively build child shells
    PrivateElementProcessor processor = new PrivateElementProcessor(errors);
    processor.process(injector, elements);
    for (Builder builder : processor.getInjectorShellBuilders()) {
        injectorShells.addAll(builder.build(initializer, bindingData, stopwatch, errors));
    }
    stopwatch.resetAndLog(""Private environment creation"");
    return injectorShells;
} 
{
    Key<Injector> key = Key.get(Injector.class);
    InjectorFactory injectorFactory = new InjectorFactory(injector);
    injector.state.putBinding(key, new ProviderInstanceBindingImpl<Injector>(injector, key, SourceProvider.UNKNOWN_SOURCE, injectorFactory, Scoping.UNSCOPED, injectorFactory, ImmutableSet.<InjectionPoint>of()));
} 
{
    Key<Logger> key = Key.get(Logger.class);
    LoggerFactory loggerFactory = new LoggerFactory();
    injector.state.putBinding(key, new ProviderInstanceBindingImpl<Logger>(injector, key, SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scoping.UNSCOPED, loggerFactory, ImmutableSet.<InjectionPoint>of()));
} 
",,,"/**
 * lazily constructed
 */
 
/**
 * null unless this exists in a {@link Binder#newPrivateBinder private environment}
 */
 
","Field state
Field privateElements
",4,177
ProviderInternalFactory.java,27,55,0.4909090909090909,"
 * Base class for InternalFactories that are used by Providers, to handle circular dependencies.
 *
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Provisions a new instance. Subclasses should override this to catch exceptions & rethrow as
 * ErrorsExceptions.
 */
 
","{
    T t = provider.get();
    if (t == null && !dependency.isNullable()) {
        InternalProvisionException.onNullInjectedIntoNonNullableDependency(source, dependency);
    }
    constructionContext.setProxyDelegates(t);
    return t;
} 
",,,,,3,136
ConstructionProxy.java,29,13,2.230769230769231,"
 * Proxies calls to a {@link java.lang.reflect.Constructor} for a class {@code T}.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Constructs an instance of {@code T} for the given arguments.
 */
 
/**
 * Returns the injection point for this constructor.
 */
 
/**
 * Returns the injected constructor. If the injected constructor is synthetic (such as generated
 * code for method interception), the natural constructor is returned.
 */
 
/**
 * Returns the interceptors applied to each method, in order of invocation.
 */
 
","newInstance 
getInjectionPoint 
getConstructor 
getMethodInterceptors 
",,,,,3,122
DeclaredMembers.java,38,50,0.76,"
 * Utility class for retrieving declared fields or methods in a particular order, because the JVM
 * doesn't guarantee ordering for listing declared methods. We don't externally guarantee an
 * ordering, but having a consistent ordering allows deterministic behavior and simpler tests.
 ",,,,,"/**
 * An ordering suitable for comparing two classes if they are loaded by the same classloader
 *
 * <p>Within a single classloader there can only be one class with a given name, so we just
 * compare the names.
 */
 
/**
 * An ordering suitable for comparing two fields if they are owned by the same class.
 *
 * <p>Within a single class it is sufficent to compare the non-generic field signature which
 * consists of the field name and type.
 */
 
/**
 * An ordering suitable for comparing two methods if they are owned by the same class.
 *
 * <p>Within a single class it is sufficient to compare the non-generic method signature which
 * consists of the name, return type and parameter types.
 */
 
","Field CLASS_ORDERING
Field FIELD_ORDERING
Field METHOD_ORDERING
",3,281
Initializer.java,80,159,0.5031446540880503,"
 * Manages and injects instances at injector-creation time. This is made more complicated by
 * instances that request other instances while they're being injected. We overcome this by using
 * {@link Initializable}, which attempts to perform injection before use.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Registers an instance for member injection when that step is performed.
 *
 * @param instance an instance that optionally has members to be injected (each annotated
 *     with @Inject).
 * @param binding the binding that caused this initializable to be created, if it exists.
 * @param source the source location that this injection was requested
 */
 
/**
 * Prepares member injectors for all injected instances. This prompts Guice to do static analysis
 * on the injected instances.
 */
 
/**
 * Performs creation-time injections on all objects that require it. Whenever fulfilling an
 * injection depends on another object that requires injection, we inject it first. If the two
 * instances are codependent (directly or transitively), ordering of injection is arbitrary.
 */
 
/**
 * Reentrant. If {@code instance} was registered for injection at injector-creation time, this
 * method will ensure that all its members have been injected before returning.
 */
 
","{
    checkNotNull(source);
    Preconditions.checkState(!validationStarted, ""Member injection could not be requested after validation is started"");
    ProvisionListenerStackCallback<T> provisionCallback = binding == null ? null : injector.provisionListenerStore.get(binding);
    // short circuit if the object has no injections or listeners.
    if (instance == null || (injectionPoints.isEmpty() && !injector.membersInjectorStore.hasTypeListeners() && provisionCallback == null)) {
        return Initializables.of(instance);
    }
    if (initializablesCache.containsKey(instance)) {
        // Map from T to InjectableReference<T>
        @SuppressWarnings(""unchecked"")
        Initializable<T> cached = (Initializable<T>) initializablesCache.get(instance);
        return cached;
    }
    InjectableReference<T> injectableReference = new InjectableReference<T>(injector, instance, binding == null ? null : binding.getKey(), provisionCallback, source, cycleDetectingLockFactory.create(instance.getClass()));
    initializablesCache.put(instance, injectableReference);
    pendingInjections.add(injectableReference);
    return injectableReference;
} 
{
    validationStarted = true;
    initializablesCache.clear();
    for (InjectableReference<?> reference : pendingInjections) {
        try {
            reference.validate(errors);
        } catch (ErrorsException e) {
            errors.merge(e.getErrors());
        }
    }
} 
{
    Preconditions.checkState(validationStarted, ""Validation should be done before injection"");
    for (InjectableReference<?> reference : pendingInjections) {
        try {
            reference.get();
        } catch (InternalProvisionException ipe) {
            errors.merge(ipe);
        }
    }
    pendingInjections.clear();
} 
{
    // skipping acquiring lock if initialization is already finished
    if (state == InjectableReferenceState.READY) {
        return instance;
    }
    // acquire lock for current binding to initialize an instance
    Multimap<?, ?> lockCycle = lock.lockOrDetectPotentialLocksCycle();
    if (!lockCycle.isEmpty()) {
        // Potential deadlock detected and creation lock is not taken.
        // According to injectAll()'s contract return non-initialized instance.
        // This condition should not be possible under the current Guice implementation.
        // This clause exists for defensive programming purposes.
        // Reasoning:
        // get() is called either directly from injectAll(), holds no locks and can not create
        // a cycle, or it is called through a singleton scope, which resolves deadlocks by itself.
        // Before calling get() object has to be requested for injection.
        // Initializer.requestInjection() is called either for constant object bindings, which wrap
        // creation into a Singleton scope, or from Binder.requestInjection(), which
        // has to use Singleton scope to reuse the same InjectableReference to potentially
        // create a lock cycle.
        return instance;
    }
    try {
        // lock acquired, current thread owns this instance initialization
        switch(state) {
            case READY:
                return instance;
            // When instance depends on itself in the same thread potential dead lock
            // is not detected. We have to prevent a stack overflow and we use
            // an ""injecting"" stage to short-circuit a call.
            case INJECTING:
                return instance;
            case VALIDATED:
                state = InjectableReferenceState.INJECTING;
                break;
            case NEW:
                throw new IllegalStateException(""InjectableReference is not validated yet"");
            default:
                throw new IllegalStateException(""Unknown state: "" + state);
        }
        // if in Stage.TOOL, we only want to inject & notify toolable injection points.
        // (otherwise we'll inject all of them)
        try {
            membersInjector.injectAndNotify(instance, key, provisionCallback, source, injector.options.stage == Stage.TOOL);
        } catch (InternalProvisionException ipe) {
            throw ipe.addSource(source);
        }
        // mark instance as ready to skip a lock on subsequent calls
        state = InjectableReferenceState.READY;
        return instance;
    } finally {
        // always release our creation lock, even on failures
        lock.unlock();
    }
} 
",,,"/**
 * Is set to true once {@link #validateOustandingInjections} is called.
 */
 
/**
 * Allows us to detect circular dependencies. It's only used during injectable reference
 * initialization. After initialization direct access through volatile field is used.
 */
 
/**
 * Instances that need injection during injector creation to a source that registered them. New
 * references added before {@link #validateOustandingInjections}. Cleared up in {@link
 * #injectAll}.
 */
 
/**
 * Map that guarantees that no instance would get two references. New references added before
 * {@link #validateOustandingInjections}. Cleared up in {@link #validateOustandingInjections}.
 */
 
","Field validationStarted
Field cycleDetectingLockFactory
Field pendingInjections
Field initializablesCache
",5,308
TypeConverterBindingProcessor.java,23,156,0.14743589743589744,"
 * Handles {@code Binder.convertToTypes} commands.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Installs default converters for primitives, enums, and class literals.
 */
 
","{
    // Configure type converters.
    convertToPrimitiveType(injector, int.class, Integer.class);
    convertToPrimitiveType(injector, long.class, Long.class);
    convertToPrimitiveType(injector, boolean.class, Boolean.class);
    convertToPrimitiveType(injector, byte.class, Byte.class);
    convertToPrimitiveType(injector, short.class, Short.class);
    convertToPrimitiveType(injector, float.class, Float.class);
    convertToPrimitiveType(injector, double.class, Double.class);
    convertToClass(injector, Character.class, new TypeConverter() {

        @Override
        public Object convert(String value, TypeLiteral<?> toType) {
            value = value.trim();
            if (value.length() != 1) {
                throw new RuntimeException(""Length != 1."");
            }
            return value.charAt(0);
        }

        @Override
        public String toString() {
            return ""TypeConverter<Character>"";
        }
    });
    convertToClasses(injector, Matchers.subclassesOf(Enum.class), new TypeConverter() {

        @Override
        @SuppressWarnings(""unchecked"")
        public Object convert(String value, TypeLiteral<?> toType) {
            return Enum.valueOf((Class) toType.getRawType(), value);
        }

        @Override
        public String toString() {
            return ""TypeConverter<E extends Enum<E>>"";
        }
    });
    internalConvertToTypes(injector, new AbstractMatcher<TypeLiteral<?>>() {

        @Override
        public boolean matches(TypeLiteral<?> typeLiteral) {
            return typeLiteral.getRawType() == Class.class;
        }

        @Override
        public String toString() {
            return ""Class<?>"";
        }
    }, new TypeConverter() {

        @Override
        @SuppressWarnings(""unchecked"")
        public Object convert(String value, TypeLiteral<?> toType) {
            try {
                return Class.forName(value);
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(e.getMessage());
            }
        }

        @Override
        public String toString() {
            return ""TypeConverter<Class<?>>"";
        }
    });
} 
",,,,,4,137
MembersInjectorImpl.java,40,138,0.2898550724637681,"
 * Injects members of instances of a given type.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,3,96
InterceptorBindingProcessor.java,21,14,1.5,"
 * Handles {@code Binder.bindInterceptor} commands.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,4,138
PrivateElementsImpl.java,23,97,0.23711340206185566," @author jessewilson@google.com (Jesse Wilson) ",,,,,"/**
 * lazily instantiated
 */
 
/**
 * lazily instantiated
 */
 
","Field elements
Field exposedKeysToSources
",1,47
Indexer.java,24,141,0.1702127659574468,"
 * Visits bindings to return a {@code IndexedBinding} that can be used to emulate the binding
 * deduplication that Guice internally performs.
 *
 * <p>Note: simply using equals/hashCode on the BindingImpls doesn't work because they all have
 * unique annotations. This works around that by reimplementing equality semantics that ignores
 * {@link Element#uniqueId()}. A better solution might be to introduce the idea of an 'anonymous'
 * binding to guice, that might support this usecase directly.
 ",,,,,,,7,486
ErrorsException.java,24,10,2.4,"
 * Indicates that a result could not be returned while preparing or resolving a binding. The caller
 * should {@link Errors#merge(Errors) merge} the errors from this exception with their existing
 * errors.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,5,250
InternalProvisionException.java,63,141,0.44680851063829785,"
 * A checked exception for provisioning errors.
 *
 * <p>This is the internal dual of {@link ProvisionException}, similar to the relationship between
 * {@link com.google.inject.ConfigurationException} and {@link ErrorsException}. This is useful for
 * several reasons:
 *
 * <ul>
 *   <li>Since it is a checked exception, we get some assistance from the java compiler in ensuring
 *       that we correctly handle it everywhere. ProvisionException is unchecked.
 *   <li>Since this is an internal package, we can add useful construction and mutation APIs that
 *       would be undesirable in a public supported API.
 * </ul>
 *
 * <p>This exception will be thrown when errors are encountered during provisioning, ErrorsException
 * will continue to be used for errors that are encountered during provisioning and both make use of
 * the {@link Message} as the core model.
 *
 * <p>NOTE: this object stores a list of messages but in the most common case the cardinality will
 * be 1. The only time that multiple errors might be reported via this mechanism is when {@link
 * #errorInUserCode} is called with an exception that holds multiple errors (like
 * ProvisionException).
 ","/**
 * Returns {@code value} if it is non-null or allowed to be null. Otherwise a message is added and
 * an {@code InternalProvisionException} is thrown.
 */
 
/**
 * Prepends the given {@code source} to the stack of binding sources for the errors reported in
 * this exception.
 *
 * <p>See {@link Errors#withSource(Object)}
 *
 * <p>It is expected that this method is called as the exception propagates up the stack.
 *
 * @param source
 * @return {@code this}
 */
 
/**
 * Returns this exception convered to a ProvisionException.
 */
 
","{
    // Hack to allow null parameters to @Provides methods, for backwards compatibility.
    if (dependency.getInjectionPoint().getMember() instanceof Method) {
        Method annotated = (Method) dependency.getInjectionPoint().getMember();
        if (annotated.isAnnotationPresent(Provides.class)) {
            switch(InternalFlags.getNullableProvidesOption()) {
                case ERROR:
                    // break out & let the below exception happen
                    break;
                case IGNORE:
                    // user doesn't care about injecting nulls to non-@Nullables.
                    return;
                case WARN:
                    // Warn only once, otherwise we spam logs too much.
                    if (warnedDependencies.add(dependency)) {
                        logger.log(Level.WARNING, ""Guice injected null into {0} (a {1}), please mark it @Nullable."" + "" Use -Dguice_check_nullable_provides_params=ERROR to turn this into an"" + "" error."", new Object[] { Messages.formatParameter(dependency), Messages.convert(dependency.getKey()) });
                    }
                    return;
            }
        }
    }
    Object formattedDependency = (dependency.getParameterIndex() != -1) ? Messages.formatParameter(dependency) : StackTraceElements.forMember(dependency.getInjectionPoint().getMember());
    throw InternalProvisionException.create(""null returned by binding at %s%n but %s is not @Nullable"", source, formattedDependency).addSource(source);
} 
{
    if (source == SourceProvider.UNKNOWN_SOURCE) {
        return this;
    }
    int sz = sourcesToPrepend.size();
    if (sz > 0 && sourcesToPrepend.get(sz - 1) == source) {
        // This is for when there are two identical sources added in a row.  This behavior is copied
        // from Errors.withSource where it can happen when an constructor/provider method throws an
        // exception
        return this;
    }
    sourcesToPrepend.add(source);
    return this;
} 
{
    return new ProvisionException(getErrors());
} 
",,,,,21,1137
Stopwatch.java,22,17,1.2941176470588236,"
 * Enables simple performance monitoring.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Resets and returns elapsed time in milliseconds.
 */
 
/**
 * Resets and logs elapsed time in milliseconds.
 */
 
","{
    long now = System.currentTimeMillis();
    try {
        return now - start;
    } finally {
        start = now;
    }
} 
{
    logger.fine(label + "": "" + reset() + ""ms"");
} 
",,,,,3,81
SourceProvider.java,29,58,0.5,"
 * Provides access to the calling line of code.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Returns a new instance that also skips {@code moreClassesToSkip}.
 */
 
/**
 * Returns true if the className should be skipped.
 */
 
/**
 * Returns the class names as Strings
 */
 
/**
 * Returns the calling line of code. The selected line is the nearest to the top of the stack that
 * is not skipped.
 */
 
/**
 * Returns the non-skipped module class name.
 */
 
","{
    return new SourceProvider(this, asStrings(moreClassesToSkip));
} 
{
    return (parent != null && parent.shouldBeSkipped(className)) || classNamesToSkip.contains(className);
} 
{
    List<String> strings = Lists.newArrayList();
    for (Class c : classes) {
        strings.add(c.getName());
    }
    return strings;
} 
{
    Preconditions.checkNotNull(stackTraceElements, ""The stack trace elements cannot be null."");
    for (final StackTraceElement element : stackTraceElements) {
        String className = element.getClassName();
        if (!shouldBeSkipped(className)) {
            return element;
        }
    }
    throw new AssertionError();
} 
{
    Preconditions.checkNotNull(moduleClassNames, ""The list of module class names cannot be null."");
    for (final String moduleClassName : moduleClassNames) {
        if (!shouldBeSkipped(moduleClassName)) {
            return new StackTraceElement(moduleClassName, ""configure"", null, -1);
        }
    }
    return UNKNOWN_SOURCE;
} 
",,,"/**
 * Indicates that the source is unknown.
 */
 
","Field UNKNOWN_SOURCE
",3,87
Classes.java,21,41,0.5121951219512195," Class utilities. ","/**
 * Formats a member as concise string, such as {@code java.util.ArrayList.size}, {@code
 * java.util.ArrayList<init>()} or {@code java.util.List.remove()}.
 */
 
/**
 * Returns {@code Field.class}, {@code Method.class} or {@code Constructor.class}.
 */
 
","{
    Class<? extends Member> memberType = Classes.memberType(member);
    if (memberType == Method.class) {
        return member.getDeclaringClass().getName() + ""."" + member.getName() + ""()"";
    } else if (memberType == Field.class) {
        return member.getDeclaringClass().getName() + ""."" + member.getName();
    } else if (memberType == Constructor.class) {
        return member.getDeclaringClass().getName() + "".<init>()"";
    } else {
        throw new AssertionError();
    }
} 
{
    checkNotNull(member, ""member"");
    if (member instanceof Field) {
        return Field.class;
    } else if (member instanceof Method) {
        return Method.class;
    } else if (member instanceof Constructor) {
        return Constructor.class;
    } else {
        throw new IllegalArgumentException(""Unsupported implementation class for Member, "" + member.getClass());
    }
} 
",,,,,1,18
StackTraceElements.java,40,152,0.2631578947368421,"
 * Creates stack trace elements for members.
 *
 * @author crazybob@google.com (Bob Lee)
 |end[AOP]| In-Memory version of {@link StackTraceElement} that does not store the file name. ","/**
 * Clears the internal cache for {@link StackTraceElement StackTraceElements}.
 */
 
/**
 * Returns encoded in-memory version of {@link StackTraceElement StackTraceElements}.
 */
 
/**
 * Decodes in-memory stack trace elements to regular {@link StackTraceElement StackTraceElements}.
 */
 
","{
    elementCache.clear();
    stringCache.clear();
} 
{
    if (stackTraceElements.length == 0) {
        return EMPTY_INMEMORY_STACK_TRACE;
    }
    InMemoryStackTraceElement[] inMemoryStackTraceElements = new InMemoryStackTraceElement[stackTraceElements.length];
    for (int i = 0; i < stackTraceElements.length; i++) {
        inMemoryStackTraceElements[i] = weakIntern(new InMemoryStackTraceElement(stackTraceElements[i]));
    }
    return inMemoryStackTraceElements;
} 
{
    if (inMemoryStackTraceElements.length == 0) {
        return EMPTY_STACK_TRACE;
    }
    StackTraceElement[] stackTraceElements = new StackTraceElement[inMemoryStackTraceElements.length];
    for (int i = 0; i < inMemoryStackTraceElements.length; i++) {
        String declaringClass = inMemoryStackTraceElements[i].getClassName();
        String methodName = inMemoryStackTraceElements[i].getMethodName();
        int lineNumber = inMemoryStackTraceElements[i].getLineNumber();
        stackTraceElements[i] = new StackTraceElement(declaringClass, methodName, UNKNOWN_SOURCE, lineNumber);
    }
    return stackTraceElements;
} 
",,,,,4,177
LineNumbers.java,48,173,0.2774566473988439,"
 * Looks up line numbers for classes and their members.
 *
 * @author Chris Nokleberg
 ","/**
 * Get the source file name as read from the bytecode.
 *
 * @return the source file name if available, or null
 */
 
/**
 * Get the line number associated with the given member.
 *
 * @param member a field, constructor, or method belonging to the class used during construction
 * @return the wrapped line number, or null if not available
 * @throws IllegalArgumentException if the member does not belong to the class used during
 *     construction
 */
 
/**
 * Gets the first line number.
 */
 
","{
    return source;
} 
{
    Preconditions.checkArgument(type == member.getDeclaringClass(), ""Member %s belongs to %s, not %s"", member, member.getDeclaringClass(), type);
    return lines.get(memberKey(member));
} 
{
    return firstLine == Integer.MAX_VALUE ? 1 : firstLine;
} 
","/**
 * Reads line number information from the given class, if available.
 *
 * @param type the class to read line number information from
 */
 
","{
    this.type = type;
    if (!type.isArray()) {
        InputStream in = null;
        try {
            in = type.getResourceAsStream(""/"" + type.getName().replace('.', '/') + "".class"");
        } catch (IllegalStateException ignored) {
        // Some classloaders throw IllegalStateException when they can't load a resource.
        }
        if (in != null) {
            try {
                new ClassReader(in).accept(new LineNumberReader(), ClassReader.SKIP_FRAMES);
            } catch (UnsupportedOperationException ignored) {
            // We may be trying to inspect classes that were compiled with a more recent version
            // of javac than our ASM supports.  If that happens, just ignore the class and don't
            // capture line numbers.
            } finally {
                try {
                    in.close();
                } catch (IOException ignored) {
                }
            }
        }
    }
} 
",,,3,81
BytecodeGen.java,149,230,0.6478260869565218,"
 * Utility methods for runtime code generation and class loading. We use this stuff for {@link
 * net.sf.cglib.reflect.FastClass faster reflection}, {@link net.sf.cglib.proxy.Enhancer method
 * interceptors} and to proxy circular dependencies.
 *
 * <p>When loading classes, we need to be careful of:
 *
 * <ul>
 * <li><strong>Memory leaks.</strong> Generated classes need to be garbage collected in long-lived
 *     applications. Once an injector and any instances it created can be garbage collected, the
 *     corresponding generated classes should be collectable.
 * <li><strong>Visibility.</strong> Containers like <code>OSGi</code> use class loader boundaries to
 *     enforce modularity at runtime.
 * </ul>
 *
 * <p>For each generated class, there's multiple class loaders involved:
 *
 * <ul>
 * <li><strong>The related class's class loader.</strong> Every generated class services exactly one
 *     user-supplied class. This class loader must be used to access members with protected and
 *     package visibility.
 * <li><strong>Guice's class loader.</strong>
 * <li><strong>Our bridge class loader.</strong> This is a child of the user's class loader. It
 *     selectively delegates to either the user's class loader (for user classes) or the Guice class
 *     loader (for internal classes that are used by the generated classes). This class loader that
 *     owns the classes generated by Guice.
 * </ul>
 *
 * @author mcculls@gmail.com (Stuart McCulloch)
 * @author jessewilson@google.com (Jesse Wilson)
 |if[AOP]|end[AOP]|if[NO_AOP]
  private static final String CGLIB_PACKAGE = "" ""; // any string that's illegal in a package name
  end[NO_AOP]|if[AOP]| use fully-qualified names so imports don't need preprocessor statements|end[AOP]| initialization-on-demand...|if[AOP]|end[AOP]|if[NO_AOP]
  private static final String CGLIB_PACKAGE = "" ""; // any string that's illegal in a package name
  end[NO_AOP]|if[AOP]| use fully-qualified names so imports don't need preprocessor statements|end[AOP]|
   * The required visibility of a user's class from a Guice-generated class. Visibility of
   * package-private members depends on the loading classloader: only if two classes were loaded by
   * the same classloader can they see each other's package-private members. We need to be careful
   * when choosing which classloader to use for generated classes. We prefer our bridge classloader,
   * since it's OSGi-safe and doesn't leak permgen space. But often we cannot due to visibility.
   |if[AOP]|end[AOP]|if[NO_AOP]
  private static final String CGLIB_PACKAGE = "" ""; // any string that's illegal in a package name
  end[NO_AOP]|if[AOP]| use fully-qualified names so imports don't need preprocessor statements|end[AOP]|
   * Loader for Guice-generated classes. For referenced classes, this delegates to either either the
   * user's classloader (which is the parent of this classloader) or Guice's class loader.
   ","/**
 * Attempts to canonicalize null references to the system class loader. May return null if for
 * some reason the system loader is unavailable.
 */
 
/**
 * Returns the class loader to host generated classes for {@code type}.
 */
 
/**
 * Returns a FastClass proxy for invoking the given member or {@code null} if access rules
 * disallow it.
 *
 * @see #newFastClassForMember(Class, Member) for a full description
 */
 
/**
 * Returns a FastClass proxy for invoking the given member or {@code null} if access rules
 * disallow it.
 *
 * <p>FastClass works by generating a type in the same package as the target {@code type}. This
 * may or may not work depending on the access level of the class/member. It breaks down into the
 * following cases depending on accessibility:
 *
 * <ul>
 * <li>Public: This always works since we can generate the type into the {@link BridgeClassLoader}
 *     which ensures there are no versioning issues.
 * <li>Package private and Protected: This works as long as:
 *     <ul>
 *     <li>We can generate into the same classloader as the type. This is not possible for JDK
 *         types which use the 'bootstrap' loader.
 *     <li>The classloader of the type has the same version of {@code FastClass} as we do. This
 *         may be violated when running in OSGI bundles.
 *     </ul>
 *
 * <li>Private: This never works.
 * </ul>
 *
 * If we are unable to generate the type, then we return null and callers should work around by
 * using normal java reflection.
 */
 
/**
 * Returns true if the types classloader has the same version of cglib that BytecodeGen has. This
 * only returns false in strange OSGI situations, but it prevents us from using FastClass for non
 * public members.
 */
 
/**
 * Returns true if the member can be called by a fast class generated in a different classloader.
 */
 
","{
    return classLoader != null ? classLoader : SystemBridgeHolder.SYSTEM_BRIDGE.getParent();
} 
{
    return getClassLoader(type, type.getClassLoader());
} 
{
    return newFastClassForMember(member.getDeclaringClass(), member);
} 
{
    if (!new net.sf.cglib.core.VisibilityPredicate(type, false).evaluate(member)) {
        // the member cannot be indexed by fast class.  Bail out.
        return null;
    }
    boolean publiclyCallable = isPubliclyCallable(member);
    if (!publiclyCallable && !hasSameVersionOfCglib(type.getClassLoader())) {
        // The type is in a classloader with a different version of cglib and is not publicly visible
        // (so we can't use the bridge classloader to work around).  Bail out.
        return null;
    }
    net.sf.cglib.reflect.FastClass.Generator generator = new net.sf.cglib.reflect.FastClass.Generator();
    if (publiclyCallable) {
        // Use the bridge classloader if we can
        generator.setClassLoader(getClassLoader(type));
    }
    generator.setType(type);
    generator.setNamingPolicy(FASTCLASS_NAMING_POLICY);
    if (logger.isLoggable(Level.FINE)) {
        logger.fine(""Loading "" + type + "" FastClass with "" + generator.getClassLoader());
    }
    return generator.create();
} 
{
    Class<?> fc = net.sf.cglib.reflect.FastClass.class;
    try {
        return classLoader.loadClass(fc.getName()) == fc;
    } catch (ClassNotFoundException e) {
        return false;
    }
} 
{
    if (!Modifier.isPublic(member.getModifiers())) {
        return false;
    }
    Class<?>[] parameterTypes;
    if (member instanceof Constructor) {
        parameterTypes = ((Constructor) member).getParameterTypes();
    } else {
        Method method = (Method) member;
        if (!Modifier.isPublic(method.getReturnType().getModifiers())) {
            return false;
        }
        parameterTypes = method.getParameterTypes();
    }
    for (Class<?> type : parameterTypes) {
        if (!Modifier.isPublic(type.getModifiers())) {
            return false;
        }
    }
    return true;
} 
",,,"/**
 * ie. ""com.google.inject.internal""
 */
 
/**
 * either ""net.sf.cglib"", or ""com.google.inject.internal.cglib""
 */
 
/**
 * Weak cache of bridge class loaders that make the Guice implementation classes visible to
 * various code-generated proxies of client classes.
 */
 
","Field GUICE_INTERNAL_PACKAGE
Field CGLIB_PACKAGE
Field CLASS_LOADER_CACHE
",44,2855
InternalContext.java,48,91,0.5274725274725275,"
 * Internal context. Used to coordinate injections and support circular dependencies.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Should only be called by InjectorImpl.enterContext().
 */
 
/**
 * Should be called any any method that received an instance via InjectorImpl.enterContext().
 */
 
/**
 * Sets the new current dependency & adds it to the state.
 */
 
/**
 * Pops the current state & sets the new dependency.
 */
 
/**
 * Adds to the state without setting the dependency.
 */
 
/**
 * Pops from the state without setting a dependency.
 */
 
/**
 * Returns the current dependency chain (all the state stored in the dependencyStack).
 */
 
","{
    enterCount++;
} 
{
    int newCount = --enterCount;
    if (newCount < 0) {
        throw new IllegalStateException(""Called close() too many times"");
    }
    if (newCount == 0) {
        toClear[0] = null;
    }
} 
{
    Dependency<?> previous = this.dependency;
    this.dependency = dependency;
    doPushState(dependency, source);
    return previous;
} 
{
    popState();
    this.dependency = newDependency;
} 
{
    doPushState(key, source);
} 
{
    // N.B. we don't null out the array entries.  It isn't necessary since all the objects in the
    // array (Key, Dependency, or Binding source objects) are all tied to the lifetime of the
    // injector, which is greater than the lifetime of this object.  So removing them from the array
    // doesn't matter.
    dependencyStackSize -= 2;
} 
{
    com.google.common.collect.ImmutableList.Builder<com.google.inject.spi.DependencyAndSource> builder = com.google.common.collect.ImmutableList.builder();
    for (int i = 0; i < dependencyStackSize; i += 2) {
        Object evenEntry = dependencyStack[i];
        Dependency<?> dependency;
        if (evenEntry instanceof com.google.inject.Key) {
            dependency = Dependency.get((com.google.inject.Key<?>) evenEntry);
        } else {
            dependency = (Dependency<?>) evenEntry;
        }
        builder.add(new com.google.inject.spi.DependencyAndSource(dependency, dependencyStack[i + 1]));
    }
    return builder.build();
} 
",,,"/**
 * Keeps track of the type that is currently being requested for injection.
 */
 
/**
 * Keeps track of the hierarchy of types needed during injection.
 *
 * <p>This is a pairwise combination of dependencies and sources, with dependencies or keys on
 * even indices, and sources on odd indices. This structure is to avoid the memory overhead of
 * DependencyAndSource objects, which can add to several tens of megabytes in large applications.
 */
 
/**
 * The number of times {@link #enter()} has been called + 1 for initial construction. This value
 * is decremented when {@link #exit()} is called.
 */
 
/**
 * A single element array to clear when the {@link #enterCount} hits {@code 0}.
 *
 * <p>This is the value stored in the {@code InjectorImpl.localContext} thread local.
 */
 
","Field dependency
Field dependencyStack
Field enterCount
Field toClear
",3,125
WeakKeySet.java,33,87,0.3793103448275862,"
 * Minimal set that doesn't hold strong references to the contained keys.
 *
 * @author dweis@google.com (Daniel Weis)
 ",,,,,"/**
 * This is already locked externally on add and getSources but we need it to handle clean up in
 * the evictionCache's RemovalListener.
 */
 
/**
 * Tracks child injector lifetimes and evicts blacklisted keys/sources after the child injector is
 * garbage collected.
 */
 
","Field lock
Field evictionCache
",3,114
DefaultConstructionProxyFactory.java,32,100,0.32,"
 * Produces construction proxies that invoke the class constructor.
 *
 * @author crazybob@google.com (Bob Lee)
 |if[AOP]|end[AOP]| A {@link ConstructionProxy} that uses FastClass to invoke the constructor. ",,,"/**
 * @param injectionPoint an injection point whose member is a constructor of {@code T}.
 */
 
","{
    this.injectionPoint = injectionPoint;
} 
",,,4,201
AbstractBindingProcessor.java,48,112,0.42857142857142855,"
 * Guarantees that processing of Binding elements happens in a sane way.
 *
 * @author sameb@google.com (Sam Berlin)
 | It's unfortunate that we have to maintain a blacklist of specific| classes, but we can't easily block the whole package because of|
   * Processor for visiting bindings. Each overriden method that wants to actually process the
   * binding should call prepareBinding first.
   ","/**
 * We tolerate duplicate bindings if one exposes the other or if the two bindings are considered
 * duplicates (see {@link Bindings#areDuplicates(BindingImpl, BindingImpl)}.
 *
 * @param original the binding in the parent injector (candidate for an exposing binding)
 * @param binding the binding to check (candidate for the exposed binding)
 */
 
/**
 * Schedule initialization of this binding to occur immediately after all bindings have been
 * initialially processed.
 */
 
/**
 * Schedule initialization for this binding to occur after all other static initialization of
 * bindings.
 */
 
","{
    if (original instanceof ExposedBindingImpl) {
        ExposedBindingImpl exposed = (ExposedBindingImpl) original;
        InjectorImpl exposedFrom = (InjectorImpl) exposed.getPrivateElements().getInjector();
        return (exposedFrom == binding.getInjector());
    } else {
        original = (BindingImpl<?>) state.getExplicitBindingsThisLevel().get(binding.getKey());
        // If no original at this level, the original was on a parent, and we don't
        // allow deduplication between parents & children.
        if (original == null) {
            return false;
        } else {
            return original.equals(binding);
        }
    }
} 
{
    bindingData.addUninitializedBinding(() -> initializeBinding(binding));
} 
{
    bindingData.addDelayedUninitializedBinding(() -> initializeBinding(binding));
} 
",,,,,6,386
CircularDependencyProxy.java,17,3,5.666666666666667," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
SingletonScope.java,146,142,1.028169014084507,"
 * One instance per {@link Injector}. Also see {@code @}{@link Singleton}.
 *
 * <p>Introduction from the author: Implementation of this class seems unreasonably complicated at
 * the first sight. I fully agree with you, that the beast below is very complex and it's hard to
 * reason on how does it work or not. Still I want to assure you that hundreds(?) of hours were
 * thrown into making this code simple, while still maintaining Singleton contract.
 *
 * <p>Anyway, why is it so complex? Singleton scope does not seem to be that unique.
 *
 * <ol>
 *   <li>Guice has never truly expected to be used in multi threading environment with many
 *       Injectors working alongside each other. There is almost no code with Guice that propagates
 *       state between threads. And Singleton scope is The exception.
 *   <li>Guice supports circular dependencies and thus manages proxy objects. There is no interface
 *       that allows user defined Scopes to create proxies, it is expected to be done by Guice.
 *       Singleton scope needs to be able to detect circular dependencies spanning several threads,
 *       therefore Singleton scope needs to be able to create these proxies.
 *   <li>To make things worse, Guice has a very tricky definition for a binding resolution when
 *       Injectors are in in a parent/child relationship. And Scope does not have access to this
 *       information by design, the only real action that Scope can do is to call or not to call a
 *       creator.
 *   <li>There is no readily available code in Guice that can detect a potential deadlock, and no
 *       code for handling dependency cycles spanning several threads. This is significantly harder
 *       as all the dependencies in a thread at runtime can be represented with a list, where in a
 *       multi threaded environment we have more complex dependency trees.
 *   <li>Guice has a pretty strong contract regarding Garbage Collection, which often prevents us
 *       from linking objects directly. So simple domain specific code can not be written and
 *       intermediary id objects need to be managed.
 *   <li>Guice is relatively fast and we should not make things worse. We're trying our best to
 *       optimize synchronization for speed and memory. Happy path should be almost as fast as in a
 *       single threaded solution and should not take much more memory.
 *   <li>Error message generation in Guice was not meant to be used like this and to work around its
 *       APIs we need a lot of code. Additional complexity comes from inherent data races as message
 *       is only generated when failure occurs on proxy object generation. Things get ugly pretty
 *       fast.
 * </ol>
 *
 * @see #scope(Key, Provider)
 * @see CycleDetectingLock
 * @author timofeyb (Timothy Basanov)
 ","/**
 * Helper method to create beautiful and rich error descriptions. Best effort and slow. Tries
 * its best to provide dependency information from injectors currently available in a global
 * internal context.
 *
 * <p>The main thing being done is creating a list of Dependencies involved into lock cycle
 * across all the threads involved. This is a structure we're creating:
 *
 * <pre>
 * { Current Thread, C.class, B.class, Other Thread, B.class, C.class, Current Thread }
 * To be inserted in the beginning by Guice: { A.class, B.class, C.class }
 * </pre>
 *
 * When we're calling Guice to create A and it fails in the deadlock while trying to create C,
 * which is being created by another thread, which waits for B. List would be reversed before
 * printing it to the end user.
 */
 
/**
 * Provides singleton scope with the following properties:
 *
 * <ul>
 *   <li>creates no more than one instance per Key as a creator is used no more than once
 *   <li>result is cached and returned quickly on subsequent calls
 *   <li>exception in a creator is not treated as instance creation and is not cached
 *   <li>creates singletons in parallel whenever possible
 *   <li>waits for dependent singletons to be created even across threads and when dependencies
 *       are shared as long as no circular dependencies are detected
 *   <li>returns circular proxy only when circular dependencies are detected
 *   <li>aside from that, blocking synchronization is only used for proxy creation and
 *       initialization
 * </ul>
 *
 * @see CycleDetectingLockFactory
 */
 
","{
    // this is the main thing that we'll show in an error message,
    // current thread is populate by Guice
    StringBuilder sb = new StringBuilder();
    Formatter fmt = new Formatter(sb);
    fmt.format(""Encountered circular dependency spanning several threads."");
    if (proxyCreationError != null) {
        fmt.format("" %s"", proxyCreationError.getMessage());
    }
    fmt.format(""%n"");
    for (Thread lockedThread : locksCycle.keySet()) {
        List<Key<?>> lockedKeys = locksCycle.get(lockedThread);
        fmt.format(""%s is holding locks the following singletons in the cycle:%n"", lockedThread);
        for (Key<?> lockedKey : lockedKeys) {
            fmt.format(""%s%n"", Errors.convert(lockedKey));
        }
        for (StackTraceElement traceElement : lockedThread.getStackTrace()) {
            fmt.format(""\tat %s%n"", traceElement);
        }
    }
    fmt.close();
    return new Message(Thread.currentThread(), sb.toString());
} 
{
    /**
     * Locking strategy:
     */
    return new Provider<T>() {

        /**
         * The lazily initialized singleton instance. Once set, this will either have type T or will
         * be equal to NULL. Would never be reset to null.
         *
         * <p>Locking strategy: double-checked locking for quick exit when scope is initialized.
         */
        volatile Object instance;

        /**
         * Circular proxies are used when potential deadlocks are detected. Guarded by itself.
         * ConstructionContext is not thread-safe, so each call should be synchronized.
         *
         * <p>Locking strategy: manipulations with proxies list or instance initialization.
         */
        final ConstructionContext<T> constructionContext = new ConstructionContext<>();

        /**
         * For each binding there is a separate lock that we hold during object creation.
         *
         * <p>Locking strategy: singleton instance creation.
         *
         * <ul>
         *   <li>allows to guarantee only one instance per singleton,
         *   <li>special type of a lock, that prevents potential deadlocks,
         *   <li>guards constructionContext for all operations except proxy creation
         * </ul>
         */
        final CycleDetectingLock<Key<?>> creationLock = cycleDetectingLockFactory.create(key);

        /**
         * The singleton provider needs a reference back to the injector, in order to get ahold of
         * InternalContext during instantiation.
         */
        final InjectorImpl /* @Nullable */
        injector;

        {
            // If we are getting called by Scoping
            if (creator instanceof ProviderToInternalFactoryAdapter) {
                injector = ((ProviderToInternalFactoryAdapter) creator).getInjector();
            } else {
                injector = null;
            }
        }

        @SuppressWarnings(""DoubleCheckedLocking"")
        @Override
        public T get() {
            // cache volatile variable for the usual case of already initialized object
            final Object initialInstance = instance;
            if (initialInstance == null) {
                // instance is not initialized yet
                // first, store the current InternalContext in a map, so that if there is a circular
                // dependency error, we can use the InternalContext objects to create a complete
                // error message.
                // Handle injector being null, which can happen when users call Scoping.scope themselves
                final InternalContext context = injector == null ? null : injector.getLocalContext();
                // acquire lock for current binding to initialize an instance
                final ListMultimap<Thread, Key<?>> locksCycle = creationLock.lockOrDetectPotentialLocksCycle();
                if (locksCycle.isEmpty()) {
                    // this thread now owns creation of an instance
                    try {
                        // intentionally reread volatile variable to prevent double initialization
                        if (instance == null) {
                            // creator throwing an exception can cause circular proxies created in
                            // different thread to never be resolved, just a warning
                            T provided = creator.get();
                            Object providedNotNull = provided == null ? NULL : provided;
                            // scope called recursively can initialize instance as a side effect
                            if (instance == null) {
                                // instance is still not initialized, so we can proceed
                                // don't remember proxies created by Guice on circular dependency
                                // detection within the same thread; they are not real instances to cache
                                if (Scopes.isCircularProxy(provided)) {
                                    return provided;
                                }
                                synchronized (constructionContext) {
                                    // guarantee thread-safety for instance and proxies initialization
                                    instance = providedNotNull;
                                    constructionContext.setProxyDelegates(provided);
                                }
                            } else {
                                // safety assert in case instance was initialized
                                Preconditions.checkState(instance == providedNotNull, ""Singleton is called recursively returning different results"");
                            }
                        }
                    } catch (RuntimeException e) {
                        // something went wrong, be sure to clean a construction context
                        // this helps to prevent potential memory leaks in circular proxies list
                        synchronized (constructionContext) {
                            constructionContext.finishConstruction();
                        }
                        throw e;
                    } finally {
                        // always release our creation lock, even on failures
                        creationLock.unlock();
                    }
                } else {
                    if (context == null) {
                        throw new ProvisionException(ImmutableList.of(createCycleDependenciesMessage(locksCycle, null)));
                    }
                    // potential deadlock detected, creation lock is not taken by this thread
                    synchronized (constructionContext) {
                        // guarantee thread-safety for instance and proxies initialization
                        if (instance == null) {
                            // creating a proxy to satisfy circular dependency across several threads
                            Dependency<?> dependency = Preconditions.checkNotNull(context.getDependency(), ""internalContext.getDependency()"");
                            Class<?> rawType = dependency.getKey().getTypeLiteral().getRawType();
                            try {
                                @SuppressWarnings(""unchecked"")
                                T proxy = (T) constructionContext.createProxy(context.getInjectorOptions(), rawType);
                                return proxy;
                            } catch (InternalProvisionException e) {
                                // best effort to create a rich error message
                                Message proxyCreationError = Iterables.getOnlyElement(e.getErrors());
                                Message cycleDependenciesMessage = createCycleDependenciesMessage(locksCycle, proxyCreationError);
                                // adding stack trace generated by us in addition to a standard one
                                throw new ProvisionException(ImmutableList.of(cycleDependenciesMessage, proxyCreationError));
                            }
                        }
                    }
                }
                // at this point we're sure that singleton was initialized,
                // reread volatile variable to catch all corner cases
                // caching volatile variable to minimize number of reads performed
                final Object initializedInstance = instance;
                Preconditions.checkState(initializedInstance != null, ""Internal error: Singleton is not initialized contrary to our expectations"");
                @SuppressWarnings(""unchecked"")
                T initializedTypedInstance = (T) initializedInstance;
                return initializedInstance == NULL ? null : initializedTypedInstance;
            } else {
                // singleton is already initialized and local cache can be used
                @SuppressWarnings(""unchecked"")
                T typedInitialIntance = (T) initialInstance;
                return initialInstance == NULL ? null : typedInitialIntance;
            }
        }

        /**
         * Helper method to create beautiful and rich error descriptions. Best effort and slow. Tries
         * its best to provide dependency information from injectors currently available in a global
         * internal context.
         *
         * <p>The main thing being done is creating a list of Dependencies involved into lock cycle
         * across all the threads involved. This is a structure we're creating:
         *
         * <pre>
         * { Current Thread, C.class, B.class, Other Thread, B.class, C.class, Current Thread }
         * To be inserted in the beginning by Guice: { A.class, B.class, C.class }
         * </pre>
         *
         * When we're calling Guice to create A and it fails in the deadlock while trying to create C,
         * which is being created by another thread, which waits for B. List would be reversed before
         * printing it to the end user.
         */
        private Message createCycleDependenciesMessage(ListMultimap<Thread, Key<?>> locksCycle, /* @Nullable */
        Message proxyCreationError) {
            // this is the main thing that we'll show in an error message,
            // current thread is populate by Guice
            StringBuilder sb = new StringBuilder();
            Formatter fmt = new Formatter(sb);
            fmt.format(""Encountered circular dependency spanning several threads."");
            if (proxyCreationError != null) {
                fmt.format("" %s"", proxyCreationError.getMessage());
            }
            fmt.format(""%n"");
            for (Thread lockedThread : locksCycle.keySet()) {
                List<Key<?>> lockedKeys = locksCycle.get(lockedThread);
                fmt.format(""%s is holding locks the following singletons in the cycle:%n"", lockedThread);
                for (Key<?> lockedKey : lockedKeys) {
                    fmt.format(""%s%n"", Errors.convert(lockedKey));
                }
                for (StackTraceElement traceElement : lockedThread.getStackTrace()) {
                    fmt.format(""\tat %s%n"", traceElement);
                }
            }
            fmt.close();
            return new Message(Thread.currentThread(), sb.toString());
        }

        @Override
        public String toString() {
            return String.format(""%s[%s]"", creator, Scopes.SINGLETON);
        }
    };
} 
",,,"/**
 * A sentinel value representing null.
 */
 
/**
 * The lazily initialized singleton instance. Once set, this will either have type T or will
 * be equal to NULL. Would never be reset to null.
 *
 * <p>Locking strategy: double-checked locking for quick exit when scope is initialized.
 */
 
/**
 * Circular proxies are used when potential deadlocks are detected. Guarded by itself.
 * ConstructionContext is not thread-safe, so each call should be synchronized.
 *
 * <p>Locking strategy: manipulations with proxies list or instance initialization.
 */
 
/**
 * For each binding there is a separate lock that we hold during object creation.
 *
 * <p>Locking strategy: singleton instance creation.
 *
 * <ul>
 *   <li>allows to guarantee only one instance per singleton,
 *   <li>special type of a lock, that prevents potential deadlocks,
 *   <li>guards constructionContext for all operations except proxy creation
 * </ul>
 */
 
/**
 * The singleton provider needs a reference back to the injector, in order to get ahold of
 * InternalContext during instantiation.
 */
 
","Field NULL
Field instance
Field constructionContext
Field creationLock
Field injector
",40,2727
ProviderMethodsModule.java,56,265,0.21132075471698114,"
 * Creates bindings to methods annotated with {@literal @}{@link Provides}. Use the scope and
 * binding annotations on the provider method to configure the binding.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Returns a module which creates bindings for provider methods from the given module.
 */
 
/**
 * Returns a module which creates bindings methods in the module that match the scanner.
 */
 
/**
 * Returns a module which creates bindings for provider methods from the given object. This is
 * useful notably for <a href=""http://code.google.com/p/google-gin/"">GIN</a>
 *
 * <p>This will skip bytecode generation for provider methods, since it is assumed that callers
 * are only interested in Module metadata.
 */
 
/**
 * Returns the annotation that is claimed by the scanner, or null if there is none.
 */
 
/**
 * Returns true if a overrides b, assumes that the signatures match
 */
 
","{
    return forObject(module, false, ProvidesMethodScanner.INSTANCE);
} 
{
    return forObject(module, false, scanner);
} 
{
    return forObject(object, true, ProvidesMethodScanner.INSTANCE);
} 
{
    if (method.isBridge() || method.isSynthetic()) {
        return null;
    }
    Annotation annotation = null;
    for (Class<? extends Annotation> annotationClass : scanner.annotationClasses()) {
        Annotation foundAnnotation = method.getAnnotation(annotationClass);
        if (foundAnnotation != null) {
            if (annotation != null) {
                binder.addError(""More than one annotation claimed by %s on method %s."" + "" Methods can only have one annotation claimed per scanner."", scanner, method);
                return null;
            }
            annotation = foundAnnotation;
        }
    }
    return annotation;
} 
{
    // See JLS section 8.4.8.1
    int modifiers = b.getModifiers();
    if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {
        return true;
    }
    if (Modifier.isPrivate(modifiers)) {
        return false;
    }
    // b must be package-private
    return a.getDeclaringClass().getPackage().equals(b.getDeclaringClass().getPackage());
} 
",,,,,5,250
InternalFactoryToInitializableAdapter.java,21,37,0.5675675675675675,"
 * Adapts {@link ProviderInstanceBinding} providers, ensuring circular proxies fail (or proxy)
 * properly.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,4,145
ProviderInstanceBindingImpl.java,44,135,0.32592592592592595,,,,,,,,1,0
ConstructorInjector.java,32,90,0.35555555555555557,"
 * Creates instances using an injectable constructor. After construction, all injectable fields and
 * methods are injected.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a
 * proxy.
 */
 
/**
 * Provisions a new T.
 */
 
","{
    final ConstructionContext<T> constructionContext = context.getConstructionContext(this);
    // We have a circular reference between constructors. Return a proxy.
    if (constructionContext.isConstructing()) {
        // TODO (crazybob): if we can't proxy this object, can we proxy the other object?
        return constructionContext.createProxy(context.getInjectorOptions(), dependency.getKey().getTypeLiteral().getRawType());
    }
    // If we're re-entering this factory while injecting fields or methods,
    // return the same instance. This prevents infinite loops.
    T t = constructionContext.getCurrentReference();
    if (t != null) {
        if (context.getInjectorOptions().disableCircularProxies) {
            throw InternalProvisionException.circularDependenciesDisabled(dependency.getKey().getTypeLiteral().getRawType());
        } else {
            return t;
        }
    }
    constructionContext.startConstruction();
    try {
        // Optimization: Don't go through the callback stack if we have no listeners.
        if (provisionCallback == null) {
            return provision(context, constructionContext);
        } else {
            return provisionCallback.provision(context, new ProvisionCallback<T>() {

                @Override
                public T call() throws InternalProvisionException {
                    return provision(context, constructionContext);
                }
            });
        }
    } finally {
        constructionContext.finishConstruction();
    }
} 
{
    try {
        T t;
        try {
            Object[] parameters = SingleParameterInjector.getAll(context, parameterInjectors);
            t = constructionProxy.newInstance(parameters);
            constructionContext.setProxyDelegates(t);
        } finally {
            constructionContext.finishConstruction();
        }
        // Store reference. If an injector re-enters this factory, they'll get the same reference.
        constructionContext.setCurrentReference(t);
        MembersInjectorImpl<T> localMembersInjector = membersInjector;
        localMembersInjector.injectMembers(t, context, false);
        localMembersInjector.notifyListeners(t);
        return t;
    } catch (InvocationTargetException userException) {
        Throwable cause = userException.getCause() != null ? userException.getCause() : userException;
        throw InternalProvisionException.errorInjectingConstructor(cause).addSource(constructionProxy.getInjectionPoint());
    } finally {
        constructionContext.removeCurrentReference();
    }
} 
",,,,,4,162
ConstructionContext.java,24,57,0.42105263157894735,"
 * Context of a dependency construction. Used to manage circular references.
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,3,116
UntargettedBindingImpl.java,15,62,0.24193548387096775,,,,,,,,1,0
ModuleAnnotatedMethodScannerProcessor.java,20,12,1.6666666666666667,"
 * Handles {@code Binder.scanModulesForAnnotatedMethods} commands.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,106
BindingBuilder.java,22,153,0.1437908496732026,"
 * Bind a non-constant key.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,3,75
LookupProcessor.java,22,33,0.6666666666666666,"
 * Handles {@code Binder.getProvider} and {@code Binder.getMembersInjector(TypeLiteral)} commands.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,4,185
ConstructorBindingImpl.java,34,236,0.1440677966101695,,"/**
 * @param constructorInjector the constructor to use, or {@code null} to use the default.
 * @param failIfNotLinked true if this ConstructorBindingImpl's InternalFactory should only
 *     succeed if retrieved from a linked binding
 */
 
/**
 * Returns true if the inject annotation is on the constructor.
 */
 
/**
 * True if this binding has been initialized and is ready for use.
 */
 
/**
 * Returns an injection point that can be used to clean up the constructor store.
 */
 
/**
 * Returns a set of dependencies that can be iterated over to clean up stray JIT bindings.
 */
 
","{
    int numErrors = errors.size();
    // constructorBinding guarantees type is consistent
    @SuppressWarnings(""unchecked"")
    Class<? super T> rawType = constructorInjector == null ? key.getTypeLiteral().getRawType() : (Class) constructorInjector.getDeclaringType().getRawType();
    // We can't inject abstract classes.
    if (Modifier.isAbstract(rawType.getModifiers())) {
        errors.missingImplementationWithHint(key, injector);
    }
    // Error: Inner class.
    if (Classes.isInnerClass(rawType)) {
        errors.cannotInjectInnerClass(rawType);
    }
    errors.throwIfNewErrors(numErrors);
    // Find a constructor annotated @Inject
    if (constructorInjector == null) {
        try {
            constructorInjector = InjectionPoint.forConstructorOf(key.getTypeLiteral());
            if (failIfNotExplicit && !hasAtInject((Constructor) constructorInjector.getMember())) {
                errors.atInjectRequired(rawType);
            }
        } catch (ConfigurationException e) {
            throw errors.merge(e.getErrorMessages()).toException();
        }
    }
    // if no scope is specified, look for a scoping annotation on the concrete class
    if (!scoping.isExplicitlyScoped()) {
        Class<?> annotatedType = constructorInjector.getMember().getDeclaringClass();
        Class<? extends Annotation> scopeAnnotation = findScopeAnnotation(errors, annotatedType);
        if (scopeAnnotation != null) {
            scoping = Scoping.makeInjectable(Scoping.forAnnotation(scopeAnnotation), injector, errors.withSource(rawType));
        }
    }
    errors.throwIfNewErrors(numErrors);
    Factory<T> factoryFactory = new Factory<>(failIfNotLinked, key);
    InternalFactory<? extends T> scopedFactory = Scoping.scope(key, injector, factoryFactory, source, scoping);
    return new ConstructorBindingImpl<T>(injector, key, source, scopedFactory, scoping, factoryFactory, constructorInjector);
} 
{
    return cxtor.isAnnotationPresent(Inject.class) || cxtor.isAnnotationPresent(javax.inject.Inject.class);
} 
{
    return factory.constructorInjector != null;
} 
{
    if (factory.constructorInjector != null) {
        return factory.constructorInjector.getConstructionProxy().getInjectionPoint();
    } else {
        return constructorInjectionPoint;
    }
} 
{
    ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder();
    if (factory.constructorInjector == null) {
        builder.add(constructorInjectionPoint);
        // If the below throws, it's OK -- we just ignore those dependencies, because no one
        // could have used them anyway.
        try {
            builder.addAll(InjectionPoint.forInstanceMethodsAndFields(constructorInjectionPoint.getDeclaringType()));
        } catch (ConfigurationException ignored) {
        }
    } else {
        builder.add(getConstructor()).addAll(getInjectableMembers());
    }
    return Dependency.forInjectionPoints(builder.build());
} 
",,,,,1,0
UntargettedBindingProcessor.java,25,37,0.6756756756756757,"
 * Processes just UntargettedBindings.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,78
RealMultibinder.java,74,456,0.16228070175438597,"
 * The actual multibinder plays several roles:
 *
 * <p>As a Multibinder, it acts as a factory for LinkedBindingBuilders for each of the set's
 * elements. Each binding is given an annotation that identifies it as a part of this set.
 *
 * <p>As a Module, it installs the binding to the set itself. As a module, this implements equals()
 * and hashcode() in order to trick Guice into executing its configure() method only once. That
 * makes it so that multiple multibinders can be created for the same target collection, but only
 * one is bound. Since the list of bindings is retrieved from the injector itself (and not the
 * multibinder), each multibinder has access to all contributions from all multibinders.
 *
 * <p>As a Provider, this constructs the set instances.
 *
 * <p>We use a subclass to hide 'implements Module, Provider' from the public API.
 | These methods are used by RealMapBinder|
   * We install the permit duplicates configuration as its own binding, all by itself. This way, if
   * only one of a multibinder's users remember to call permitDuplicates(), they're still permitted.
   *
   * <p>This is like setting a global variable in the injector so that each instance of the
   * multibinder will have the same value for permitDuplicates, even if it is only set on one of
   * them.
   ","/**
 * Implementation of newSetBinder.
 */
 
/**
 * Adds a new entry to the set and returns the key for it.
 */
 
","{
    binder = binder.skipSources(RealMultibinder.class);
    RealMultibinder<T> result = new RealMultibinder<>(binder, key);
    binder.install(result);
    return result;
} 
{
    checkConfiguration(!bindingSelection.isInitialized(), ""Multibinder was already initialized"");
    return Key.get(bindingSelection.getElementTypeLiteral(), new RealElement(bindingSelection.getSetName(), MULTIBINDER, """"));
} 
",,,"/**
 * whether duplicates are allowed. Possibly configured by a different instance
 */
 
","Field permitDuplicates
",21,1272
ExposedBindingImpl.java,17,47,0.3617021276595745,,,,,,,,1,0
FailableCache.java,21,51,0.4117647058823529,"
 * Lazily creates (and caches) values for keys. If creating the value fails (with errors), an
 * exception is thrown on retrieval.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,4,176
InstanceBindingImpl.java,44,135,0.32592592592592595,,,,,,,,1,0
DelayedInitialize.java,22,4,5.5,"
 * Something that needs some delayed initialization, typically a binding or internal factory that
 * needs to be created & put into the bindings map & then initialized later.
 *
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Initializes this binding, throwing any errors if necessary.
 */
 
","initialize 
",,,,,4,212
SingleParameterInjector.java,19,36,0.5277777777777778," Resolves a single parameter, to be used in a constructor or method invocation. ","/**
 * Returns an array of parameter values.
 */
 
","{
    if (parameterInjectors == null) {
        return NO_ARGUMENTS;
    }
    int size = parameterInjectors.length;
    Object[] parameters = new Object[size];
    // optimization: use manual for/each to save allocating an iterator here
    for (int i = 0; i < size; i++) {
        parameters[i] = parameterInjectors[i].inject(context);
    }
    return parameters;
} 
",,,,,1,80
Lookups.java,22,33,0.6666666666666666,"
 * Accessors for providers and members injectors. The returned values will not be functional until
 * the injector has been created.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,4,178
CreationListener.java,17,4,4.25," Something that is notified upon creation. ","/**
 * Notifies that creation should happen.
 */
 
","notify 
",,,,,1,43
LinkedProviderBindingImpl.java,15,112,0.13392857142857142,,,,,,,,1,0
InternalFlags.java,49,74,0.6621621621621622,"
 * Contains flags for Guice.
 |
   * The options for Guice stack trace collection.
   |
   * The options for Guice custom class loading.
   ","/**
 * Gets the system option indicated by the specified key; runs as a privileged action.
 *
 * @param name of the system option
 * @param defaultValue if the option is not set
 *
 * @return value of the option, defaultValue if not set
 */
 
/**
 * Gets the system option indicated by the specified key; runs as a privileged action.
 *
 * @param name of the system option
 * @param defaultValue if the option is not set
 * @param secureValue if the security manager disallows access to the option
 *
 * @return value of the option, defaultValue if not set, secureValue if no access
 */
 
","{
    return getSystemOption(name, defaultValue, defaultValue);
} 
{
    Class<T> enumType = defaultValue.getDeclaringClass();
    String value = null;
    try {
        value = AccessController.doPrivileged(new PrivilegedAction<String>() {

            @Override
            public String run() {
                return System.getProperty(name);
            }
        });
        return (value != null && value.length() > 0) ? Enum.valueOf(enumType, value) : defaultValue;
    } catch (SecurityException e) {
        return secureValue;
    } catch (IllegalArgumentException e) {
        logger.warning(value + "" is not a valid flag value for "" + name + "". "" + "" Values must be one of "" + Arrays.asList(enumType.getEnumConstants()));
        return defaultValue;
    }
} 
",,,,,5,132
BindingImpl.java,34,236,0.1440677966101695," @author crazybob@google.com (Bob Lee) ","/**
 * Is this a constant binding? This returns true for constant bindings as well as toInstance()
 * bindings.
 */
 
","{
    return this instanceof InstanceBinding;
} 
",,,,,1,39
InternalProviderInstanceBindingImpl.java,44,135,0.32592592592592595,"
 * A {@link ProviderInstanceBindingImpl} for implementing 'native' guice extensions.
 *
 * <p>Beyond the normal binding contract that is mostly handled by our baseclass, this also
 * implements {@link DelayedInitialize} in order to initialize factory state.
 |
   * A base factory implementation. Any Factories that delegate to other bindings should use the
   * {@code CyclicFactory} subclass, but trivial factories can use this one.
   |
   * An base factory implementation that can be extended to provide a specialized implementation of
   * a {@link ProviderWithExtensionVisitor} and also implements {@link InternalFactory}
   ","/**
 * The binding source.
 *
 * <p>May be useful for augmenting runtime error messages.
 *
 * <p>Note: this will return {#code null} until {@link #initialize(InjectorImpl, Errors)} has
 * already been called.
 */
 
/**
 * A callback that allows for implementations to fetch dependencies on other bindings.
 *
 * <p>Will be called exactly once, prior to any call to {@link #doProvision}.
 */
 
/**
 * Creates an object to be injected.
 *
 * @throws com.google.inject.internal.InternalProvisionException if a value cannot be provided
 * @return instance to be injected
 */
 
","{
    return source;
} 
initialize 
doProvision 
",,,,,10,613
InternalInjectorCreator.java,62,240,0.25833333333333336,"
 * Builds a tree of injectors. This is a primary injector, plus child injectors needed for each
 * {@code Binder.newPrivateBinder() private environment}. The primary injector is not necessarily a
 * top-level injector.
 *
 * <p>Injector construction happens in two phases.
 *
 * <ol>
 *   <li>Static building. In this phase, we interpret commands, create bindings, and inspect
 *       dependencies. During this phase, we hold a lock to ensure consistency with parent
 *       injectors. No user code is executed in this phase.
 *   <li>Dynamic injection. In this phase, we call user code. We inject members that requested
 *       injection. This may require user's objects be created and their providers be called. And we
 *       create eager singletons. In this phase, user code may have started other threads. This
 *       phase is not executed for injectors created using {@link Stage#TOOL the tool stage}
 * </ol>
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 | {@link Injector} exposed to users in {@link Stage#TOOL}. ","/**
 * Sets the parent of the injector to-be-constructed. As a side effect, this sets this injector's
 * stage to the stage of {@code parent} and sets {@link #requireExplicitBindings()} if the parent
 * injector also required them.
 */
 
/**
 * Initialize and validate everything.
 */
 
/**
 * Returns the injector being constructed. This is not necessarily the root injector.
 */
 
/**
 * Inject everything that can be injected. This method is intentionally not synchronized. If we
 * locked while injecting members (ie. running user code), things would deadlock should the user
 * code build a just-in-time binding from another thread.
 */
 
/**
 * Loads eager singletons, or all singletons if we're in Stage.PRODUCTION. Bindings discovered
 * while we're binding these singletons are not be eager.
 */
 
","{
    shellBuilder.parent(parent);
    return this;
} 
{
    bindingData.initializeBindings();
    stopwatch.resetAndLog(""Binding initialization"");
    for (InjectorShell shell : shells) {
        shell.getInjector().index();
    }
    stopwatch.resetAndLog(""Binding indexing"");
    injectionRequestProcessor.process(shells);
    stopwatch.resetAndLog(""Collecting injection requests"");
    bindingData.runCreationListeners(errors);
    stopwatch.resetAndLog(""Binding validation"");
    injectionRequestProcessor.validate();
    stopwatch.resetAndLog(""Static validation"");
    initializer.validateOustandingInjections(errors);
    stopwatch.resetAndLog(""Instance member validation"");
    new LookupProcessor(errors).process(shells);
    for (InjectorShell shell : shells) {
        ((DeferredLookups) shell.getInjector().lookups).initialize(errors);
    }
    stopwatch.resetAndLog(""Provider verification"");
    // This needs to come late since some user bindings rely on requireBinding calls to create
    // jit bindings during the LookupProcessor.
    bindingData.initializeDelayedBindings();
    stopwatch.resetAndLog(""Delayed Binding initialization"");
    for (InjectorShell shell : shells) {
        if (!shell.getElements().isEmpty()) {
            throw new AssertionError(""Failed to execute "" + shell.getElements());
        }
    }
    errors.throwCreationExceptionIfErrorsExist();
} 
{
    return shells.get(0).getInjector();
} 
{
    injectionRequestProcessor.injectMembers();
    stopwatch.resetAndLog(""Static member injection"");
    initializer.injectAll(errors);
    stopwatch.resetAndLog(""Instance injection"");
    errors.throwCreationExceptionIfErrorsExist();
    if (shellBuilder.getStage() != Stage.TOOL) {
        for (InjectorShell shell : shells) {
            loadEagerSingletons(shell.getInjector(), shellBuilder.getStage(), errors);
        }
        stopwatch.resetAndLog(""Preloading singletons"");
    }
    errors.throwCreationExceptionIfErrorsExist();
} 
{
    List<BindingImpl<?>> candidateBindings = new ArrayList<>();
    // casting Collection<Binding> to Collection<BindingImpl> is safe
    @SuppressWarnings(""unchecked"")
    Collection<BindingImpl<?>> bindingsAtThisLevel = (Collection) injector.state.getExplicitBindingsThisLevel().values();
    candidateBindings.addAll(bindingsAtThisLevel);
    synchronized (injector.state.lock()) {
        // jit bindings must be accessed while holding the lock.
        candidateBindings.addAll(injector.jitBindings.values());
    }
    InternalContext context = injector.enterContext();
    try {
        for (BindingImpl<?> binding : candidateBindings) {
            if (isEagerSingleton(injector, binding, stage)) {
                Dependency<?> dependency = Dependency.get(binding.getKey());
                Dependency previous = context.pushDependency(dependency, binding.getSource());
                try {
                    binding.getInternalFactory().get(context, dependency, false);
                } catch (InternalProvisionException e) {
                    errors.withSource(dependency).merge(e);
                } finally {
                    context.popStateAndSetDependency(previous);
                }
            }
        }
    } finally {
        context.close();
    }
} 
",,,,,19,1039
ProvidedByInternalFactory.java,20,67,0.29850746268656714,"
 * An {@link InternalFactory} for {@literal @}{@link ProvidedBy} bindings.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,114
MoreTypes.java,80,393,0.2035623409669211,"
 * Static methods for working with types that we aren't publishing in the public {@code Types} API.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 |
   * The WildcardType interface supports multiple upper bounds and multiple lower bounds. We only
   * support what the Java 6 language needs - at most one bound. If a lower bound is set, the upper
   * bound must be Object.class.
   | A type formed from other types, such as arrays, parameterized types or wildcard types ","/**
 * Returns a key that doesn't hold any references to parent classes. This is necessary for
 * anonymous keys, so ensure we don't hold a ref to the containing module (or class) forever.
 */
 
/**
 * Returns an type that's appropriate for use in a key.
 *
 * <p>If the raw type of {@code typeLiteral} is a {@code javax.inject.Provider}, this returns a
 * {@code com.google.inject.Provider} with the same type parameters.
 *
 * <p>If the type is a primitive, the corresponding wrapper type will be returned.
 *
 * @throws ConfigurationException if {@code type} contains a type variable
 */
 
/**
 * Returns true if {@code type} is free from type variables.
 */
 
/**
 * Returns a type that is functionally equal but not necessarily equal according to {@link
 * Object#equals(Object) Object.equals()}. The returned type is {@link Serializable}.
 */
 
/**
 * Returns true if {@code a} and {@code b} are equal.
 */
 
/**
 * Returns the generic supertype for {@code type}. For example, given a class {@code IntegerSet},
 * the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the result when
 * the supertype is {@code Collection.class} is {@code Collection<Integer>}.
 */
 
/**
 * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
 * a class.
 */
 
/**
 * Returns true if there are no type variables in this type.
 */
 
","{
    // If we know this isn't a subclass, return as-is.
    // Otherwise, recreate the key to avoid the subclass
    if (key.getClass() == Key.class) {
        return key;
    } else {
        return key.ofType(key.getTypeLiteral());
    }
} 
{
    Type type = typeLiteral.getType();
    if (!isFullySpecified(type)) {
        Errors errors = new Errors().keyNotFullySpecified(typeLiteral);
        throw new ConfigurationException(errors.getMessages());
    }
    if (typeLiteral.getRawType() == javax.inject.Provider.class) {
        ParameterizedType parameterizedType = (ParameterizedType) type;
        // the following casts are generally unsafe, but com.google.inject.Provider extends
        // javax.inject.Provider and is covariant
        @SuppressWarnings(""unchecked"")
        TypeLiteral<T> guiceProviderType = (TypeLiteral<T>) TypeLiteral.get(Types.providerOf(parameterizedType.getActualTypeArguments()[0]));
        return guiceProviderType;
    }
    @SuppressWarnings(""unchecked"")
    TypeLiteral<T> wrappedPrimitives = (TypeLiteral<T>) PRIMITIVE_TO_WRAPPER.get(typeLiteral);
    if (wrappedPrimitives != null) {
        return wrappedPrimitives;
    }
    // If we know this isn't a subclass, return as-is.
    if (typeLiteral.getClass() == TypeLiteral.class) {
        return typeLiteral;
    }
    // recreate the TypeLiteral to avoid anonymous TypeLiterals from holding refs to their
    // surrounding classes.
    @SuppressWarnings(""unchecked"")
    TypeLiteral<T> recreated = (TypeLiteral<T>) TypeLiteral.get(typeLiteral.getType());
    return recreated;
} 
{
    if (type instanceof Class) {
        return true;
    } else if (type instanceof CompositeType) {
        return ((CompositeType) type).isFullySpecified();
    } else if (type instanceof TypeVariable) {
        return false;
    } else {
        return ((CompositeType) canonicalize(type)).isFullySpecified();
    }
} 
{
    if (type instanceof Class) {
        Class<?> c = (Class<?>) type;
        return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;
    } else if (type instanceof CompositeType) {
        return type;
    } else if (type instanceof ParameterizedType) {
        ParameterizedType p = (ParameterizedType) type;
        return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments());
    } else if (type instanceof GenericArrayType) {
        GenericArrayType g = (GenericArrayType) type;
        return new GenericArrayTypeImpl(g.getGenericComponentType());
    } else if (type instanceof WildcardType) {
        WildcardType w = (WildcardType) type;
        return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());
    } else {
        // type is either serializable as-is or unsupported
        return type;
    }
} 
{
    if (a == b) {
        // also handles (a == null && b == null)
        return true;
    } else if (a instanceof Class) {
        // Class already specifies equals().
        return a.equals(b);
    } else if (a instanceof ParameterizedType) {
        if (!(b instanceof ParameterizedType)) {
            return false;
        }
        // TODO: save a .clone() call
        ParameterizedType pa = (ParameterizedType) a;
        ParameterizedType pb = (ParameterizedType) b;
        return Objects.equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());
    } else if (a instanceof GenericArrayType) {
        if (!(b instanceof GenericArrayType)) {
            return false;
        }
        GenericArrayType ga = (GenericArrayType) a;
        GenericArrayType gb = (GenericArrayType) b;
        return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
    } else if (a instanceof WildcardType) {
        if (!(b instanceof WildcardType)) {
            return false;
        }
        WildcardType wa = (WildcardType) a;
        WildcardType wb = (WildcardType) b;
        return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
    } else if (a instanceof TypeVariable) {
        if (!(b instanceof TypeVariable)) {
            return false;
        }
        TypeVariable<?> va = (TypeVariable) a;
        TypeVariable<?> vb = (TypeVariable) b;
        return va.getGenericDeclaration().equals(vb.getGenericDeclaration()) && va.getName().equals(vb.getName());
    } else {
        // This isn't a type we support. Could be a generic array type, wildcard type, etc.
        return false;
    }
} 
{
    if (toResolve == rawType) {
        return type;
    }
    // we skip searching through interfaces if unknown is an interface
    if (toResolve.isInterface()) {
        Class[] interfaces = rawType.getInterfaces();
        for (int i = 0, length = interfaces.length; i < length; i++) {
            if (interfaces[i] == toResolve) {
                return rawType.getGenericInterfaces()[i];
            } else if (toResolve.isAssignableFrom(interfaces[i])) {
                return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
            }
        }
    }
    // check our supertypes
    if (!rawType.isInterface()) {
        while (rawType != Object.class) {
            Class<?> rawSupertype = rawType.getSuperclass();
            if (rawSupertype == toResolve) {
                return rawType.getGenericSuperclass();
            } else if (toResolve.isAssignableFrom(rawSupertype)) {
                return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
            }
            rawType = rawSupertype;
        }
    }
    // we can't resolve this further
    return toResolve;
} 
{
    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;
} 
isFullySpecified 
",,,,,8,464
ScopeBindingProcessor.java,23,31,0.7419354838709677,"
 * Handles {@code Binder.bindScope} commands.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,4,132
Initializable.java,21,4,5.25,"
 * Holds a reference that requires initialization to be performed before it can be used.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Ensures the reference is initialized, then returns it.
 */
 
","get 
",,,,,3,136
ErrorHandler.java,22,6,3.6666666666666665,"
 * Handles errors in the Injector.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Handles an error.
 */
 
/**
 * Handles a user-reported error.
 */
 
","handle 
handle 
",,,,,3,74
Messages.java,70,282,0.24822695035460993," Utility methods for {@link Message} objects ","/**
 * Prepends the list of sources to the given {@link Message}
 */
 
/**
 * Calls {@link String#format} after converting the arguments using some standard guice formatting
 * for {@link Key}, {@link Class} and {@link Member} objects.
 */
 
/**
 * Returns the formatted message for an exception with the specified messages.
 */
 
/**
 * Creates a new Message without a cause.
 *
 * @param messageFormat Format string
 * @param arguments format string arguments
 */
 
/**
 * Creates a new Message with the given cause.
 *
 * @param cause The exception that caused the error
 * @param messageFormat Format string
 * @param arguments format string arguments
 */
 
/**
 * Creates a new Message with the given cause and a binding source stack.
 *
 * @param cause The exception that caused the error
 * @param sources The binding sources for the source stack
 * @param messageFormat Format string
 * @param arguments format string arguments
 */
 
/**
 * Formats an object in a user friendly way.
 */
 
/**
 * Maps {@code 1} to the string {@code ""1st""} ditto for all non-negative numbers
 *
 * @see <a href=""https://en.wikipedia.org/wiki/English_numerals#Ordinal_numbers"">
 *     https://en.wikipedia.org/wiki/English_numerals#Ordinal_numbers</a>
 */
 
/**
 * Returns the cause throwable if there is exactly one cause in {@code messages}. If there are
 * zero or multiple messages with causes, null is returned.
 */
 
","{
    List<Object> messageSources = message.getSources();
    // It is possible that the end of getSources() and the beginning of message.getSources() are
    // equivalent, in this case we should drop the repeated source when joining the lists.  The
    // most likely scenario where this would happen is when a scoped binding throws an exception,
    // due to the fact that InternalFactoryToProviderAdapter applies the binding source when
    // merging errors.
    if (!sources.isEmpty() && !messageSources.isEmpty() && Objects.equal(messageSources.get(0), sources.get(sources.size() - 1))) {
        messageSources = messageSources.subList(1, messageSources.size());
    }
    return new Message(ImmutableList.builder().addAll(sources).addAll(messageSources).build(), message.getMessage(), message.getCause());
} 
{
    for (int i = 0; i < arguments.length; i++) {
        arguments[i] = convert(arguments[i]);
    }
    return String.format(messageFormat, arguments);
} 
{
    Formatter fmt = new Formatter().format(heading).format("":%n%n"");
    int index = 1;
    boolean displayCauses = getOnlyCause(errorMessages) == null;
    Map<Equivalence.Wrapper<Throwable>, Integer> causes = Maps.newHashMap();
    for (Message errorMessage : errorMessages) {
        int thisIdx = index++;
        fmt.format(""%s) %s%n"", thisIdx, errorMessage.getMessage());
        List<Object> dependencies = errorMessage.getSources();
        for (int i = dependencies.size() - 1; i >= 0; i--) {
            Object source = dependencies.get(i);
            formatSource(fmt, source);
        }
        Throwable cause = errorMessage.getCause();
        if (displayCauses && cause != null) {
            Equivalence.Wrapper<Throwable> causeEquivalence = ThrowableEquivalence.INSTANCE.wrap(cause);
            if (!causes.containsKey(causeEquivalence)) {
                causes.put(causeEquivalence, thisIdx);
                fmt.format(""Caused by: %s"", Throwables.getStackTraceAsString(cause));
            } else {
                int causeIdx = causes.get(causeEquivalence);
                fmt.format(""Caused by: %s (same stack trace as error #%s)"", cause.getClass().getName(), causeIdx);
            }
        }
        fmt.format(""%n"");
    }
    if (errorMessages.size() == 1) {
        fmt.format(""1 error"");
    } else {
        fmt.format(""%s errors"", errorMessages.size());
    }
    return fmt.toString();
} 
{
    return create(null, messageFormat, arguments);
} 
{
    return create(cause, ImmutableList.of(), messageFormat, arguments);
} 
{
    String message = format(messageFormat, arguments);
    return new Message(sources, message, cause);
} 
{
    ElementSource source = null;
    if (o instanceof ElementSource) {
        source = (ElementSource) o;
        o = source.getDeclaringSource();
    }
    return convert(o, source);
} 
{
    // negative ordinals don't make sense, we allow zero though because we are programmers
    checkArgument(ordinal >= 0);
    if ((ordinal / 10) % 10 == 1) {
        // all the 'teens' are weird
        return ""th"";
    } else {
        // could use a lookup table? any better?
        switch(ordinal % 10) {
            case 1:
                return ""st"";
            case 2:
                return ""nd"";
            case 3:
                return ""rd"";
            default:
                return ""th"";
        }
    }
} 
{
    Throwable onlyCause = null;
    for (Message message : messages) {
        Throwable messageCause = message.getCause();
        if (messageCause == null) {
            continue;
        }
        if (onlyCause != null && !ThrowableEquivalence.INSTANCE.equivalent(onlyCause, messageCause)) {
            return null;
        }
        onlyCause = messageCause;
    }
    return onlyCause;
} 
",,,,,1,45
InjectionRequestProcessor.java,35,98,0.35714285714285715,"
 * Handles {@code Binder.requestInjection} and {@code Binder.requestStaticInjection} commands.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 * @author mikeward@google.com (Mike Ward)
 | A requested static injection. ",,,,,,,6,254
ConstantFactory.java,16,18,0.8888888888888888," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
EncounterImpl.java,21,103,0.20388349514563106," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
SingleMemberInjector.java,16,6,2.6666666666666665," Injects a field or method of a given object. ",,,,,,,1,46
InjectorOptionsProcessor.java,20,57,0.3508771929824561,"
 * A processor to gather injector options.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,82
MethodAspect.java,27,35,0.7714285714285715,"
 * Ties a matcher to a method interceptor.
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,"/**
 * @param classMatcher matches classes the interceptor should apply to. For example: {@code
 *     only(Runnable.class)}.
 * @param methodMatcher matches methods the interceptor should apply to. For example: {@code
 *     annotatedWith(Transactional.class)}.
 * @param interceptors to apply
 */
 
","{
    this.classMatcher = checkNotNull(classMatcher, ""class matcher"");
    this.methodMatcher = checkNotNull(methodMatcher, ""method matcher"");
    this.interceptors = checkNotNull(interceptors, ""interceptors"");
} 
",,,3,82
ExposureBuilder.java,16,43,0.37209302325581395," For private binder's expose() method. ",,,,,,,1,39
DelegatingInvocationHandler.java,19,37,0.5135135135135135,,,,,,,,1,0
ListenerBindingProcessor.java,20,18,1.1111111111111112,"
 * Handles {@code Binder#bindListener} commands.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,3,96
SingleMethodInjector.java,19,62,0.3064516129032258," Invokes an injectable method. ",,,,,,,1,31
SingleFieldInjector.java,17,37,0.4594594594594595," Sets an injectable field. ",,,,,,,1,27
ConstructorInjectorStore.java,35,49,0.7142857142857143,"
 * Constructor injectors by type.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Returns a new complete constructor injector with injection listeners registered.
 */
 
/**
 * Purges an injection point from the cache. Use this only if the cache is not actually valid and
 * needs to be purged. (See issue 319 and
 * ImplicitBindingTest#testCircularJitBindingsLeaveNoResidue and
 * #testInstancesRequestingProvidersForThemselvesWithChildInjectors for examples of when this is
 * necessary.)
 *
 * <p>Returns true if the injector for that point was stored in the cache, false otherwise.
 */
 
","{
    return cache.get(constructorInjector, errors);
} 
{
    return cache.remove(ip);
} 
",,,,,3,81
Initializables.java,17,15,1.1333333333333333," @author jessewilson@google.com (Jesse Wilson) ","/**
 * Returns an initializable for an instance that requires no initialization.
 */
 
","{
    return new Initializable<T>() {

        @Override
        public T get() {
            return instance;
        }

        @Override
        public String toString() {
            return String.valueOf(instance);
        }
    };
} 
",,,,,1,47
PrivateElementProcessor.java,20,20,1.0,"
 * Handles {@code Binder.newPrivateBinder()} elements.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,3,102
Errors.java,92,482,0.1908713692946058,"
 * A collection of error messages. If this type is passed as a method parameter, the method is
 * considered to have executed successfully only if new errors were not added to this collection.
 *
 * <p>Errors can be chained to provide additional context. To add context, call {@link #withSource}
 * to create a new Errors instance that contains additional context. All messages added to the
 * returned instance will contain full context.
 *
 * <p>To avoid messages with redundant context, {@link #withSource} should be added sparingly. A
 * good rule of thumb is to assume a method's caller has already specified enough context to
 * identify that method. When calling a method that's defined in a different context, call that
 * method with an errors object that includes its context.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Throws a ConfigurationException with an NullPointerExceptions as the cause if the given
 * reference is {@code null}.
 */
 
/**
 * Throws a ConfigurationException with a formatted {@link Message} if this condition is {@code
 * false}.
 */
 
/**
 * Returns an instance that uses {@code source} as a reference point for newly added errors.
 */
 
/**
 * We use a fairly generic error message here. The motivation is to share the same message for
 * both bind time errors:
 *
 * <pre><code>Guice.createInjector(new AbstractModule() {
 *   public void configure() {
 *     bind(Runnable.class);
 *   }
 * }</code></pre>
 *
 * ...and at provide-time errors:
 *
 * <pre><code>Guice.createInjector().getInstance(Runnable.class);</code></pre>
 *
 * Otherwise we need to know who's calling when resolving a just-in-time binding, which makes
 * things unnecessarily complex.
 */
 
/**
 * Within guice's core, allow for better missing binding messages
 */
 
","{
    if (reference != null) {
        return reference;
    }
    NullPointerException npe = new NullPointerException(name);
    throw new ConfigurationException(ImmutableSet.of(new Message(npe.toString(), npe)));
} 
{
    if (condition) {
        return;
    }
    throw new ConfigurationException(ImmutableSet.of(new Message(Errors.format(format, args))));
} 
{
    return source == this.source || source == SourceProvider.UNKNOWN_SOURCE ? this : new Errors(this, source);
} 
{
    return addMessage(""No implementation for %s was bound."", key);
} 
{
    StringBuilder sb = new StringBuilder();
    sb.append(format(""No implementation for %s was bound."", key));
    // Keys which have similar strings as the desired key
    List<String> possibleMatches = new ArrayList<>();
    // Check for other keys that may have the same type,
    // but not the same annotation
    TypeLiteral<T> type = key.getTypeLiteral();
    List<Binding<T>> sameTypes = injector.findBindingsByType(type);
    if (!sameTypes.isEmpty()) {
        sb.append(format(""%n  Did you mean?""));
        int howMany = Math.min(sameTypes.size(), MAX_MATCHING_TYPES_REPORTED);
        for (int i = 0; i < howMany; ++i) {
            // TODO: Look into a better way to prioritize suggestions. For example, possbily
            // use levenshtein distance of the given annotation vs actual annotation.
            sb.append(format(""%n    * %s"", sameTypes.get(i).getKey()));
        }
        int remaining = sameTypes.size() - MAX_MATCHING_TYPES_REPORTED;
        if (remaining > 0) {
            String plural = (remaining == 1) ? """" : ""s"";
            sb.append(format(""%n    %d more binding%s with other annotations."", remaining, plural));
        }
    } else {
        // For now, do a simple substring search for possibilities. This can help spot
        // issues when there are generics being used (such as a wrapper class) and the
        // user has forgotten they need to bind based on the wrapper, not the underlying
        // class. In the future, consider doing a strict in-depth type search.
        // TODO: Look into a better way to prioritize suggestions. For example, possbily
        // use levenshtein distance of the type literal strings.
        String want = type.toString();
        Map<Key<?>, Binding<?>> bindingMap = injector.getAllBindings();
        for (Key<?> bindingKey : bindingMap.keySet()) {
            String have = bindingKey.getTypeLiteral().toString();
            if (have.contains(want) || want.contains(have)) {
                Formatter fmt = new Formatter();
                Messages.formatSource(fmt, bindingMap.get(bindingKey).getSource());
                String match = String.format(""%s bound%s"", convert(bindingKey), fmt.toString());
                possibleMatches.add(match);
                // TODO: Consider a check that if there are more than some number of results,
                // don't suggest any.
                if (possibleMatches.size() > MAX_RELATED_TYPES_REPORTED) {
                    // Early exit if we have found more than we need.
                    break;
                }
            }
        }
        if ((possibleMatches.size() > 0) && (possibleMatches.size() <= MAX_RELATED_TYPES_REPORTED)) {
            sb.append(format(""%n  Did you mean?""));
            for (String possibleMatch : possibleMatches) {
                sb.append(format(""%n    %s"", possibleMatch));
            }
        }
    }
    // If where are no possibilities to suggest, then handle the case of missing
    // annotations on simple types. This is usually a bad idea.
    if (sameTypes.isEmpty() && possibleMatches.isEmpty() && key.getAnnotationType() == null && COMMON_AMBIGUOUS_TYPES.contains(key.getTypeLiteral().getRawType())) {
        // We don't recommend using such simple types without annotations.
        sb.append(format(""%nThe key seems very generic, did you forget an annotation?""));
    }
    return addMessage(sb.toString());
} 
",,,"/**
 * When a binding is not found, show at most this many bindings with the same type
 */
 
/**
 * When a binding is not found, show at most this many bindings that have some similarities
 */
 
/**
 * If the key is unknown and it is one of these types, it generally means there is a missing
 * annotation.
 */
 
/**
 * The root errors object. Used to access the list of error messages.
 */
 
/**
 * The parent errors object. Used to obtain the chain of source objects.
 */
 
/**
 * The leaf source for errors added here.
 */
 
","Field MAX_MATCHING_TYPES_REPORTED
Field MAX_RELATED_TYPES_REPORTED
Field COMMON_AMBIGUOUS_TYPES
Field root
Field parent
Field source
",13,814
BoundProviderFactory.java,16,60,0.26666666666666666," Delegates to a custom factory which is also bound in the injector. ",,,,,,,1,68
Scoping.java,50,220,0.22727272727272727,"
 * References a scope, either directly (as a scope instance), or indirectly (as a scope annotation).
 * The scope's eager or laziness is also exposed.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Returns true if this scope was explicitly applied. If no scope was explicitly applied then the
 * scoping annotation will be used.
 */
 
/**
 * Returns true if this is the default scope. In this case a new instance will be provided for
 * each injection.
 */
 
/**
 * Returns true if this scope is a singleton that should be loaded eagerly in {@code stage}.
 */
 
/**
 * Returns the scope instance, or {@code null} if that isn't known for this instance.
 */
 
/**
 * Returns the scope annotation, or {@code null} if that isn't known for this instance.
 */
 
/**
 * Scopes an internal factory.
 */
 
/**
 * Replaces annotation scopes with instance scopes using the Injector's annotation-to-instance
 * map. If the scope annotation has no corresponding instance, an error will be added and unscoped
 * will be retuned.
 */
 
","{
    return this != UNSCOPED;
} 
{
    return getScopeInstance() == Scopes.NO_SCOPE;
} 
{
    if (this == EAGER_SINGLETON) {
        return true;
    }
    if (stage == Stage.PRODUCTION) {
        return this == SINGLETON_ANNOTATION || this == SINGLETON_INSTANCE;
    }
    return false;
} 
{
    return null;
} 
{
    return null;
} 
{
    if (scoping.isNoScope()) {
        return creator;
    }
    Scope scope = scoping.getScopeInstance();
    // NOTE: SingletonScope relies on the fact that we are passing a
    // ProviderToInternalFactoryAdapter here.  If you change the type make sure to update
    // SingletonScope as well.
    Provider<T> scoped = scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator));
    return new InternalFactoryToProviderAdapter<T>(scoped, source);
} 
{
    Class<? extends Annotation> scopeAnnotation = scoping.getScopeAnnotation();
    if (scopeAnnotation == null) {
        return scoping;
    }
    ScopeBinding scope = injector.state.getScopeBinding(scopeAnnotation);
    if (scope != null) {
        return forInstance(scope.getScope());
    }
    errors.scopeNotFound(scopeAnnotation);
    return UNSCOPED;
} 
",,,"/**
 * No scoping annotation has been applied. Note that this is different from {@code
 * in(Scopes.NO_SCOPE)}, where the 'NO_SCOPE' has been explicitly applied.
 */
 
/**
 * No scoping annotation has been applied explicitly. Note that this is is the same as {@code
 * in(Scopes.NO_SCOPE)}.
 */
 
","Field UNSCOPED
Field EXPLICITLY_UNSCOPED
",4,196
ProviderMethod.java,55,203,0.270935960591133,"
 * A provider that invokes a method and returns its result.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 |if[AOP]|end[AOP]|
   * A {@link ProviderMethod} implementation that uses {@link net.sf.cglib.reflect.FastClass#invoke}
   * to invoke the provider method.
   |if[AOP]|end[AOP]|
   * A {@link ProviderMethod} implementation that invokes the method using normal java reflection.
   ","/**
 * Creates a {@link ProviderMethod}.
 *
 * <p>Unless {@code skipFastClassGeneration} is set, this will use {@link
 * net.sf.cglib.reflect.FastClass} to invoke the actual method, since it is significantly faster.
 * However, this will fail if the method is {@code private} or {@code protected}, since fastclass
 * is subject to java access policies.
 */
 
/**
 * Extension point for our subclasses to implement the provisioning strategy.
 */
 
","{
    int modifiers = method.getModifiers();
    /*if[AOP]*/
    if (!skipFastClassGeneration) {
        try {
            net.sf.cglib.reflect.FastClass fc = BytecodeGen.newFastClassForMember(method);
            if (fc != null) {
                return new FastClassProviderMethod<T>(key, fc, method, instance, dependencies, scopeAnnotation, annotation);
            }
        } catch (net.sf.cglib.core.CodeGenerationException e) {
        /* fall-through */
        }
    }
    /*end[AOP]*/
    if (!Modifier.isPublic(modifiers) || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) {
        method.setAccessible(true);
    }
    return new ReflectionProviderMethod<T>(key, method, instance, dependencies, scopeAnnotation, annotation);
} 
doProvision 
","/**
 * @param method the method to invoke. It's return type must be the same type as {@code key}.
 */
 
","{
    // We can be safely initialized eagerly since our bindings must exist statically and it is an
    // error for them not to.
    super(InitializationTiming.EAGER);
    this.key = key;
    this.scopeAnnotation = scopeAnnotation;
    this.instance = instance;
    this.dependencies = dependencies;
    this.method = method;
    this.exposed = method.isAnnotationPresent(Exposed.class);
    this.annotation = annotation;
} 
","/**
 * Set by {@link #initialize(InjectorImpl, Errors)} so it is always available prior to injection.
 */
 
","Field parameterInjectors
",8,379
ConstructionProxyFactory.java,32,100,0.32,"
 * Creates {@link ConstructionProxy} instances.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Gets a construction proxy for the given constructor.
 */
 
","create 
",,,,,3,87
ConstantBindingBuilderImpl.java,21,97,0.21649484536082475,"
 * Bind a constant.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,3,67
DeferredLookups.java,22,33,0.6666666666666666,"
 * Returns providers and members injectors that haven't yet been initialized. As a part of injector
 * creation it's necessary to {@link #initialize initialize} these lookups.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Initialize the specified lookups, either immediately or when the injector is created.
 */
 
","{
    injector.lookups = injector;
    new LookupProcessor(errors).process(injector, lookups);
} 
",,,,,4,221
InterceptorStackCallback.java,24,84,0.2857142857142857,"
 * Intercepts a method with a stack of interceptors.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Removes stacktrace elements related to AOP internal mechanics from the throwable's stack trace
 * and any causes it may have.
 */
 
","{
    for (Throwable t = throwable; t != null; t = t.getCause()) {
        StackTraceElement[] stackTrace = t.getStackTrace();
        List<StackTraceElement> pruned = Lists.newArrayList();
        for (StackTraceElement element : stackTrace) {
            String className = element.getClassName();
            if (!AOP_INTERNAL_CLASSES.contains(className) && !className.contains(""$EnhancerByGuice$"")) {
                pruned.add(element);
            }
        }
        t.setStackTrace(pruned.toArray(new StackTraceElement[pruned.size()]));
    }
} 
",,,,,3,92
ProvidesMethodScanner.java,26,142,0.18309859154929578,"
 * A {@link ModuleAnnotatedMethodScanner} that handles the {@Provides}, {@link ProvidesIntoSet},
 * {@link ProvidesIntoMap} and {@link ProvidesIntoOptional} annotations.
 *
 * <p>This is the default scanner used by ProviderMethodsModule and handles all the built in
 * annotations.
 ",,,,,,,5,273
AbstractBindingBuilder.java,23,88,0.26136363636363635,"
 * Bind a value or constant.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Sets the binding to a copy with the specified annotation on the bound key
 */
 
/**
 * Sets the binding to a copy with the specified annotation on the bound key
 */
 
","{
    checkNotNull(annotationType, ""annotationType"");
    checkNotAnnotated();
    return setBinding(binding.withKey(Key.get(this.binding.getKey().getTypeLiteral(), annotationType)));
} 
{
    checkNotNull(annotation, ""annotation"");
    checkNotAnnotated();
    return setBinding(binding.withKey(Key.get(this.binding.getKey().getTypeLiteral(), annotation)));
} 
",,,,,3,76
Nullability.java,29,14,2.0714285714285716,"
 * Whether a member supports null values injected.
 *
 * <p>Support for {@code Nullable} annotations in Guice is loose. Any annotation type whose
 * simplename is ""Nullable"" is sufficient to indicate support for null values injected.
 *
 * <p>This allows support for JSR-305's <a
 * href=""http://groups.google.com/group/jsr-305/web/proposed-annotations"">
 * javax.annotation.meta.Nullable</a> annotation and IntelliJ IDEA's <a
 * href=""http://www.jetbrains.com/idea/documentation/howto.html"">
 * org.jetbrains.annotations.Nullable</a>.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,12,565
State.java,21,223,0.09417040358744394,"
 * The inheritable data within an injector. This class is intended to allow parent and local
 * injector data to be accessed as a unit.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Gets a binding which was specified explicitly in a module, or null.
 */
 
/**
 * Returns the explicit bindings at this level only.
 */
 
/**
 * Returns the matching converter for {@code type}, or null if none match.
 */
 
/**
 * Returns all converters at this level only.
 */
 
/**
 * Forbids the corresponding injector from creating a binding to {@code key}. Child injectors
 * blacklist their bound keys on their parent injectors to prevent just-in-time bindings on the
 * parent injector that would conflict and pass along their state to control the lifetimes.
 */
 
/**
 * Returns true if {@code key} is forbidden from being bound in this injector. This indicates that
 * one of this injector's descendent's has bound the key.
 */
 
/**
 * Returns the source of a blacklisted key.
 */
 
/**
 * Returns the shared lock for all injector data. This is a low-granularity, high-contention lock
 * to be used when reading mutable data (ie. just-in-time bindings, and binding blacklists).
 */
 
/**
 * Returns all the scope bindings at this level and parent levels.
 */
 
","getExplicitBinding 
getExplicitBindingsThisLevel 
getConverter 
getConvertersThisLevel 
blacklist 
isBlacklisted 
getSourcesForBlacklistedKey 
lock 
getScopes 
",,,,,4,181
InternalFactoryToProviderAdapter.java,16,29,0.5517241379310345," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
ProcessedBindingData.java,32,32,1.0,"
 * Keeps track of creation listeners & uninitialized bindings, so they can be processed after
 * bindings are recorded.
 *
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Initialize bindings. This may be done eagerly
 */
 
/**
 * Runs creation listeners.
 *
 * <p>TODO(lukes): figure out exactly why this case exists.
 */
 
/**
 * Initialized bindings that need to be delayed until after all injection points and other
 * bindings are processed. The main current usecase for this is resolving Optional dependencies
 * for OptionalBinder bindings.
 */
 
","{
    for (Runnable initializer : uninitializedBindings) {
        initializer.run();
    }
} 
{
    for (CreationListener creationListener : creationListeners) {
        creationListener.notify(errors);
    }
} 
{
    for (Runnable initializer : delayedUninitializedBindings) {
        initializer.run();
    }
} 
",,,,,4,157
ProvisionListenerCallbackStore.java,42,77,0.5454545454545454,"
 * {@link ProvisionListenerStackCallback} for each key.
 *
 * @author sameb@google.com (Sam Berlin)
 | TODO(sameb): Consider exposing this in the API somehow?  Maybe?| A struct that holds key & binding but uses just key for equality/hashcode. ","/**
 * Returns a new {@link ProvisionListenerStackCallback} for the key or {@code null} if there are
 * no listeners
 */
 
/**
 * Purges a key from the cache. Use this only if the type is not actually valid for binding and
 * needs to be purged. (See issue 319 and
 * ImplicitBindingTest#testCircularJitBindingsLeaveNoResidue and
 * #testInstancesRequestingProvidersForThemselvesWithChildInjectors for examples of when this is
 * necessary.)
 *
 * <p>Returns true if the type was stored in the cache, false otherwise.
 */
 
/**
 * Creates a new {@link ProvisionListenerStackCallback} with the correct listeners for the key.
 */
 
","{
    // Never notify any listeners for internal bindings.
    if (!INTERNAL_BINDINGS.contains(binding.getKey())) {
        ProvisionListenerStackCallback<T> callback = (ProvisionListenerStackCallback<T>) cache.getUnchecked(new KeyBinding(binding.getKey(), binding));
        return callback.hasListeners() ? callback : null;
    }
    return null;
} 
{
    return cache.asMap().remove(type) != null;
} 
{
    List<ProvisionListener> listeners = null;
    for (ProvisionListenerBinding provisionBinding : listenerBindings) {
        if (provisionBinding.getBindingMatcher().matches(binding)) {
            if (listeners == null) {
                listeners = Lists.newArrayList();
            }
            listeners.addAll(provisionBinding.getListeners());
        }
    }
    if (listeners == null || listeners.isEmpty()) {
        // Optimization: don't bother constructing the callback if there are
        // no listeners.
        return ProvisionListenerStackCallback.emptyListener();
    }
    return new ProvisionListenerStackCallback<T>(binding, listeners);
} 
",,,,,4,237
RealElement.java,17,69,0.2463768115942029," An implementation of Element. | TODO(cgruber): Use AutoAnnotation when available, here & wherever else is makes sense.",,,,,,,1,119
UniqueAnnotations.java,20,42,0.47619047619047616," @author jessewilson@google.com (Jesse Wilson) ","/**
 * Returns an annotation instance that is not equal to any other annotation instances, for use in
 * creating distinct {@link com.google.inject.Key}s.
 */
 
","{
    return create(nextUniqueValue.getAndIncrement());
} 
",,,,,1,47
CycleDetectingLock.java,133,161,0.8260869565217391,"
 * Simplified version of {@link Lock} that is special due to how it handles deadlocks detection.
 *
 * <p>Is an inherent part of {@link SingletonScope}, moved into a upper level class due to its size
 * and complexity.
 *
 * @param <ID> Lock identification provided by the client, is returned unmodified to the client when
 *     lock cycle is detected to identify it. Only toString() needs to be implemented. Lock
 *     references this object internally, for the purposes of Garbage Collection you should not use
 *     heavy IDs. Lock is referenced by a lock factory as long as it's owned by a thread.
 * @see SingletonScope
 * @see com.google.inject.internal.CycleDetectingLock.CycleDetectingLockFactory
 * @author timofeyb (Timothy Basanov)
 |
   * Wraps locks so they would never cause a deadlock. On each {@link
   * CycleDetectingLock#lockOrDetectPotentialLocksCycle} we check for dependency cycles within locks
   * created by the same factory. Either we detect a cycle and return it or take it atomically.
   *
   * <p>Important to note that we do not prevent deadlocks in the client code. As an example: Thread
   * A takes lock L and creates singleton class CA depending on the singleton class CB. Meanwhile
   * thread B is creating class CB and is waiting on the lock L. Issue happens due to client code
   * creating interdependent classes and using locks, where no guarantees on the creation order from
   * Guice are provided.
   *
   * <p>Instances of these locks are not intended to be exposed outside of {@link SingletonScope}.
   | The implementation for {@link CycleDetectingLock}. ","/**
 * Takes a lock in a blocking fashion in case no potential deadlocks are detected. If the lock was
 * successfully owned, returns an empty map indicating no detected potential deadlocks.
 *
 * <p>Otherwise, a map indicating threads involved in a potential deadlock are returned. Map is
 * ordered by dependency cycle and lists locks for each thread that are part of the loop in order,
 * the last lock in the list is the one that the thread is currently waiting for. Returned map is
 * created atomically.
 *
 * <p>In case no cycle is detected performance is O(threads creating singletons), in case cycle is
 * detected performance is O(singleton locks).
 */
 
/**
 * Unlocks previously locked lock.
 */
 
/**
 * Creates new lock within this factory context. We can guarantee that locks created by the same
 * factory would not deadlock.
 *
 * @param userLockId lock id that would be used to report lock cycles if detected
 */
 
/**
 * Check consistency of an internal state.
 */
 
/**
 * Algorithm to detect a potential lock cycle.
 *
 * <p>For lock's thread owner check which lock is it trying to take. Repeat recursively. When
 * current thread is found a potential cycle is detected.
 *
 * @see CycleDetectingLock#lockOrDetectPotentialLocksCycle()
 */
 
/**
 * Adds all locks held by the given thread that are after the given lock and then returns the
 * lock the thread is currently waiting on, if any
 */
 
","lockOrDetectPotentialLocksCycle 
unlock 
{
    return new ReentrantCycleDetectingLock<ID>(this, userLockId, new ReentrantLock());
} 
{
    final Thread currentThread = Thread.currentThread();
    Preconditions.checkState(!lockThreadIsWaitingOn.containsKey(currentThread), ""Internal error: Thread should not be in a waiting thread on a lock now"");
    if (lockOwnerThread != null) {
        // check state of a locked lock
        Preconditions.checkState(lockReentranceCount >= 0, ""Internal error: Lock ownership and reentrance count internal states do not match"");
        Preconditions.checkState(locksOwnedByThread.get(lockOwnerThread).contains(this), ""Internal error: Set of locks owned by a current thread and lock "" + ""ownership status do not match"");
    } else {
        // check state of a non locked lock
        Preconditions.checkState(lockReentranceCount == 0, ""Internal error: Reentrance count of a non locked lock is expect to be zero"");
        Preconditions.checkState(!locksOwnedByThread.values().contains(this), ""Internal error: Non locked lock should not be owned by any thread"");
    }
} 
{
    final Thread currentThread = Thread.currentThread();
    if (lockOwnerThread == null || lockOwnerThread == currentThread) {
        // if nobody owns this lock, lock cycle is impossible
        // if a current thread owns this lock, we let Guice to handle it
        return ImmutableListMultimap.of();
    }
    ListMultimap<Thread, ID> potentialLocksCycle = MultimapBuilder.linkedHashKeys().arrayListValues().build();
    // lock that is a part of a potential locks cycle, starts with current lock
    ReentrantCycleDetectingLock<?> lockOwnerWaitingOn = this;
    // try to find a dependency path between lock's owner thread and a current thread
    while (lockOwnerWaitingOn != null && lockOwnerWaitingOn.lockOwnerThread != null) {
        Thread threadOwnerThreadWaits = lockOwnerWaitingOn.lockOwnerThread;
        // in case locks cycle exists lock we're waiting for is part of it
        lockOwnerWaitingOn = addAllLockIdsAfter(threadOwnerThreadWaits, lockOwnerWaitingOn, potentialLocksCycle);
        if (threadOwnerThreadWaits == currentThread) {
            // owner thread depends on current thread, cycle detected
            return potentialLocksCycle;
        }
    }
    // no dependency path from an owner thread to a current thread
    return ImmutableListMultimap.of();
} 
{
    boolean found = false;
    Collection<ReentrantCycleDetectingLock<?>> ownedLocks = locksOwnedByThread.get(thread);
    Preconditions.checkNotNull(ownedLocks, ""Internal error: No locks were found taken by a thread"");
    for (ReentrantCycleDetectingLock<?> ownedLock : ownedLocks) {
        if (ownedLock == lock) {
            found = true;
        }
        if (found && ownedLock.lockFactory == this.lockFactory) {
            // All locks are stored in a shared map therefore there is no way to
            // enforce type safety. We know that our cast is valid as we check for a lock's
            // factory. If the lock was generated by the
            // same factory it has to have same type as the current lock.
            @SuppressWarnings(""unchecked"")
            ID userLockId = (ID) ownedLock.userLockId;
            potentialLocksCycle.put(thread, userLockId);
        }
    }
    Preconditions.checkState(found, ""Internal error: We can not find locks that created a cycle that we detected"");
    ReentrantCycleDetectingLock<?> unownedLock = lockThreadIsWaitingOn.get(thread);
    // If this thread is waiting for a lock add it to the cycle and return it
    if (unownedLock != null && unownedLock.lockFactory == this.lockFactory) {
        @SuppressWarnings(""unchecked"")
        ID typed = (ID) unownedLock.userLockId;
        potentialLocksCycle.put(thread, typed);
    }
    return unownedLock;
} 
",,,"/**
 * Specifies lock that thread is currently waiting on to own it. Used only for purposes of locks
 * cycle detection.
 *
 * <ul>
 *   <li>Key: thread
 *   <li>Value: lock that is being waited on
 * </ul>
 *
 * <p>Element is added inside {@link #lockOrDetectPotentialLocksCycle()} before {@link
 * Lock#lock} is called. Element is removed inside {@link #lockOrDetectPotentialLocksCycle()}
 * after {@link Lock#lock} and synchronously with adding it to {@link #locksOwnedByThread}.
 *
 * <p>Same lock can be added for several threads in case all of them are trying to take it.
 *
 * <p>Guarded by {@code CycleDetectingLockFactory.class}.
 */
 
/**
 * Lists locks that thread owns. Used only to populate locks in a potential cycle when it is
 * detected.
 *
 * <ul>
 *   <li>Key: thread
 *   <li>Value: stack of locks that were owned.
 * </ul>
 *
 * <p>Element is added inside {@link #lockOrDetectPotentialLocksCycle()} after {@link Lock#lock}
 * is called. Element is removed inside {@link #unlock()} synchronously with {@link
 * Lock#unlock()} call.
 *
 * <p>Same lock can only be present several times for the same thread as locks are reentrant.
 * Lock can not be owned by several different threads as the same time.
 *
 * <p>Guarded by {@code CycleDetectingLockFactory.class}.
 */
 
/**
 * Underlying lock used for actual waiting when no potential deadlocks are detected.
 */
 
/**
 * User id for this lock.
 */
 
/**
 * Factory that was used to create this lock.
 */
 
/**
 * Thread that owns this lock. Nullable. Guarded by {@code CycleDetectingLockFactory.this}.
 */
 
/**
 * Number of times that thread owned this lock. Guarded by {@code
 * CycleDetectingLockFactory.this}.
 */
 
","Field lockThreadIsWaitingOn
Field locksOwnedByThread
Field lockImplementation
Field userLockId
Field lockFactory
Field lockOwnerThread
Field lockReentranceCount
",25,1557
InjectorImpl.java,203,845,0.24023668639053256,"
 * Default {@link Injector} implementation.
 *
 * @author crazybob@google.com (Bob Lee)
 | Options that control how the injector behaves. | some limitations on what just in time bindings are allowed. | Invokes a method. ","/**
 * Indexes bindings by type.
 */
 
/**
 * Returns the binding for {@code key}
 */
 
/**
 * Gets a binding implementation. First, it check to see if the parent has a binding. If the
 * parent has a binding and the binding is scoped, it will use that binding. Otherwise, this
 * checks for an explicit binding. If no explicit binding is found, it looks for a just-in-time
 * binding.
 */
 
/**
 * Returns a just-in-time binding for {@code key}, creating it if necessary.
 *
 * @throws ErrorsException if the binding could not be created.
 */
 
/**
 * Returns true if the key type is Provider (but not a subclass of Provider).
 */
 
/**
 * Returns true if the key type is MembersInjector (but not a subclass of MembersInjector).
 */
 
/**
 * Creates a synthetic binding to {@code Provider<T>}, i.e. a binding to the provider from {@code
 * Binding<T>}.
 */
 
/**
 * Converts a constant string binding to the required type.
 *
 * @return the binding if it could be resolved, or null if the binding doesn't exist
 * @throws com.google.inject.internal.ErrorsException if there was an error resolving the binding
 */
 
/**
 * Iterates through the binding's dependencies to clean up any stray bindings that were leftover
 * from a failed JIT binding. This is required because the bindings are eagerly & optimistically
 * added to allow circular dependency support, so dependencies may pass where they should have
 * failed.
 */
 
/**
 * Cleans up any state that may have been cached when constructing the JIT binding.
 */
 
/**
 * Safely gets the dependencies of possibly not initialized bindings.
 */
 
/**
 * Creates a binding for an injectable type with the given scope. Looks for a scope on the type if
 * none is specified.
 */
 
/**
 * Converts a binding for a {@code Key<TypeLiteral<T>>} to the value {@code TypeLiteral<T>}. It's
 * a bit awkward because we have to pull out the inner type in the type literal.
 */
 
/**
 * Creates a binding for a type annotated with @ProvidedBy.
 */
 
/**
 * Creates a binding for a type annotated with @ImplementedBy.
 */
 
/**
 * Attempts to create a just-in-time binding for {@code key} in the root injector, falling back to
 * other ancestor injectors until this injector is tried.
 */
 
/**
 * Returns a new just-in-time binding created by resolving {@code key}. The strategies used to
 * create just-in-time bindings are:
 *
 * <ol>
 *   <li>Internalizing Providers. If the requested binding is for {@code Provider<T>}, we delegate
 *       to the binding for {@code T}.
 *   <li>Converting constants.
 *   <li>ImplementedBy and ProvidedBy annotations. Only for unannotated keys.
 *   <li>The constructor of the raw type. Only for unannotated keys.
 * </ol>
 *
 * @throws com.google.inject.internal.ErrorsException if the binding cannot be created.
 */
 
/**
 * Returns parameter injectors, or {@code null} if there are no parameters.
 */
 
/**
 * Only to be called by the {@link SingletonScope} provider.
 */
 
/**
 * Looks up thread local context and {@link InternalContext#enter() enters} it or creates a new
 * context if necessary.
 *
 * <p>All callers of this are responsible for calling {@link InternalContext#close()}. Typical
 * usage should look like:
 *
 * <pre>{@code
 * InternalContext ctx = injector.enterContext();
 * try {
 *   ... use ctx ...
 * } finally {
 *   ctx.close();
 * }
 * }</pre>
 */
 
","{
    for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) {
        bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding);
    }
} 
{
    Errors errors = new Errors(checkNotNull(key, ""key""));
    try {
        BindingImpl<T> result = getBindingOrThrow(key, errors, JitLimitation.EXISTING_JIT);
        errors.throwConfigurationExceptionIfErrorsExist();
        return result;
    } catch (ErrorsException e) {
        throw new ConfigurationException(errors.merge(e.getErrors()).getMessages());
    }
} 
{
    // Check explicit bindings, i.e. bindings created by modules.
    BindingImpl<T> binding = state.getExplicitBinding(key);
    if (binding != null) {
        return binding;
    }
    // Look for an on-demand binding.
    return getJustInTimeBinding(key, errors, jitType);
} 
{
    boolean jitOverride = isProvider(key) || isTypeLiteral(key) || isMembersInjector(key);
    synchronized (state.lock()) {
        // first try to find a JIT binding that we've already created
        for (InjectorImpl injector = this; injector != null; injector = injector.parent) {
            // we only store bindings that match their key
            @SuppressWarnings(""unchecked"")
            BindingImpl<T> binding = (BindingImpl<T>) injector.jitBindings.get(key);
            if (binding != null) {
                // If we found a JIT binding and we don't allow them,
                // fail.  (But allow bindings created through TypeConverters.)
                if (options.jitDisabled && jitType == JitLimitation.NO_JIT && !jitOverride && !(binding instanceof ConvertedConstantBindingImpl)) {
                    throw errors.jitDisabled(key).toException();
                } else {
                    return binding;
                }
            }
        }
        // If we previously failed creating this JIT binding and our Errors has
        // already recorded an error, then just directly throw that error.
        // We need to do this because it's possible we already cleaned up the
        // entry in jitBindings (during cleanup), and we may be trying
        // to create it again (in the case of a recursive JIT binding).
        // We need both of these guards for different reasons
        // failedJitBindings.contains: We want to continue processing if we've never
        // failed before, so that our initial error message contains
        // as much useful information as possible about what errors exist.
        // errors.hasErrors: If we haven't already failed, then it's OK to
        // continue processing, to make sure the ultimate error message
        // is the correct one.
        // See: ImplicitBindingsTest#testRecursiveJitBindingsCleanupCorrectly
        // for where this guard compes into play.
        if (failedJitBindings.contains(key) && errors.hasErrors()) {
            throw errors.toException();
        }
        return createJustInTimeBindingRecursive(key, errors, options.jitDisabled, jitType);
    }
// end synchronized(state.lock())
} 
{
    return key.getTypeLiteral().getRawType().equals(Provider.class);
} 
{
    return key.getTypeLiteral().getRawType().equals(MembersInjector.class) && key.getAnnotationType() == null;
} 
{
    Key<T> providedKey = getProvidedKey(key, errors);
    BindingImpl<T> delegate = getBindingOrThrow(providedKey, errors, JitLimitation.NO_JIT);
    return new ProviderBindingImpl<T>(this, key, delegate);
} 
{
    // Find a constant string binding.
    Key<String> stringKey = key.ofType(STRING_TYPE);
    BindingImpl<String> stringBinding = state.getExplicitBinding(stringKey);
    if (stringBinding == null || !stringBinding.isConstant()) {
        return null;
    }
    // We can't call getProvider().get() because this InstanceBinding may not have been inintialized
    // yet (because we may have been called during InternalInjectorCreator.initializeStatically and
    // instance binding validation hasn't happened yet.)
    @SuppressWarnings(""unchecked"")
    String stringValue = ((InstanceBinding<String>) stringBinding).getInstance();
    Object source = stringBinding.getSource();
    // Find a matching type converter.
    TypeLiteral<T> type = key.getTypeLiteral();
    TypeConverterBinding typeConverterBinding = state.getConverter(stringValue, type, errors, source);
    if (typeConverterBinding == null) {
        // No converter can handle the given type.
        return null;
    }
    // Try to convert the string. A failed conversion results in an error.
    try {
        // This cast is safe because we double check below.
        @SuppressWarnings(""unchecked"")
        T converted = (T) typeConverterBinding.getTypeConverter().convert(stringValue, type);
        if (converted == null) {
            throw errors.converterReturnedNull(stringValue, source, type, typeConverterBinding).toException();
        }
        if (!type.getRawType().isInstance(converted)) {
            throw errors.conversionTypeError(stringValue, source, type, typeConverterBinding, converted).toException();
        }
        return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding, typeConverterBinding);
    } catch (ErrorsException e) {
        throw e;
    } catch (RuntimeException e) {
        throw errors.conversionError(stringValue, source, type, typeConverterBinding, e).toException();
    }
} 
{
    boolean bindingFailed = false;
    Set<Dependency<?>> deps = getInternalDependencies(binding);
    for (Dependency dep : deps) {
        Key<?> depKey = dep.getKey();
        InjectionPoint ip = dep.getInjectionPoint();
        if (encountered.add(depKey)) {
            // only check if we haven't looked at this key yet
            BindingImpl depBinding = jitBindings.get(depKey);
            if (depBinding != null) {
                // if the binding still exists, validate
                // if children fail, we fail
                boolean failed = cleanup(depBinding, encountered);
                if (depBinding instanceof ConstructorBindingImpl) {
                    ConstructorBindingImpl ctorBinding = (ConstructorBindingImpl) depBinding;
                    ip = ctorBinding.getInternalConstructor();
                    if (!ctorBinding.isInitialized()) {
                        failed = true;
                    }
                }
                if (failed) {
                    removeFailedJitBinding(depBinding, ip);
                    bindingFailed = true;
                }
            } else if (state.getExplicitBinding(depKey) == null) {
                // ignore keys if they were explicitly bound, but if neither JIT
                // nor explicit, it's also invalid & should let parent know.
                bindingFailed = true;
            }
        }
    }
    return bindingFailed;
} 
{
    failedJitBindings.add(binding.getKey());
    jitBindings.remove(binding.getKey());
    membersInjectorStore.remove(binding.getKey().getTypeLiteral());
    provisionListenerStore.remove(binding);
    if (ip != null) {
        constructors.remove(ip);
    }
} 
{
    if (binding instanceof ConstructorBindingImpl) {
        return ((ConstructorBindingImpl) binding).getInternalDependencies();
    } else if (binding instanceof HasDependencies) {
        return ((HasDependencies) binding).getDependencies();
    } else {
        return ImmutableSet.of();
    }
} 
{
    Class<?> rawType = key.getTypeLiteral().getRawType();
    ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class);
    // Don't try to inject arrays or enums annotated with @ImplementedBy.
    if (rawType.isArray() || (rawType.isEnum() && implementedBy != null)) {
        throw errors.missingImplementationWithHint(key, this).toException();
    }
    // Handle TypeLiteral<T> by binding the inner type
    if (rawType == TypeLiteral.class) {
        // we have to fudge the inner type as Object
        @SuppressWarnings(""unchecked"")
        BindingImpl<T> binding = (BindingImpl<T>) createTypeLiteralBinding((Key<TypeLiteral<Object>>) key, errors);
        return binding;
    }
    // Handle @ImplementedBy
    if (implementedBy != null) {
        Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors);
        return createImplementedByBinding(key, scoping, implementedBy, errors);
    }
    // Handle @ProvidedBy.
    ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class);
    if (providedBy != null) {
        Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors);
        return createProvidedByBinding(key, scoping, providedBy, errors);
    }
    return ConstructorBindingImpl.create(this, key, null, /* use default constructor */
    source, scoping, errors, jitBinding && options.jitDisabled, options.atInjectRequired);
} 
{
    Type typeLiteralType = key.getTypeLiteral().getType();
    if (!(typeLiteralType instanceof ParameterizedType)) {
        throw errors.cannotInjectRawTypeLiteral().toException();
    }
    ParameterizedType parameterizedType = (ParameterizedType) typeLiteralType;
    Type innerType = parameterizedType.getActualTypeArguments()[0];
    // this is unforunate. We don't support building TypeLiterals for type variable like 'T'. If
    // this proves problematic, we can probably fix TypeLiteral to support type variables
    if (!(innerType instanceof Class) && !(innerType instanceof GenericArrayType) && !(innerType instanceof ParameterizedType)) {
        throw errors.cannotInjectTypeLiteralOf(innerType).toException();
    }
    // by definition, innerType == T, so this is safe
    @SuppressWarnings(""unchecked"")
    TypeLiteral<T> value = (TypeLiteral<T>) TypeLiteral.get(innerType);
    InternalFactory<TypeLiteral<T>> factory = new ConstantFactory<TypeLiteral<T>>(Initializables.of(value));
    return new InstanceBindingImpl<TypeLiteral<T>>(this, key, SourceProvider.UNKNOWN_SOURCE, factory, ImmutableSet.<InjectionPoint>of(), value);
} 
{
    Class<?> rawType = key.getTypeLiteral().getRawType();
    Class<? extends javax.inject.Provider<?>> providerType = providedBy.value();
    // Make sure it's not the same type. TODO: Can we check for deeper loops?
    if (providerType == rawType) {
        throw errors.recursiveProviderType().toException();
    }
    // Assume the provider provides an appropriate type. We double check at runtime.
    @SuppressWarnings(""unchecked"")
    Key<? extends Provider<T>> providerKey = (Key<? extends Provider<T>>) Key.get(providerType);
    ProvidedByInternalFactory<T> internalFactory = new ProvidedByInternalFactory<T>(rawType, providerType, providerKey);
    Object source = rawType;
    BindingImpl<T> binding = LinkedProviderBindingImpl.createWithInitializer(this, key, source, Scoping.<T>scope(key, this, internalFactory, source, scoping), scoping, providerKey, internalFactory);
    internalFactory.setProvisionListenerCallback(provisionListenerStore.get(binding));
    return binding;
} 
{
    Class<?> rawType = key.getTypeLiteral().getRawType();
    Class<?> implementationType = implementedBy.value();
    // Make sure it's not the same type. TODO: Can we check for deeper cycles?
    if (implementationType == rawType) {
        throw errors.recursiveImplementationType().toException();
    }
    // Make sure implementationType extends type.
    if (!rawType.isAssignableFrom(implementationType)) {
        throw errors.notASubtype(implementationType, rawType).toException();
    }
    // After the preceding check, this cast is safe.
    @SuppressWarnings(""unchecked"")
    Class<? extends T> subclass = (Class<? extends T>) implementationType;
    // Look up the target binding.
    final Key<? extends T> targetKey = Key.get(subclass);
    Object source = rawType;
    FactoryProxy<T> factory = new FactoryProxy<>(this, key, targetKey, source);
    // causes the factory to initialize itself internally
    factory.notify(errors);
    return new LinkedBindingImpl<T>(this, key, source, Scoping.<T>scope(key, this, factory, source, scoping), scoping, targetKey);
} 
{
    // ask the parent to create the JIT binding
    if (parent != null) {
        if (jitType == JitLimitation.NEW_OR_EXISTING_JIT && jitDisabled && !parent.options.jitDisabled) {
            // If the binding would be forbidden here but allowed in a parent, report an error instead
            throw errors.jitDisabledInParent(key).toException();
        }
        try {
            return parent.createJustInTimeBindingRecursive(key, new Errors(), jitDisabled, parent.options.jitDisabled ? JitLimitation.NO_JIT : jitType);
        } catch (ErrorsException ignored) {
        }
    }
    // Retrieve the sources before checking for blacklisting to guard against sources becoming null
    // due to a full GC happening after calling state.isBlacklisted and
    // state.getSourcesForBlacklistedKey.
    // TODO(user): Consolidate these two APIs.
    Set<Object> sources = state.getSourcesForBlacklistedKey(key);
    if (state.isBlacklisted(key)) {
        throw errors.childBindingAlreadySet(key, sources).toException();
    }
    // before storing the key long-term, canonicalize it.
    key = MoreTypes.canonicalizeKey(key);
    BindingImpl<T> binding = createJustInTimeBinding(key, errors, jitDisabled, jitType);
    state.parent().blacklist(key, state, binding.getSource());
    jitBindings.put(key, binding);
    return binding;
} 
{
    int numErrorsBefore = errors.size();
    // Retrieve the sources before checking for blacklisting to guard against sources becoming null
    // due to a full GC happening after calling state.isBlacklisted and
    // state.getSourcesForBlacklistedKey.
    // TODO(user): Consolidate these two APIs.
    Set<Object> sources = state.getSourcesForBlacklistedKey(key);
    if (state.isBlacklisted(key)) {
        throw errors.childBindingAlreadySet(key, sources).toException();
    }
    // Handle cases where T is a Provider<?>.
    if (isProvider(key)) {
        // These casts are safe. We know T extends Provider<X> and that given Key<Provider<X>>,
        // createProviderBinding() will return BindingImpl<Provider<X>>.
        @SuppressWarnings({ ""unchecked"", ""cast"" })
        BindingImpl<T> binding = (BindingImpl<T>) createProviderBinding((Key) key, errors);
        return binding;
    }
    // Handle cases where T is a MembersInjector<?>
    if (isMembersInjector(key)) {
        // These casts are safe. T extends MembersInjector<X> and that given Key<MembersInjector<X>>,
        // createMembersInjectorBinding() will return BindingImpl<MembersInjector<X>>.
        @SuppressWarnings({ ""unchecked"", ""cast"" })
        BindingImpl<T> binding = (BindingImpl<T>) createMembersInjectorBinding((Key) key, errors);
        return binding;
    }
    // Try to convert a constant string binding to the requested type.
    BindingImpl<T> convertedBinding = convertConstantStringBinding(key, errors);
    if (convertedBinding != null) {
        return convertedBinding;
    }
    if (!isTypeLiteral(key) && jitDisabled && jitType != JitLimitation.NEW_OR_EXISTING_JIT) {
        throw errors.jitDisabled(key).toException();
    }
    // If the key has an annotation...
    if (key.getAnnotationType() != null) {
        // Look for a binding without annotation attributes or return null.
        if (key.hasAttributes() && !options.exactBindingAnnotationsRequired) {
            try {
                Errors ignored = new Errors();
                return getBindingOrThrow(key.withoutAttributes(), ignored, JitLimitation.NO_JIT);
            } catch (ErrorsException ignored) {
            // throw with a more appropriate message below
            }
        }
        throw errors.missingImplementationWithHint(key, this).toException();
    }
    Object source = key.getTypeLiteral().getRawType();
    BindingImpl<T> binding = createUninitializedBinding(key, Scoping.UNSCOPED, source, errors, true);
    errors.throwIfNewErrors(numErrorsBefore);
    initializeJitBinding(binding, errors);
    return binding;
} 
{
    if (parameters.isEmpty()) {
        return null;
    }
    int numErrorsBefore = errors.size();
    SingleParameterInjector<?>[] result = new SingleParameterInjector<?>[parameters.size()];
    int i = 0;
    for (Dependency<?> parameter : parameters) {
        try {
            result[i++] = createParameterInjector(parameter, errors.withSource(parameter));
        } catch (ErrorsException rethrownBelow) {
        // rethrown below
        }
    }
    errors.throwIfNewErrors(numErrorsBefore);
    return result;
} 
{
    return (InternalContext) localContext.get()[0];
} 
{
    Object[] reference = localContext.get();
    if (reference == null) {
        reference = new Object[1];
        localContext.set(reference);
    }
    InternalContext ctx = (InternalContext) reference[0];
    if (ctx == null) {
        reference[0] = ctx = new InternalContext(options, reference);
    } else {
        ctx.enter();
    }
    return ctx;
} 
",,,"/**
 * Just-in-time binding cache. Guarded by state.lock()
 */
 
/**
 * Cache of Keys that we were unable to create JIT bindings for, so we don't keep trying. Also
 * guarded by state.lock().
 */
 
/**
 * The set of types passed to {@link #getMembersInjector} and {@link #injectMembers}.
 */
 
/**
 * Cached constructor injectors for each type
 */
 
/**
 * Cached field and method injectors for each type.
 */
 
/**
 * Cached provision listener callbacks for each key.
 */
 
/**
 * Holds Object[] as a mutable wrapper, rather than InternalContext, since array operations are
 * faster than ThreadLocal.set() / .get() operations.
 *
 * <p>Holds Object[] rather than InternalContext[], since localContext never gets cleaned up at
 * any point. This could lead to problems when, for example, an OSGI application is reloaded, the
 * InjectorImpl is destroyed, but the thread that the injector runs on is kept alive. In such a
 * case, ThreadLocal itself would hold on to a reference to localContext, which would hold on to
 * the old InternalContext.class object, which would hold on to the old classloader that loaded
 * that class, and so on.
 */
 
","Field jitBindings
Field failedJitBindings
Field userRequestedMembersInjectorTypes
Field constructors
Field membersInjectorStore
Field provisionListenerStore
Field localContext
",4,214
InheritingState.java,21,223,0.09417040358744394," @author jessewilson@google.com (Jesse Wilson) ",,,,,,,1,47
ProviderToInternalFactoryAdapter.java,20,30,0.6666666666666666," @author crazybob@google.com (Bob Lee) ","/**
 * Exposed for SingletonScope.
 */
 
","{
    return injector;
} 
",,,,,1,39
MessageProcessor.java,21,27,0.7777777777777778,"
 * Handles {@code Binder.addError} commands.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,4,131
FactoryProxy.java,19,48,0.3958333333333333,"
 * A placeholder which enables us to swap in the real factory once the injector is created. Used for
 * a linked binding, so that getting the linked binding returns the link's factory.
 ",,,,,,,2,182
RealOptionalBinder.java,110,582,0.18900343642611683,"
 * The actual OptionalBinder plays several roles. It implements Module to hide that fact from the
 * public API, and installs the various bindings that are exposed to the user.
 | Provides the binding for java.util.Optional<T>. | Provides the binding for java.util.Optional<Provider<T>>. | Provides the binding for T, conditionally installed by calling setBinding/setDefault. | Provides the binding for Optional<Provider<T>>. | Provides the binding for Optional<T>. |
   * A helper object that implements the core logic for deciding what the implementation of the
   * binding will be.
   *
   * <p>This also implements the main OptionalBinderBinding logic.
   | A base class for ProviderWithDependencies that need equality based on a specific object. ","/**
 * Adds a binding for T. Multiple calls to this are safe, and will be collapsed as duplicate
 * bindings.
 */
 
/**
 * Returns the key to use for the default binding.
 *
 * <p>As a side effect this installs support for the 'direct type', so a binding for {@code T}
 * will be made available.
 */
 
/**
 * Returns the key to use for the actual binding, overrides the default if set.
 *
 * <p>As a side effect this installs support for the 'direct type', so a binding for {@code T}
 * will be made available.
 */
 
/**
 * Returns the Dependency for the target binding, throws NoSuchElementException if no target
 * exists.
 *
 * <p>Calls to this method should typically be guarded by checking if {@link #getBinding()}
 * returns {@code null}.
 */
 
/**
 * Implementation of {@link OptionalBinderBinding#containsElement}.
 */
 
/**
 * Initialize the factory. BindingSelection is guaranteed to be initialized at this point and
 * this will be called prior to any provisioning.
 */
 
","{
    binder.bind(bindingSelection.getDirectKey()).toProvider(new RealDirectTypeProvider<T>(bindingSelection));
} 
{
    bindingSelection.checkNotInitialized();
    addDirectTypeBinding(binder);
    return bindingSelection.getKeyForDefaultBinding();
} 
{
    bindingSelection.checkNotInitialized();
    addDirectTypeBinding(binder);
    return bindingSelection.getKeyForActualBinding();
} 
{
    return Iterables.getOnlyElement(dependencies);
} 
{
    // All of our bindings are ProviderInstanceBindings whose providers extend
    // RealOptionalBinderProviderWithDependencies and have 'this' as its binding selection.
    if (element instanceof ProviderInstanceBinding) {
        javax.inject.Provider<?> providerInstance = ((ProviderInstanceBinding<?>) element).getUserSuppliedProvider();
        if (providerInstance instanceof RealOptionalBinderProviderWithDependencies) {
            return ((RealOptionalBinderProviderWithDependencies<?, ?>) providerInstance).bindingSelection.equals(this);
        }
    }
    if (element instanceof Binding) {
        Key<?> elementKey = ((Binding) element).getKey();
        // if it isn't one of the things we bound directly it might be an actual or default key
        return elementKey.equals(getKeyForActualBinding()) || elementKey.equals(getKeyForDefaultBinding());
    }
    // cannot match;
    return false;
} 
doInitialize 
",,,"/**
 * lazily allocated, by {@link #getBindingName}.
 */
 
/**
 * lazily allocated, by {@link #getKeyForDefaultBinding}.
 */
 
/**
 * lazily allocated, by {@link #getKeyForActualBinding}.
 */
 
","Field bindingName
Field defaultBindingKey
Field actualBindingKey
",8,739
ExposedKeyFactory.java,23,28,0.8214285714285714,"
 * This factory exists in a parent injector. When invoked, it retrieves its value from a child
 * injector.
 ",,,,,,,2,105
Injector.java,32,90,0.35555555555555557,"
 * Builds the graphs of objects that make up your application. The injector tracks the dependencies
 * for each type and uses bindings to inject them. This is the core of Guice, although you rarely
 * interact with it directly. This ""behind-the-scenes"" operation is what distinguishes dependency
 * injection from its cousin, the service locator pattern.
 *
 * <p>Contains several default bindings:
 *
 * <ul>
 *   <li>This {@link Injector} instance itself
 *   <li>A {@code Provider<T>} for each binding of type {@code T}
 *   <li>The {@link java.util.logging.Logger} for the class being injected
 *   <li>The {@link Stage} in which the Injector was created
 * </ul>
 *
 * Injectors are created using the facade class {@link Guice}.
 *
 * <p>An injector can also {@link #injectMembers(Object) inject the dependencies} of
 * already-constructed instances. This can be used to interoperate with objects created by other
 * frameworks or services.
 *
 * <p>Injectors can be {@link #createChildInjector(Iterable) hierarchical}. Child injectors inherit
 * the configuration of their parent injectors, but the converse does not hold.
 *
 * <p>The injector's {@link #getBindings() internal bindings} are available for introspection. This
 * enables tools and extensions to operate on an injector reflectively.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
 * absence of an injectable constructor.
 *
 * <p>Whenever Guice creates an instance, it performs this injection automatically (after first
 * performing constructor injection), so if you're able to let Guice create all your objects for
 * you, you'll never need to use this method.
 *
 * @param instance to inject members on
 * @see Binder#getMembersInjector(Class) for a preferred alternative that supports checks before
 *     run time
 */
 
/**
 * Returns the members injector used to inject dependencies into methods and fields on instances
 * of the given type {@code T}.
 *
 * @param typeLiteral type to get members injector for
 * @see Binder#getMembersInjector(TypeLiteral) for an alternative that offers up front error
 *     detection
 * @since 2.0
 */
 
/**
 * Returns the members injector used to inject dependencies into methods and fields on instances
 * of the given type {@code T}. When feasible, use {@link Binder#getMembersInjector(TypeLiteral)}
 * instead to get increased up front error detection.
 *
 * @param type type to get members injector for
 * @see Binder#getMembersInjector(Class) for an alternative that offers up front error detection
 * @since 2.0
 */
 
/**
 * Returns this injector's <strong>explicit</strong> bindings.
 *
 * <p>The returned map does not include bindings inherited from a {@link #getParent() parent
 * injector}, should one exist. The returned map is guaranteed to iterate (for example, with its
 * {@link Map#entrySet()} iterator) in the order of insertion. In other words, the order in which
 * bindings appear in user Modules.
 *
 * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 */
 
/**
 * Returns a snapshot of this injector's bindings, <strong>both explicit and
 * just-in-time</strong>. The returned map is immutable; it contains only the bindings that were
 * present when {@code getAllBindings()} was invoked. Just-in-time bindings are only present if
 * they have been requested at least once. Subsequent calls may return a map with additional
 * just-in-time bindings.
 *
 * <p>The returned map does not include bindings inherited from a {@link #getParent() parent
 * injector}, should one exist.
 *
 * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 *
 * @since 3.0
 */
 
/**
 * Returns the binding for the given injection key. This will be an explicit bindings if the key
 * was bound explicitly by a module, or an implicit binding otherwise. The implicit binding will
 * be created if necessary.
 *
 * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 *
 * @throws ConfigurationException if this injector cannot find or create the binding.
 */
 
/**
 * Returns the binding for the given type. This will be an explicit bindings if the injection key
 * was bound explicitly by a module, or an implicit binding otherwise. The implicit binding will
 * be created if necessary.
 *
 * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 *
 * @throws ConfigurationException if this injector cannot find or create the binding.
 * @since 2.0
 */
 
/**
 * Returns the binding if it already exists, or null if does not exist. Unlike {@link
 * #getBinding(Key)}, this does not attempt to create just-in-time bindings for keys that aren't
 * bound.
 *
 * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 *
 * @since 3.0
 */
 
/**
 * Returns all explicit bindings for {@code type}.
 *
 * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 */
 
/**
 * Returns the provider used to obtain instances for the given injection key. When feasible, avoid
 * using this method, in favor of having Guice inject your dependencies ahead of time.
 *
 * @throws ConfigurationException if this injector cannot find or create the provider.
 * @see Binder#getProvider(Key) for an alternative that offers up front error detection
 */
 
/**
 * Returns the provider used to obtain instances for the given type. When feasible, avoid using
 * this method, in favor of having Guice inject your dependencies ahead of time.
 *
 * @throws ConfigurationException if this injector cannot find or create the provider.
 * @see Binder#getProvider(Class) for an alternative that offers up front error detection
 */
 
/**
 * Returns the appropriate instance for the given injection key; equivalent to {@code
 * getProvider(key).get()}. When feasible, avoid using this method, in favor of having Guice
 * inject your dependencies ahead of time.
 *
 * @throws ConfigurationException if this injector cannot find or create the provider.
 * @throws ProvisionException if there was a runtime failure while providing an instance.
 */
 
/**
 * Returns the appropriate instance for the given injection type; equivalent to {@code
 * getProvider(type).get()}. When feasible, avoid using this method, in favor of having Guice
 * inject your dependencies ahead of time.
 *
 * @throws ConfigurationException if this injector cannot find or create the provider.
 * @throws ProvisionException if there was a runtime failure while providing an instance.
 */
 
/**
 * Returns this injector's parent, or {@code null} if this is a top-level injector.
 *
 * @since 2.0
 */
 
/**
 * Returns a new injector that inherits all state from this injector. All bindings, scopes,
 * interceptors and type converters are inherited -- they are visible to the child injector.
 * Elements of the child injector are not visible to its parent.
 *
 * <p>Just-in-time bindings created for child injectors will be created in an ancestor injector
 * whenever possible. This allows for scoped instances to be shared between injectors. Use
 * explicit bindings to prevent bindings from being shared with the parent injector. Optional
 * injections in just-in-time bindings (created in the parent injector) may be silently ignored if
 * the optional dependencies are from the child injector.
 *
 * <p>No key may be bound by both an injector and one of its ancestors. This includes just-in-time
 * bindings. The lone exception is the key for {@code Injector.class}, which is bound by each
 * injector to itself.
 *
 * @since 2.0
 */
 
/**
 * Returns a new injector that inherits all state from this injector. All bindings, scopes,
 * interceptors and type converters are inherited -- they are visible to the child injector.
 * Elements of the child injector are not visible to its parent.
 *
 * <p>Just-in-time bindings created for child injectors will be created in an ancestor injector
 * whenever possible. This allows for scoped instances to be shared between injectors. Use
 * explicit bindings to prevent bindings from being shared with the parent injector.
 *
 * <p>No key may be bound by both an injector and one of its ancestors. This includes just-in-time
 * bindings. The lone exception is the key for {@code Injector.class}, which is bound by each
 * injector to itself.
 *
 * @since 2.0
 */
 
/**
 * Returns a map containing all scopes in the injector. The maps keys are scoping annotations like
 * {@code Singleton.class}, and the values are scope instances, such as {@code Scopes.SINGLETON}.
 * The returned map is immutable.
 *
 * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 *
 * @since 3.0
 */
 
/**
 * Returns a set containing all type converter bindings in the injector. The returned set is
 * immutable.
 *
 * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 *
 * @since 3.0
 */
 
/**
 * Returns the elements that make up this injector. Note that not all kinds of elements are
 * returned.
 *
 * <p>The returned list does not include elements inherited from a {@link #getParent() parent
 * injector}, should one exist.
 *
 * <p>The returned list is immutable; it contains only the elements that were present when {@link
 * #getElements} was invoked. Subsequent calls may return a list with additional elements.
 *
 * <p>The returned list does not include data inherited from a {@link #getParent() parent
 * injector}, should one exist.
 *
 * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 *
 * @since 5.0
 */
 
/**
 * Returns the injection points created for calls to {@link #getMembersInjector} (either directly
 * or indirectly, e.g. through {@link #injectMembers}.
 *
 * <p>This excludes any injection points from elements (which are accessible from each element via
 * the SPI), unless {@link #getMembersInjector} or {@link #injectMembers} were also called for the
 * same key.
 *
 * <p>The returned multimap does not include data inherited from a {@link #getParent() parent
 * injector}, should one exist.
 *
 * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
 *
 * @since 5.0
 */
 
","injectMembers 
getMembersInjector 
getMembersInjector 
getBindings 
getAllBindings 
getBinding 
getBinding 
getExistingBinding 
findBindingsByType 
getProvider 
getProvider 
getInstance 
getInstance 
getParent 
createChildInjector 
createChildInjector 
getScopeBindings 
getTypeConverterBindings 
getElements 
getAllMembersInjectorInjectionPoints 
",,,,,28,1342
Matcher.java,20,64,0.3125,"
 * Returns {@code true} or {@code false} for a given input.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Returns {@code true} if this matches {@code t}, {@code false} otherwise.
 */
 
/**
 * Returns a new matcher which returns {@code true} if both this and the given matcher return
 * {@code true}.
 */
 
/**
 * Returns a new matcher which returns {@code true} if either this or the given matcher return
 * {@code true}.
 */
 
","matches 
and 
or 
",,,,,3,99
AbstractMatcher.java,20,64,0.3125,"
 * Implements {@code and()} and {@code or()}.
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,3,85
Matchers.java,38,287,0.13240418118466898,"
 * Matcher implementations. Supports matching classes and methods.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Returns a matcher which matches any input.
 */
 
/**
 * Inverts the given matcher.
 */
 
/**
 * Returns a matcher which matches elements (methods, classes, etc.) with a given annotation.
 */
 
/**
 * Returns a matcher which matches elements (methods, classes, etc.) with a given annotation.
 */
 
/**
 * Returns a matcher which matches subclasses of the given type (as well as the given type).
 */
 
/**
 * Returns a matcher which matches objects equal to the given object.
 */
 
/**
 * Returns a matcher which matches only the given object.
 */
 
/**
 * Returns a matcher which matches classes in the given package. Packages are specific to their
 * classloader, so classes with the same package name may not have the same package at runtime.
 */
 
/**
 * Returns a matcher which matches classes in the given package and its subpackages. Unlike {@link
 * #inPackage(Package) inPackage()}, this matches classes from any classloader.
 *
 * @since 2.0
 */
 
/**
 * Returns a matcher which matches methods with matching return types.
 */
 
","{
    return ANY;
} 
{
    return new Not<T>(p);
} 
{
    return new AnnotatedWithType(annotationType);
} 
{
    return new AnnotatedWith(annotation);
} 
{
    return new SubclassesOf(superclass);
} 
{
    return new Only(value);
} 
{
    return new IdenticalTo(value);
} 
{
    return new InPackage(targetPackage);
} 
{
    return new InSubpackage(targetPackageName);
} 
{
    return new Returns(returnType);
} 
",,,,,3,106
ElementVisitor.java,27,75,0.36,"
 * Visit elements.
 *
 * @param <V> any type to be returned by the visit method. Use {@link Void} with {@code return null}
 *     if no return type is needed.
 * @since 2.0
 ","/**
 * Visit a mapping from a key (type and optional annotation) to the strategy for getting instances
 * of the type.
 */
 
/**
 * Visit a registration of interceptors for matching methods of matching classes.
 */
 
/**
 * Visit a registration of a scope annotation with the scope that implements it.
 */
 
/**
 * Visit a registration of type converters for matching target types.
 */
 
/**
 * Visit a request to inject the instance fields and methods of an instance.
 */
 
/**
 * Visit a request to inject the static fields and methods of type.
 */
 
/**
 * Visit a lookup of the provider for a type.
 */
 
/**
 * Visit a lookup of the members injector.
 */
 
/**
 * Visit an error message and the context in which it occured.
 */
 
/**
 * Visit a collection of configuration elements for a {@linkplain com.google.inject.PrivateBinder
 * private binder}.
 */
 
/**
 * Visit an injectable type listener binding.
 */
 
/**
 * Visit a provision listener binding.
 *
 * @since 4.0
 */
 
/**
 * Visit a require explicit bindings command.
 *
 * @since 3.0
 */
 
/**
 * Visit a disable circular proxies command.
 *
 * @since 3.0
 */
 
/**
 * Visit a require explicit {@literal @}{@link Inject} command.
 *
 * @since 4.0
 */
 
/**
 * Visit a require exact binding annotations command.
 *
 * @since 4.0
 */
 
/**
 * Visits a {@link Binder#scanModulesForAnnotatedMethods} command.
 *
 * @since 4.0
 */
 
","visit 
visit 
visit 
visit 
visit 
visit 
visit 
visit 
visit 
visit 
visit 
visit 
visit 
visit 
visit 
visit 
visit 
",,,,,5,164
Message.java,45,76,0.5921052631578947,"
 * An error message and the context in which it occured. Messages are usually created internally by
 * Guice and its extensions. Messages can be created explicitly in a module using {@link
 * com.google.inject.Binder#addError(Throwable) addError()} statements:
 *
 * <pre>
 *     try {
 *       bindPropertiesFromFile();
 *     } catch (IOException e) {
 *       addError(e);
 *     }</pre>
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * @since 2.0
 */
 
/**
 * Gets the error message text.
 */
 
/**
 * @since 2.0
 */
 
/**
 * Returns the throwable that caused this message, or {@code null} if this message was not caused
 * by a throwable.
 *
 * @since 2.0
 */
 
/**
 * @since 2.0
 */
 
/**
 * When serialized, we eagerly convert sources to strings. This hurts our formatting, but it
 * guarantees that the receiving end will be able to read the message.
 */
 
","{
    return sources;
} 
{
    return message;
} 
{
    return visitor.visit(this);
} 
{
    return cause;
} 
{
    binder.withSource(getSource()).addError(this);
} 
{
    Object[] sourcesAsStrings = sources.toArray();
    for (int i = 0; i < sourcesAsStrings.length; i++) {
        sourcesAsStrings[i] = Errors.convert(sourcesAsStrings[i]).toString();
    }
    return new Message(ImmutableList.copyOf(sourcesAsStrings), message, cause);
} 
","/**
 * @since 2.0
 */
 
/**
 * @since 4.0
 */
 
","{
    this.sources = ImmutableList.copyOf(sources);
    this.message = checkNotNull(message, ""message"");
    this.cause = cause;
} 
{
    this(ImmutableList.of(), message, cause);
} 
",,,12,412
TypeEncounter.java,86,21,4.095238095238095,"
 * Context of an injectable type encounter. Enables reporting errors, registering injection
 * listeners and binding method interceptors for injectable type {@code I}. It is an error to use an
 * encounter after the {@link TypeListener#hear(TypeLiteral, TypeEncounter) hear()} method has
 * returned.
 *
 * @param <I> the injectable type encountered
 * @since 2.0
 ","/**
 * Records an error message for type {@code I} which will be presented to the user at a later
 * time. Unlike throwing an exception, this enable us to continue configuring the Injector and
 * discover more errors. Uses {@link String#format(String, Object[])} to insert the arguments into
 * the message.
 */
 
/**
 * Records an exception for type {@code I}, the full details of which will be logged, and the
 * message of which will be presented to the user at a later time. If your type listener calls
 * something that you worry may fail, you should catch the exception and pass it to this method.
 */
 
/**
 * Records an error message to be presented to the user at a later time.
 */
 
/**
 * Returns the provider used to obtain instances for the given injection key. The returned
 * provider will not be valid until the injector has been created. The provider will throw an
 * {@code IllegalStateException} if you try to use it beforehand.
 */
 
/**
 * Returns the provider used to obtain instances for the given injection type. The returned
 * provider will not be valid until the injector has been created. The provider will throw an
 * {@code IllegalStateException} if you try to use it beforehand.
 */
 
/**
 * Returns the members injector used to inject dependencies into methods and fields on instances
 * of the given type {@code T}. The returned members injector will not be valid until the main
 * injector has been created. The members injector will throw an {@code IllegalStateException} if
 * you try to use it beforehand.
 *
 * @param typeLiteral type to get members injector for
 */
 
/**
 * Returns the members injector used to inject dependencies into methods and fields on instances
 * of the given type {@code T}. The returned members injector will not be valid until the main
 * injector has been created. The members injector will throw an {@code IllegalStateException} if
 * you try to use it beforehand.
 *
 * @param type type to get members injector for
 */
 
/**
 * Registers a members injector for type {@code I}. Guice will use the members injector after its
 * performed its own injections on an instance of {@code I}.
 */
 
/**
 * Registers an injection listener for type {@code I}. Guice will notify the listener after all
 * injections have been performed on an instance of {@code I}.
 */
 
/**
 * Binds method interceptor[s] to methods matched in type {@code I} and its supertypes. A method
 * is eligible for interception if:
 *
 * <ul>
 * <li>Guice created the instance the method is on
 * <li>Neither the enclosing type nor the method is final
 * <li>And the method is package-private or more accessible
 * </ul>
 *
 * @param methodMatcher matches methods the interceptor should apply to. For example: {@code
 *     annotatedWith(Transactional.class)}.
 * @param interceptors to bind
 */
 
","addError 
addError 
addError 
getProvider 
getProvider 
getMembersInjector 
getMembersInjector 
register 
register 
bindInterceptor 
",,,,,7,351
Element.java,17,69,0.2463768115942029,"
 * A core component of a module or injector.
 *
 * <p>The elements of a module can be inspected, validated and rewritten. Use {@link
 * Elements#getElements(com.google.inject.Module[]) Elements.getElements()} to read the elements
 * from a module, and {@link Elements#getModule(Iterable) Elements.getModule()} to rewrite them.
 * This can be used for static analysis and generation of Guice modules.
 *
 * <p>The elements of an injector can be inspected and exercised. Use {@link
 * com.google.inject.Injector#getBindings Injector.getBindings()} to reflect on Guice injectors.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @author crazybob@google.com (Bob Lee)
 * @since 2.0
 ","/**
 * Returns an arbitrary object containing information about the ""place"" where this element was
 * configured. Used by Guice in the production of descriptive error messages.
 *
 * <p>Tools might specially handle types they know about; {@code StackTraceElement} is a good
 * example. Tools should simply call {@code toString()} on the source object if the type is
 * unfamiliar.
 */
 
/**
 * Accepts an element visitor. Invokes the visitor method specific to this element's type.
 *
 * @param visitor to call back on
 */
 
/**
 * Writes this module element to the given binder (optional operation).
 *
 * @param binder to apply configuration element to
 * @throws UnsupportedOperationException if the {@code applyTo} method is not supported by this
 *     element.
 */
 
","getSource 
acceptVisitor 
applyTo 
",,,,,13,659
InterceptorBinding.java,31,50,0.62,"
 * Registration of interceptors for matching methods of matching classes. Instances are created
 * explicitly in a module using {@link com.google.inject.Binder#bindInterceptor( Matcher, Matcher,
 * MethodInterceptor[]) bindInterceptor()} statements:
 *
 * <pre>
 *     bindInterceptor(Matchers.subclassesOf(MyAction.class),
 *         Matchers.annotatedWith(Transactional.class),
 *         new MyTransactionInterceptor());</pre>
 *
 * or from an injectable type listener using {@link TypeEncounter#bindInterceptor(Matcher,
 * org.aopalliance.intercept.MethodInterceptor[]) TypeEncounter.bindInterceptor()}.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ",,,,,,,14,647
ModuleSource.java,84,77,1.0909090909090908,"
 * Associated to a {@link Module module}, provides the module class name, the parent module {@link
 * ModuleSource source}, and the call stack that ends just before the module {@link
 * Module#configure(Binder) configure(Binder)} method invocation.
 ","/**
 * Returns the corresponding module class name.
 *
 * @see Class#getName()
 */
 
/**
 * Returns the chunk of call stack that starts from the parent module {@link
 * Module#configure(Binder) configure(Binder)} call and ends just before the module {@link
 * Module#configure(Binder) configure(Binder)} method invocation. The return array is non-empty
 * only if stack trace collection is on.
 */
 
/**
 * Returns the size of partial call stack if stack trace collection is on otherwise zero.
 */
 
/**
 * Creates and returns a child {@link ModuleSource} corresponding to the {@link Module module}.
 *
 * @param moduleClass the corresponding module
 * @param partialCallStack the chunk of call stack that starts from the parent module {@link
 *     Module#configure(Binder) configure(Binder)} call and ends just before the module {@link
 *     Module#configure(Binder) configure(Binder)} method invocation
 */
 
/**
 * Returns the parent module {@link ModuleSource source}.
 */
 
/**
 * Returns the class names of modules in this module source. The first element (index 0) is filled
 * by this object {@link #getModuleClassName()}. The second element is filled by the parent's
 * {@link #getModuleClassName()} and so on.
 */
 
/**
 * Returns the size of {@link ModuleSource ModuleSources} chain (all parents) that ends at this
 * object.
 */
 
/**
 * Returns the size of call stack that ends just before the module {@link Module#configure(Binder)
 * configure(Binder)} method invocation (see {@link #getStackTrace()}).
 */
 
/**
 * Returns the full call stack that ends just before the module {@link Module#configure(Binder)
 * configure(Binder)} method invocation. The return array is non-empty if stack trace collection
 * on.
 */
 
","{
    return moduleClassName;
} 
{
    return StackTraceElements.convertToStackTraceElement(partialCallStack);
} 
{
    return partialCallStack.length;
} 
{
    return new ModuleSource(this, moduleClass, partialCallStack);
} 
{
    return parent;
} 
{
    ImmutableList.Builder<String> classNames = ImmutableList.builder();
    ModuleSource current = this;
    while (current != null) {
        String className = current.moduleClassName;
        classNames.add(className);
        current = current.parent;
    }
    return classNames.build();
} 
{
    if (parent == null) {
        return 1;
    }
    return parent.size() + 1;
} 
{
    if (parent == null) {
        return partialCallStack.length;
    }
    return parent.getStackTraceSize() + partialCallStack.length;
} 
{
    int stackTraceSize = getStackTraceSize();
    StackTraceElement[] callStack = new StackTraceElement[stackTraceSize];
    int cursor = 0;
    ModuleSource current = this;
    while (current != null) {
        StackTraceElement[] chunk = StackTraceElements.convertToStackTraceElement(current.partialCallStack);
        int chunkSize = chunk.length;
        System.arraycopy(chunk, 0, callStack, cursor, chunkSize);
        current = current.parent;
        cursor = cursor + chunkSize;
    }
    return callStack;
} 
","/**
 * Creates a new {@link ModuleSource} with a {@literal null} parent.
 *
 * @param moduleClass the corresponding module
 * @param partialCallStack the chunk of call stack that starts from the parent module {@link
 *     Module#configure(Binder) configure(Binder)} call and ends just before the module {@link
 *     Module#configure(Binder) configure(Binder)} method invocation
 */
 
/**
 * Creates a new {@link ModuleSource} Object.
 *
 * @param parent the parent module {@link ModuleSource source}
 * @param moduleClass the corresponding module
 * @param partialCallStack the chunk of call stack that starts from the parent module {@link
 *     Module#configure(Binder) configure(Binder)} call and ends just before the module {@link
 *     Module#configure(Binder) configure(Binder)} method invocation
 */
 
","{
    this(null, moduleClass, partialCallStack);
} 
{
    Preconditions.checkNotNull(moduleClass, ""module cannot be null."");
    Preconditions.checkNotNull(partialCallStack, ""partialCallStack cannot be null."");
    this.parent = parent;
    this.moduleClassName = moduleClass.getName();
    this.partialCallStack = StackTraceElements.convertToInMemoryStackTraceElement(partialCallStack);
} 
","/**
 * The class name of module that this {@link ModuleSource} associated to.
 */
 
/**
 * The parent {@link ModuleSource module source}.
 */
 
/**
 * The chunk of call stack that starts from the parent module {@link Module#configure(Binder)
 * configure(Binder)} call and ends just before the module {@link Module#configure(Binder)
 * configure(Binder)} method invocation. For a module without a parent module the chunk starts
 * from the bottom of call stack. The array is non-empty if stack trace collection is on.
 */
 
","Field moduleClassName
Field parent
Field partialCallStack
",3,244
PrivateElements.java,38,11,3.4545454545454546,"
 * A private collection of elements that are hidden from the enclosing injector or module by
 * default. See {@link com.google.inject.PrivateModule PrivateModule} for details.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns the configuration information in this private environment.
 */
 
/**
 * Returns the child injector that hosts these private elements, or null if the elements haven't
 * been used to create an injector.
 */
 
/**
 * Returns the unique exposed keys for these private elements.
 */
 
/**
 * Returns an arbitrary object containing information about the ""place"" where this key was
 * exposed. Used by Guice in the production of descriptive error messages.
 *
 * <p>Tools might specially handle types they know about; {@code StackTraceElement} is a good
 * example. Tools should simply call {@code toString()} on the source object if the type is
 * unfamiliar.
 *
 * @param key one of the keys exposed by this module.
 */
 
","getElements 
getInjector 
getExposedKeys 
getExposedSource 
",,,,,5,233
ProvidesMethodBinding.java,31,11,2.8181818181818183,"
 * An {@literal @}{@link Provides} binding or binding produced by a {@link
 * ModuleAnnotatedMethodScanner}.
 *
 * @since 4.0
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Returns the method this binding uses.
 */
 
/**
 * Returns the instance of the object the method is defined in.
 */
 
/**
 * Returns the key of the binding.
 */
 
/**
 * Returns the annotation that caused this binding to be created. For {@code @Provides} methods,
 * this is an instance of the {@code @Provides} annotation. For bindings from {@link
 * ModuleAnnotatedMethodScanner}, this is the annotation that caused the scanner to produce the
 * binding.
 */
 
","getMethod 
getEnclosingInstance 
getKey 
getAnnotation 
",,,,,5,158
InjectionListener.java,28,4,7.0,"
 * Listens for injections into instances of type {@code I}. Useful for performing further
 * injections, post-injection initialization, and more.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Invoked by Guice after it injects the fields and methods of instance.
 *
 * @param injectee instance that Guice injected dependencies into
 */
 
","afterInjection 
",,,,,6,242
ProviderWithDependencies.java,21,4,5.25,"
 * A provider with dependencies on other injected types. If a {@link Provider} has dependencies that
 * aren't specified in injections, this interface should be used to expose all dependencies.
 *
 * @since 2.0
 ",,,,,,,4,204
ConvertedConstantBinding.java,33,11,3.0,"
 * A binding created from converting a bound instance to a new type. The source binding has the same
 * binding annotation but a different type.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns the converted value.
 */
 
/**
 * Returns the type converter binding used to convert the constant.
 *
 * @since 3.0
 */
 
/**
 * Returns the key for the source binding. That binding can be retrieved from an injector using
 * {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
 */
 
/**
 * Returns a singleton set containing only the converted key.
 */
 
","getValue 
getTypeConverterBinding 
getSourceKey 
getDependencies 
",,,,,5,202
ProviderKeyBinding.java,27,6,4.5,"
 * A binding to a provider key. To resolve injections, the provider key is first resolved, then that
 * provider's {@code get} method is invoked.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns the key used to resolve the provider's binding. That binding can be retrieved from an
 * injector using {@link com.google.inject.Injector#getBinding(Key)
 * Injector.getBinding(providerKey)}
 */
 
","getProviderKey 
",,,,,5,203
TypeConverter.java,22,5,4.4,"
 * Converts constant string values to a different type.
 *
 * @author crazybob@google.com (Bob Lee)
 * @since 2.0
 ","/**
 * Converts a string value. Throws an exception if a conversion error occurs.
 */
 
","convert 
",,,,,4,107
ProvisionListener.java,83,13,6.384615384615385,"
 * Listens for provisioning of objects. Useful for gathering timing information about provisioning,
 * post-provision initialization, and more.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 4.0
 |
   * Encapsulates a single act of provisioning.
   *
   * @since 4.0
   ","/**
 * Invoked by Guice when an object requires provisioning. Provisioning occurs when Guice locates
 * and injects the dependencies for a binding. For types bound to a Provider, provisioning
 * encapsulates the {@link Provider#get} method. For toInstance or constant bindings, provisioning
 * encapsulates the injecting of {@literal @}{@code Inject}ed fields or methods. For other types,
 * provisioning encapsulates the construction of the object. If a type is bound within a {@link
 * Scope}, provisioning depends on the scope. Types bound in Singleton scope will only be
 * provisioned once. Types bound in no scope will be provisioned every time they are injected.
 * Other scopes define their own behavior for provisioning.
 *
 * <p>To perform the provision, call {@link ProvisionInvocation#provision()}. If you do not
 * explicitly call provision, it will be automatically done after this method returns. It is an
 * error to call provision more than once.
 */
 
/**
 * Returns the Binding this is provisioning.
 *
 * <p>You must not call {@link Provider#get()} on the provider returned by {@link
 * Binding#getProvider}, otherwise you will get confusing error messages.
 */
 
/**
 * Performs the provision, returning the object provisioned.
 */
 
/**
 * Returns the dependency chain that led to this object being provisioned.
 *
 * @deprecated This method is planned for removal in Guice 4.4.  Some use cases can be replaced
 * by inferring the current chain via ThreadLocals in the listener, other use cases can use
 * the static dependency graph.  For example,
 * <pre>{@code
 *   bindListener(Matchers.any(), new MyListener());
 *   ...
 *
 *   private static final class MyListener implements ProvisionListener {
 *     private final ThreadLocal<ArrayDeque<Binding<?>>> bindingStack =
 *         new ThreadLocal<ArrayDeque<Binding<?>>>() {
 *           {@literal @}Override protected ArrayDeque<Binding<?>> initialValue() {
 *             return new ArrayDeque<>();
 *           }
 *         };
 *     {@literal @}Override public <T> void onProvision(ProvisionInvocation<T> invocation) {
 *       bindingStack.get().push(invocation.getBinding());
 *       try {
 *         invocation.provision();
 *       } finally {
 *         bindingStack.get().pop();
 *       }
 *       // Inspect the binding stack...
 *     }
 *   }
 *
 * }<pre>
 *
 * In this example the bindingStack thread local will contain a data structure that is very
 * similar to the data returned by this list.  The main differences are that linked keys are
 * not in the stack, but such edges do exist in the static dependency graph (inspectable via
 * {@link HasDependencies#getDependencies()}), so you could infer some of the missing edges..
 */
 
","onProvision 
getBinding 
provision 
getDependencyChain 
",,,,,9,260
TypeListener.java,37,5,7.4,"
 * Listens for Guice to encounter injectable types. If a given type has its constructor injected in
 * one situation but only its methods and fields injected in another, Guice will notify this
 * listener once.
 *
 * <p>Useful for extra type checking, {@linkplain TypeEncounter#register(InjectionListener)
 * registering injection listeners}, and {@linkplain TypeEncounter#bindInterceptor(
 * com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[]) binding method
 * interceptors}.
 *
 * @since 2.0
 ","/**
 * Invoked when Guice encounters a new type eligible for constructor or members injection. Called
 * during injector creation (or afterwards if Guice encounters a type at run time and creates a
 * JIT binding).
 *
 * @param type encountered by Guice
 * @param encounter context of this encounter, enables reporting errors, registering injection
 *     listeners and binding method interceptors for {@code type}.
 * @param <I> the injectable type
 */
 
","hear 
",,,,,10,506
DefaultBindingTargetVisitor.java,26,44,0.5909090909090909,"
 * No-op visitor for subclassing. All interface methods simply delegate to {@link
 * #visitOther(Binding)}, returning its result.
 *
 * @param <V> any type to be returned by the visit method. Use {@link Void} with {@code return null}
 *     if no return type is needed.
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Default visit implementation. Returns {@code null}.
 */
 
","{
    return null;
} 
",,,,,7,320
MembersInjectorLookup.java,53,70,0.7571428571428571,"
 * A lookup of the members injector for a type. Lookups are created explicitly in a module using
 * {@link com.google.inject.Binder#getMembersInjector(Class) getMembersInjector()} statements:
 *
 * <pre>
 *     MembersInjector&lt;PaymentService&gt; membersInjector
 *         = getMembersInjector(PaymentService.class);</pre>
 *
 * @author crazybob@google.com (Bob Lee)
 * @since 2.0
 ","/**
 * Gets the type containing the members to be injected.
 */
 
/**
 * Sets the actual members injector.
 *
 * @throws IllegalStateException if the delegate is already set
 */
 
/**
 * Returns the delegate members injector, or {@code null} if it has not yet been initialized. The
 * delegate will be initialized when this element is processed, or otherwise used to create an
 * injector.
 */
 
/**
 * Returns the instance methods and fields that will be injected to fulfill this request.
 *
 * @return a possibly empty set of injection points. The set has a specified iteration order. All
 *     fields are returned and then all methods. Within the fields, supertype fields are returned
 *     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 * @throws ConfigurationException if there is a malformed injection point on the class of {@code
 *     instance}, such as a field with multiple binding annotations. The exception's {@link
 *     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
 *     the valid injection points.
 */
 
/**
 * Returns the looked up members injector. The result is not valid until this lookup has been
 * initialized, which usually happens when the injector is created. The members injector will
 * throw an {@code IllegalStateException} if you try to use it beforehand.
 */
 
","{
    return type;
} 
{
    checkState(this.delegate == null, ""delegate already initialized"");
    this.delegate = checkNotNull(delegate, ""delegate"");
} 
{
    return delegate;
} 
{
    return InjectionPoint.forInstanceMethodsAndFields(type);
} 
{
    return new MembersInjector<T>() {

        @Override
        public void injectMembers(T instance) {
            MembersInjector<T> local = delegate;
            if (local == null) {
                throw new IllegalStateException(""This MembersInjector cannot be used until the Injector has been created."");
            }
            local.injectMembers(instance);
        }

        @Override
        public String toString() {
            return ""MembersInjector<"" + type + "">"";
        }
    };
} 
",,,,,9,367
ProviderBinding.java,27,7,3.857142857142857,"
 * A binding to a {@link Provider} that delegates to the binding for the provided type. This binding
 * is used whenever a {@code Provider<T>} is injected (as opposed to injecting {@code T} directly).
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns the key whose binding is used to {@link Provider#get provide instances}. That binding
 * can be retrieved from an injector using {@link com.google.inject.Injector#getBinding(Key)
 * Injector.getBinding(providedKey)}
 */
 
","getProvidedKey 
",,,,,5,258
UntargettedBinding.java,22,3,7.333333333333333,"
 * An untargetted binding. This binding indicates that the injector should use its implicit binding
 * strategies to resolve injections.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ",,,,,,,5,194
ScopeBinding.java,27,43,0.627906976744186,"
 * Registration of a scope annotation with the scope that implements it. Instances are created
 * explicitly in a module using {@link com.google.inject.Binder#bindScope(Class, Scope) bindScope()}
 * statements:
 *
 * <pre>
 *     Scope recordScope = new RecordScope();
 *     bindScope(RecordScoped.class, new RecordScope());</pre>
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ",,,,,,,10,379
DependencyAndSource.java,36,37,0.972972972972973,"
 * A combination of a {@link Dependency} and the {@link Binding#getSource() source} where the
 * dependency was bound.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 4.0
 * @deprecated The only use of this object is for {@link
 *     ProvisionListener.ProvisionInvocation#getDependencyChain()} which is also deprecated. This
 *     object will also be removed in Guice 4.4.
 ","/**
 * Returns the Dependency, if one exists. For anything that can be referenced by {@link
 * Injector#getBinding}, a dependency exists. A dependency will not exist (and this will return
 * null) for types initialized with {@link Binder#requestInjection} or {@link
 * Injector#injectMembers(Object)}, nor will it exist for objects injected into Providers bound
 * with LinkedBindingBuilder#toProvider(Provider).
 */
 
/**
 * Returns a string describing where this dependency was bound. If the binding was just-in-time,
 * there is no valid binding source, so this describes the class in question.
 */
 
","{
    return dependency;
} 
{
    if (source instanceof Class) {
        return StackTraceElements.forType((Class) source).toString();
    } else if (source instanceof Member) {
        return StackTraceElements.forMember((Member) source).toString();
    } else {
        return source.toString();
    }
} 
",,,,,8,366
RequireExactBindingAnnotationsOption.java,21,21,1.0,"
 * A request to require exact binding annotations.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 4.0
 ",,,,,,,4,102
DisableCircularProxiesOption.java,21,21,1.0,"
 * A request to disable circular proxies.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 3.0
 ",,,,,,,4,93
InjectionPoint.java,220,556,0.39568345323741005,"
 * A constructor, field or method that can receive injections. Typically this is a member with the
 * {@literal @}{@link Inject} annotation. For non-private, no argument constructors, the member may
 * omit the annotation.
 *
 * @author crazybob@google.com (Bob Lee)
 * @since 2.0
 | Node in the doubly-linked list of injectable members (fields and methods). | Linked list of injectable members. | Position in type hierarchy. |
   * Keeps track of injectable methods so we can remove methods that get overridden in O(1) time.
   * Uses our position in the type hierarchy to perform optimizations.
   | A method signature. Used to handle method overridding. ","/**
 * Returns the injected constructor, field, or method.
 */
 
/**
 * Returns the dependencies for this injection point. If the injection point is for a method or
 * constructor, the dependencies will correspond to that member's parameters. Field injection
 * points always have a single dependency for the field itself.
 *
 * @return a possibly-empty list
 */
 
/**
 * Returns true if this injection point shall be skipped if the injector cannot resolve bindings
 * for all required dependencies. Both explicit bindings (as specified in a module), and implicit
 * bindings ({@literal @}{@link com.google.inject.ImplementedBy ImplementedBy}, default
 * constructors etc.) may be used to satisfy optional injection points.
 */
 
/**
 * Returns true if the element is annotated with {@literal @}{@link Toolable}.
 *
 * @since 3.0
 */
 
/**
 * Returns the generic type that defines this injection point. If the member exists on a
 * parameterized type, the result will include more type information than the member's {@link
 * Member#getDeclaringClass() raw declaring class}.
 *
 * @since 3.0
 */
 
/**
 * Returns a new injection point for the specified constructor. If the declaring type of {@code
 * constructor} is parameterized (such as {@code List<T>}), prefer the overload that includes a
 * type literal.
 *
 * @param constructor any single constructor present on {@code type}.
 * @since 3.0
 */
 
/**
 * Returns a new injection point for the specified constructor of {@code type}.
 *
 * @param constructor any single constructor present on {@code type}.
 * @param type the concrete type that defines {@code constructor}.
 * @since 3.0
 */
 
/**
 * Returns a new injection point for the injectable constructor of {@code type}.
 *
 * @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},
 *     or a no-arguments constructor that is not private.
 * @throws ConfigurationException if there is no injectable constructor, more than one injectable
 *     constructor, or if parameters of the injectable constructor are malformed, such as a
 *     parameter with multiple binding annotations.
 */
 
/**
 * Returns a new injection point for the injectable constructor of {@code type}.
 *
 * @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},
 *     or a no-arguments constructor that is not private.
 * @throws ConfigurationException if there is no injectable constructor, more than one injectable
 *     constructor, or if parameters of the injectable constructor are malformed, such as a
 *     parameter with multiple binding annotations.
 */
 
/**
 * Returns a new injection point for the specified method of {@code type}. This is useful for
 * extensions that need to build dependency graphs from arbitrary methods.
 *
 * @param method any single method present on {@code type}.
 * @param type the concrete type that defines {@code method}.
 * @since 4.0
 */
 
/**
 * Returns all static method and field injection points on {@code type}.
 *
 * @return a possibly empty set of injection points. The set has a specified iteration order. All
 *     fields are returned and then all methods. Within the fields, supertype fields are returned
 *     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
 *     a field with multiple binding annotations. The exception's {@link
 *     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
 *     the valid injection points.
 */
 
/**
 * Returns all static method and field injection points on {@code type}.
 *
 * @return a possibly empty set of injection points. The set has a specified iteration order. All
 *     fields are returned and then all methods. Within the fields, supertype fields are returned
 *     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
 *     a field with multiple binding annotations. The exception's {@link
 *     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
 *     the valid injection points.
 */
 
/**
 * Returns all instance method and field injection points on {@code type}.
 *
 * @return a possibly empty set of injection points. The set has a specified iteration order. All
 *     fields are returned and then all methods. Within the fields, supertype fields are returned
 *     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
 *     a field with multiple binding annotations. The exception's {@link
 *     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
 *     the valid injection points.
 */
 
/**
 * Returns all instance method and field injection points on {@code type}.
 *
 * @return a possibly empty set of injection points. The set has a specified iteration order. All
 *     fields are returned and then all methods. Within the fields, supertype fields are returned
 *     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
 *     a field with multiple binding annotations. The exception's {@link
 *     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
 *     the valid injection points.
 */
 
/**
 * Returns true if the binding annotation is in the wrong place.
 */
 
/**
 * Removes a method overridden by the given method, if present. In order to remain backwards
 * compatible with prior Guice versions, this will *not* remove overridden methods if
 * 'alwaysRemove' is false and the overridden signature was annotated with a
 * com.google.inject.Inject.
 *
 * @param method The method used to determine what is overridden and should be removed.
 * @param alwaysRemove true if overridden methods should be removed even if they were
 *     guice @Inject
 * @param injectableMethod if this method overrode any guice @Inject methods, {@link
 *     InjectableMethod#overrodeGuiceInject} is set to true
 */
 
/**
 * Adds the given method to the list of injection points. Keeps track of it in this index in
 * case it gets overridden.
 */
 
/**
 * Returns an ordered, immutable set of injection points for the given type. Members in
 * superclasses come before members in subclasses. Within a class, fields come before methods.
 * Overridden methods are filtered out. The order of fields/methods within a class is consistent
 * but undefined.
 *
 * @param statics true is this method should return static members, false for instance members
 * @param errors used to record errors
 */
 
/**
 * Returns true if the method is eligible to be injected. This is different than {@link
 * #isValidMethod}, because ineligibility will not drop a method from being injected if a
 * superclass was eligible & valid. Bridge & synthetic methods are excluded from eligibility for
 * two reasons:
 *
 * <p>Prior to Java8, javac would generate these methods in subclasses without annotations, which
 * means this would accidentally stop injecting a method annotated with {@link
 * javax.inject.Inject}, since the spec says to stop injecting if a subclass isn't annotated with
 * it.
 *
 * <p>Starting at Java8, javac copies the annotations to the generated subclass method, except it
 * leaves out the generic types. If this considered it a valid injectable method, this would eject
 * the parent's overridden method that had the proper generic types, and would use invalid
 * injectable parameters as a result.
 *
 * <p>The fix for both is simply to ignore these synthetic bridge methods.
 */
 
/**
 * Returns true if a overrides b. Assumes signatures of a and b are the same and a's declaring
 * class is a subclass of b's declaring class.
 */
 
","{
    // TODO: Don't expose the original member (which probably has setAccessible(true)).
    return member;
} 
{
    return dependencies;
} 
{
    return optional;
} 
{
    return ((AnnotatedElement) member).isAnnotationPresent(Toolable.class);
} 
{
    return declaringType;
} 
{
    return new InjectionPoint(TypeLiteral.get(constructor.getDeclaringClass()), constructor);
} 
{
    if (type.getRawType() != constructor.getDeclaringClass()) {
        new Errors(type).constructorNotDefinedByType(constructor, type).throwConfigurationExceptionIfErrorsExist();
    }
    return new InjectionPoint(type, constructor);
} 
{
    Class<?> rawType = getRawType(type.getType());
    Errors errors = new Errors(rawType);
    Constructor<?> injectableConstructor = null;
    for (Constructor<?> constructor : rawType.getDeclaredConstructors()) {
        boolean optional;
        Inject guiceInject = constructor.getAnnotation(Inject.class);
        if (guiceInject == null) {
            javax.inject.Inject javaxInject = constructor.getAnnotation(javax.inject.Inject.class);
            if (javaxInject == null) {
                continue;
            }
            optional = false;
        } else {
            optional = guiceInject.optional();
        }
        if (optional) {
            errors.optionalConstructor(constructor);
        }
        if (injectableConstructor != null) {
            errors.tooManyConstructors(rawType);
        }
        injectableConstructor = constructor;
        checkForMisplacedBindingAnnotations(injectableConstructor, errors);
    }
    errors.throwConfigurationExceptionIfErrorsExist();
    if (injectableConstructor != null) {
        return new InjectionPoint(type, injectableConstructor);
    }
    // If no annotated constructor is found, look for a no-arg constructor instead.
    try {
        Constructor<?> noArgConstructor = rawType.getDeclaredConstructor();
        // Disallow private constructors on non-private classes (unless they have @Inject)
        if (Modifier.isPrivate(noArgConstructor.getModifiers()) && !Modifier.isPrivate(rawType.getModifiers())) {
            errors.missingConstructor(type);
            throw new ConfigurationException(errors.getMessages());
        }
        checkForMisplacedBindingAnnotations(noArgConstructor, errors);
        return new InjectionPoint(type, noArgConstructor);
    } catch (NoSuchMethodException e) {
        errors.missingConstructor(type);
        throw new ConfigurationException(errors.getMessages());
    }
} 
{
    return forConstructorOf(TypeLiteral.get(type));
} 
{
    return new InjectionPoint(type, method, false);
} 
{
    Errors errors = new Errors();
    Set<InjectionPoint> result;
    if (type.getRawType().isInterface()) {
        errors.staticInjectionOnInterface(type.getRawType());
        result = null;
    } else {
        result = getInjectionPoints(type, true, errors);
    }
    if (errors.hasErrors()) {
        throw new ConfigurationException(errors.getMessages()).withPartialValue(result);
    }
    return result;
} 
{
    return forStaticMethodsAndFields(TypeLiteral.get(type));
} 
{
    Errors errors = new Errors();
    Set<InjectionPoint> result = getInjectionPoints(type, false, errors);
    if (errors.hasErrors()) {
        throw new ConfigurationException(errors.getMessages()).withPartialValue(result);
    }
    return result;
} 
{
    return forInstanceMethodsAndFields(TypeLiteral.get(type));
} 
{
    Annotation misplacedBindingAnnotation = Annotations.findBindingAnnotation(errors, member, ((AnnotatedElement) member).getAnnotations());
    if (misplacedBindingAnnotation == null) {
        return false;
    }
    // don't warn about misplaced binding annotations on methods when there's a field with the same
    // name. In Scala, fields always get accessor methods (that we need to ignore). See bug 242.
    if (member instanceof Method) {
        try {
            if (member.getDeclaringClass().getDeclaredField(member.getName()) != null) {
                return false;
            }
        } catch (NoSuchFieldException ignore) {
        }
    }
    errors.misplacedBindingAnnotation(member, misplacedBindingAnnotation);
    return true;
} 
{
    if (position == Position.TOP) {
        // If we're at the top of the hierarchy, there's nothing to override.
        return false;
    }
    if (bySignature == null) {
        // We encountered a method in a subclass. Time to index the
        // methods in the parent class.
        bySignature = new HashMap<>();
        for (InjectableMember member = injectableMembers.head; member != null; member = member.next) {
            if (!(member instanceof InjectableMethod)) {
                continue;
            }
            InjectableMethod im = (InjectableMethod) member;
            if (im.isFinal()) {
                continue;
            }
            List<InjectableMethod> methods = new ArrayList<>();
            methods.add(im);
            bySignature.put(new Signature(im.method), methods);
        }
    }
    lastMethod = method;
    Signature signature = lastSignature = new Signature(method);
    List<InjectableMethod> methods = bySignature.get(signature);
    boolean removed = false;
    if (methods != null) {
        for (Iterator<InjectableMethod> iterator = methods.iterator(); iterator.hasNext(); ) {
            InjectableMethod possiblyOverridden = iterator.next();
            if (overrides(method, possiblyOverridden.method)) {
                boolean wasGuiceInject = !possiblyOverridden.jsr330 || possiblyOverridden.overrodeGuiceInject;
                if (injectableMethod != null) {
                    injectableMethod.overrodeGuiceInject = wasGuiceInject;
                }
                // Only actually remove the methods if we want to force
                // remove or if the signature never specified @com.google.inject.Inject
                // somewhere.
                if (alwaysRemove || !wasGuiceInject) {
                    removed = true;
                    iterator.remove();
                    injectableMembers.remove(possiblyOverridden);
                }
            }
        }
    }
    return removed;
} 
{
    injectableMembers.add(injectableMethod);
    if (position == Position.BOTTOM || injectableMethod.isFinal()) {
        // This method can't be overridden, so there's no need to index it.
        return;
    }
    if (bySignature != null) {
        // Try to reuse the signature we created during removal
        @SuppressWarnings(""ReferenceEquality"")
        Signature signature = injectableMethod.method == lastMethod ? lastSignature : new Signature(injectableMethod.method);
        bySignature.computeIfAbsent(signature, k -> new ArrayList<>()).add(injectableMethod);
    }
} 
{
    InjectableMembers injectableMembers = new InjectableMembers();
    OverrideIndex overrideIndex = null;
    List<TypeLiteral<?>> hierarchy = hierarchyFor(type);
    int topIndex = hierarchy.size() - 1;
    for (int i = topIndex; i >= 0; i--) {
        if (overrideIndex != null && i < topIndex) {
            // Knowing the position within the hierarchy helps us make optimizations.
            if (i == 0) {
                overrideIndex.position = Position.BOTTOM;
            } else {
                overrideIndex.position = Position.MIDDLE;
            }
        }
        TypeLiteral<?> current = hierarchy.get(i);
        for (Field field : getDeclaredFields(current)) {
            if (Modifier.isStatic(field.getModifiers()) == statics) {
                Annotation atInject = getAtInject(field);
                if (atInject != null) {
                    InjectableField injectableField = new InjectableField(current, field, atInject);
                    if (injectableField.jsr330 && Modifier.isFinal(field.getModifiers())) {
                        errors.cannotInjectFinalField(field);
                    }
                    injectableMembers.add(injectableField);
                }
            }
        }
        for (Method method : getDeclaredMethods(current)) {
            if (isEligibleForInjection(method, statics)) {
                Annotation atInject = getAtInject(method);
                if (atInject != null) {
                    InjectableMethod injectableMethod = new InjectableMethod(current, method, atInject);
                    if (checkForMisplacedBindingAnnotations(method, errors) || !isValidMethod(injectableMethod, errors)) {
                        if (overrideIndex != null) {
                            boolean removed = overrideIndex.removeIfOverriddenBy(method, false, injectableMethod);
                            if (removed) {
                                logger.log(Level.WARNING, ""Method: {0} is not a valid injectable method ("" + ""because it either has misplaced binding annotations "" + ""or specifies type parameters) but is overriding a method that is "" + ""valid. Because it is not valid, the method will not be injected. "" + ""To fix this, make the method a valid injectable method."", method);
                            }
                        }
                        continue;
                    }
                    if (statics) {
                        injectableMembers.add(injectableMethod);
                    } else {
                        if (overrideIndex == null) {
                            /*
                 * Creating the override index lazily means that the first type in the hierarchy
                 * with injectable methods (not necessarily the top most type) will be treated as
                 * the TOP position and will enjoy the same optimizations (no checks for overridden
                 * methods, etc.).
                 */
                            overrideIndex = new OverrideIndex(injectableMembers);
                        } else {
                            // Forcibly remove the overridden method, otherwise we'll inject
                            // it twice.
                            overrideIndex.removeIfOverriddenBy(method, true, injectableMethod);
                        }
                        overrideIndex.add(injectableMethod);
                    }
                } else {
                    if (overrideIndex != null) {
                        boolean removed = overrideIndex.removeIfOverriddenBy(method, false, null);
                        if (removed) {
                            logger.log(Level.WARNING, ""Method: {0} is not annotated with @Inject but "" + ""is overriding a method that is annotated with @javax.inject.Inject."" + ""Because it is not annotated with @Inject, the method will not be "" + ""injected. To fix this, annotate the method with @Inject."", method);
                        }
                    }
                }
            }
        }
    }
    if (injectableMembers.isEmpty()) {
        return Collections.emptySet();
    }
    ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder();
    for (InjectableMember im = injectableMembers.head; im != null; im = im.next) {
        try {
            builder.add(im.toInjectionPoint());
        } catch (ConfigurationException ignorable) {
            if (!im.optional) {
                errors.merge(ignorable.getErrorMessages());
            }
        }
    }
    return builder.build();
} 
{
    return Modifier.isStatic(method.getModifiers()) == statics && !method.isBridge() && !method.isSynthetic();
} 
{
    // See JLS section 8.4.8.1
    int modifiers = b.getModifiers();
    if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {
        return true;
    }
    if (Modifier.isPrivate(modifiers)) {
        return false;
    }
    // b must be package-private
    return a.getDeclaringClass().getPackage().equals(b.getDeclaringClass().getPackage());
} 
",,,"/**
 * true if this method overrode a method that was annotated with com.google.inject.Inject. used
 * to allow different override behavior for guice inject vs javax.inject.Inject
 */
 
","Field overrodeGuiceInject
",10,640
TypeConverterBinding.java,28,44,0.6363636363636364,"
 * Registration of type converters for matching target types. Instances are created explicitly in a
 * module using {@link com.google.inject.Binder#convertToTypes(Matcher, TypeConverter)
 * convertToTypes()} statements:
 *
 * <pre>
 *     convertToTypes(Matchers.only(TypeLiteral.get(DateTime.class)), new DateTimeConverter());
 * </pre>
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ",,,"/**
 * @since 3.0
 */
 
","{
    this.source = checkNotNull(source, ""source"");
    this.typeMatcher = checkNotNull(typeMatcher, ""typeMatcher"");
    this.typeConverter = checkNotNull(typeConverter, ""typeConverter"");
} 
",,,10,385
Elements.java,66,455,0.14505494505494507,"
 * Exposes elements of a module so they can be inspected, validated or {@link
 * Element#applyTo(Binder) rewritten}.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Records the elements executed by {@code modules}.
 */
 
/**
 * Records the elements executed by {@code modules}.
 */
 
/**
 * Records the elements executed by {@code modules}.
 */
 
/**
 * Records the elements executed by {@code modules}.
 */
 
/**
 * Returns the module composed of {@code elements}.
 */
 
/**
 * Applies all scanners to the modules we've installed. We skip certain PrivateModules because
 * store them in more than one Modules map and only want to process them through one of the
 * maps. (They're stored in both maps to prevent a module from being installed more than once.)
 */
 
/**
 * Removes the {@link #moduleSource} call stack from the beginning of current call stack. It
 * also removes the last two elements in order to make {@link #install(Module)} the last call in
 * the call stack.
 */
 
","{
    return getElements(Stage.DEVELOPMENT, Arrays.asList(modules));
} 
{
    return getElements(stage, Arrays.asList(modules));
} 
{
    return getElements(Stage.DEVELOPMENT, modules);
} 
{
    RecordingBinder binder = new RecordingBinder(stage);
    for (Module module : modules) {
        binder.install(module);
    }
    binder.scanForAnnotatedMethods();
    for (RecordingBinder child : binder.privateBinders) {
        child.scanForAnnotatedMethods();
    }
    // Free the memory consumed by the stack trace elements cache
    StackTraceElements.clearCache();
    return Collections.unmodifiableList(binder.elements);
} 
{
    return new ElementsAsModule(elements);
} 
{
    for (ModuleAnnotatedMethodScanner scanner : scanners) {
        // Note: we must iterate over a copy of the modules because calling install(..)
        // will mutate modules, otherwise causing a ConcurrentModificationException.
        for (Map.Entry<Module, ModuleInfo> entry : Maps.newLinkedHashMap(modules).entrySet()) {
            Module module = entry.getKey();
            ModuleInfo info = entry.getValue();
            if (info.skipScanning) {
                continue;
            }
            moduleSource = entry.getValue().moduleSource;
            try {
                info.binder.install(ProviderMethodsModule.forModule(module, scanner));
            } catch (RuntimeException e) {
                Collection<Message> messages = Errors.getMessagesFromThrowable(e);
                if (!messages.isEmpty()) {
                    elements.addAll(messages);
                } else {
                    addError(e);
                }
            }
        }
    }
    moduleSource = null;
} 
{
    int toSkip = 0;
    if (moduleSource != null) {
        toSkip = moduleSource.getStackTraceSize();
    }
    // -1 for skipping 'getModuleSource' and 'getElementSource' calls
    int chunkSize = callStack.length - toSkip - 1;
    StackTraceElement[] partialCallStack = new StackTraceElement[chunkSize];
    System.arraycopy(callStack, 1, partialCallStack, 0, chunkSize);
    return partialCallStack;
} 
","/**
 * Creates a recording binder that's backed by {@code prototype}.
 */
 
/**
 * Creates a private recording binder.
 */
 
","{
    checkArgument(source == null ^ sourceProvider == null);
    this.stage = prototype.stage;
    this.modules = prototype.modules;
    this.elements = prototype.elements;
    this.scanners = prototype.scanners;
    this.source = source;
    this.moduleSource = prototype.moduleSource;
    this.sourceProvider = sourceProvider;
    this.parent = prototype.parent;
    this.privateElements = prototype.privateElements;
    this.privateBinders = prototype.privateBinders;
} 
{
    this.stage = parent.stage;
    this.modules = Maps.newLinkedHashMap();
    this.scanners = Sets.newLinkedHashSet(parent.scanners);
    this.elements = privateElements.getElementsMutable();
    this.source = parent.source;
    this.moduleSource = parent.moduleSource;
    this.sourceProvider = parent.sourceProvider;
    this.parent = parent;
    this.privateElements = privateElements;
    this.privateBinders = parent.privateBinders;
} 
","/**
 * The current modules stack
 */
 
/**
 * The binder where exposed bindings will be created
 */
 
/**
 * All children private binders, so we can scan through them.
 */
 
","Field moduleSource
Field parent
Field privateBinders
",5,174
Toolable.java,27,12,2.25,"
 * Instructs an {@link Injector} running in {@link Stage#TOOL} that a method should be injected.
 * This is typically useful for for extensions to Guice that perform additional validation in an
 * injected method or field. This only applies to objects that are already constructed when bindings
 * are created (ie., something bound using {@link
 * com.google.inject.binder.LinkedBindingBuilder#toProvider toProvider}, {@link
 * com.google.inject.binder.LinkedBindingBuilder#toInstance toInstance}, or {@link
 * com.google.inject.Binder#requestInjection requestInjection}.
 *
 * @author sberlin@gmail.com (Sam Berlin)
 * @since 3.0
 ",,,,,,,10,612
RequireExplicitBindingsOption.java,21,21,1.0,"
 * A request to require explicit bindings.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 3.0
 ",,,,,,,4,94
DefaultBindingScopingVisitor.java,25,24,1.0416666666666667,"
 * No-op visitor for subclassing. All interface methods simply delegate to {@link #visitOther()},
 * returning its result.
 *
 * @param <V> any type to be returned by the visit method. Use {@link Void} with {@code return null}
 *     if no return type is needed.
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Default visit implementation. Returns {@code null}.
 */
 
","{
    return null;
} 
",,,,,7,313
ModuleAnnotatedMethodScanner.java,42,10,4.2,"
 * Allows extensions to scan modules for annotated methods and bind those methods as providers,
 * similar to {@code @Provides} methods.
 *
 * @since 4.0
 ","/**
 * Returns the annotations this should scan for. Every method in the module that has one of these
 * annotations will create a Provider binding, with the return value of the binding being what's
 * provided and the parameters of the method being dependencies of the provider.
 */
 
/**
 * Prepares a method for binding. This {@code key} parameter is the key discovered from looking at
 * the binding annotation and return value of the method. Implementations can modify the key to
 * instead bind to another key. For example, Multibinder may want to change
 * {@code @ProvidesIntoSet String provideFoo()} to bind into a unique Key within the multibinder
 * instead of binding {@code String}.
 *
 * <p>The injection point and annotation are provided in case the implementation wants to set the
 * key based on the property of the annotation or if any additional preparation is needed for any
 * of the dependencies. The annotation is guaranteed to be an instance of one the classes returned
 * by {@link #annotationClasses}.
 *
 * <p>If {@code injectionPoint} represents an {@code abstract} method, {@code null} must be
 * returned from this method. This scanner can use {@code binder} to bind alternative bindings in
 * place of the abstract method. In all other cases, this method may not return null.
 */
 
","annotationClasses 
prepareMethod 
",,,,,4,147
DefaultElementVisitor.java,27,75,0.36,"
 * No-op visitor for subclassing. All interface methods simply delegate to {@link
 * #visitOther(Element)}, returning its result.
 *
 * @param <V> any type to be returned by the visit method. Use {@link Void} with {@code return null}
 *     if no return type is needed.
 * @author sberlin@gmail.com (Sam Berlin)
 * @since 2.0
 ","/**
 * Default visit implementation. Returns {@code null}.
 */
 
","{
    return null;
} 
",,,,,7,313
ProvidesMethodTargetVisitor.java,27,5,5.4,"
 * A visitor for the {@literal @}{@link Provides} bindings.
 *
 * <p>If your {@link com.google.inject.spi.BindingTargetVisitor} implements this interface, bindings
 * created by using {@code @Provides} will be visited through this interface.
 *
 * @since 4.0
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Visits an {@link ProvidesMethodBinding} created with an {@literal @}{@link Provides} method.
 */
 
","visit 
",,,,,7,287
BindingTargetVisitor.java,26,44,0.5909090909090909,"
 * Visits each of the strategies used to find an instance to satisfy an injection.
 *
 * @param <V> any type to be returned by the visit method. Use {@link Void} with {@code return null}
 *     if no return type is needed.
 * @since 2.0
 ","/**
 * Visit a instance binding. The same instance is returned for every injection. This target is
 * found in both module and injector bindings.
 */
 
/**
 * Visit a provider instance binding. The provider's {@code get} method is invoked to resolve
 * injections. This target is found in both module and injector bindings.
 */
 
/**
 * Visit a provider key binding. To resolve injections, the provider key is first resolved, then
 * that provider's {@code get} method is invoked. This target is found in both module and injector
 * bindings.
 */
 
/**
 * Visit a linked key binding. The other key's binding is used to resolve injections. This target
 * is found in both module and injector bindings.
 */
 
/**
 * Visit a binding to a key exposed from an enclosed private environment. This target is only
 * found in injector bindings.
 */
 
/**
 * Visit an untargetted binding. This target is found only on module bindings. It indicates that
 * the injector should use its implicit binding strategies to resolve injections.
 */
 
/**
 * Visit a constructor binding. To resolve injections, an instance is instantiated by invoking
 * {@code constructor}. This target is found only on injector bindings.
 */
 
/**
 * Visit a binding created from converting a bound instance to a new type. The source binding has
 * the same binding annotation but a different type. This target is found only on injector
 * bindings.
 */
 
/**
 * Visit a binding to a {@link com.google.inject.Provider} that delegates to the binding for the
 * provided type. This target is found only on injector bindings.
 */
 
","visit 
visit 
visit 
visit 
visit 
visit 
visit 
visit 
visit 
",,,,,5,228
TypeListenerBinding.java,27,33,0.8181818181818182,"
 * Binds types (picked using a Matcher) to an type listener. Registrations are created explicitly in
 * a module using {@link com.google.inject.Binder#bindListener(Matcher, TypeListener)} statements:
 *
 * <pre>
 *     register(only(new TypeLiteral&lt;PaymentService&lt;CreditCard>>() {}), listener);</pre>
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns the registered listener.
 */
 
/**
 * Returns the type matcher which chooses which types the listener should be notified of.
 */
 
","{
    return listener;
} 
{
    return typeMatcher;
} 
",,,,,8,358
ExposedBinding.java,23,8,2.875,"
 * A binding to a key exposed from an enclosed private environment.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns the enclosed environment that holds the original binding.
 */
 
/**
 * Unsupported. Always throws {@link UnsupportedOperationException}.
 */
 
","getPrivateElements 
applyTo 
",,,,,4,127
ConstructorBinding.java,37,11,3.3636363636363638,"
 * A binding to the constructor of a concrete clss. To resolve injections, an instance is
 * instantiated by invoking the constructor.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Gets the constructor this binding injects.
 */
 
/**
 * Returns all instance method and field injection points on {@code type}.
 *
 * @return a possibly empty set of injection points. The set has a specified iteration order. All
 *     fields are returned and then all methods. Within the fields, supertype fields are returned
 *     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 */
 
/**
 * Returns the interceptors applied to each method, in the order that they will be applied.
 *
 * @return a possibly empty map
 */
 
","getConstructor 
getInjectableMembers 
getMethodInterceptors 
",,,,,5,192
ProvisionListenerBinding.java,26,37,0.7027027027027027,"
 * Binds keys (picked using a Matcher) to a provision listener. Listeners are created explicitly in
 * a module using {@link Binder#bindListener(Matcher, ProvisionListener...)} statements:
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 4.0
 ","/**
 * Returns the registered listeners.
 */
 
/**
 * Returns the binding matcher which chooses which bindings the listener should be notified of.
 */
 
","{
    return listeners;
} 
{
    return bindingMatcher;
} 
",,,,,5,238
ProviderInstanceBinding.java,39,10,3.9,"
 * A binding to a provider instance. The provider's {@code get} method is invoked to resolve
 * injections.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * If the user supplied a JSR330 binding, then this will wrap that one. To always return the
 * user-supplied provider, use {@link #getUserSuppliedProvider}.
 *
 * @deprecated Use {@link #getUserSuppliedProvider} instead.
 */
 
/**
 * Returns the user-supplied, unscoped provider.
 *
 * @since 4.0
 */
 
/**
 * Returns the field and method injection points of the provider, injected at injector-creation
 * time only.
 *
 * @return a possibly empty set
 */
 
","getProviderInstance 
getUserSuppliedProvider 
getInjectionPoints 
",,,,,5,165
HasDependencies.java,29,5,5.8,"
 * Implemented by {@link com.google.inject.Binding bindings}, {@link com.google.inject.Provider
 * providers} and instances that expose their dependencies explicitly.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns the known dependencies for this type. If this has dependencies whose values are not
 * known statically, a dependency for the {@link com.google.inject.Injector Injector} will be
 * included in the returned set.
 *
 * @return a possibly empty set
 */
 
","getDependencies 
",,,,,5,224
StaticInjectionRequest.java,38,42,0.9047619047619048,"
 * A request to inject the static fields and methods of a type. Requests are created explicitly in a
 * module using {@link com.google.inject.Binder#requestStaticInjection(Class[])
 * requestStaticInjection()} statements:
 *
 * <pre>
 *     requestStaticInjection(MyLegacyService.class);</pre>
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns the static methods and fields of {@code type} that will be injected to fulfill this
 * request.
 *
 * @return a possibly empty set of injection points. The set has a specified iteration order. All
 *     fields are returned and then all methods. Within the fields, supertype fields are returned
 *     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
 *     a field with multiple binding annotations. The exception's {@link
 *     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
 *     the valid injection points.
 */
 
","{
    return InjectionPoint.forStaticMethodsAndFields(type);
} 
",,,,,9,343
ProviderLookup.java,44,88,0.5,"
 * A lookup of the provider for a type. Lookups are created explicitly in a module using {@link
 * com.google.inject.Binder#getProvider(Class) getProvider()} statements:
 *
 * <pre>
 *     Provider&lt;PaymentService&gt; paymentServiceProvider
 *         = getProvider(PaymentService.class);</pre>
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * @since 4.0
 */
 
/**
 * Sets the actual provider.
 *
 * @throws IllegalStateException if the delegate is already set
 */
 
/**
 * Returns the delegate provider, or {@code null} if it has not yet been initialized. The delegate
 * will be initialized when this element is processed, or otherwise used to create an injector.
 */
 
/**
 * Returns the looked up provider. The result is not valid until this lookup has been initialized,
 * which usually happens when the injector is created. The provider will throw an {@code
 * IllegalStateException} if you try to use it beforehand.
 */
 
","{
    return dependency;
} 
{
    checkState(this.delegate == null, ""delegate already initialized"");
    this.delegate = checkNotNull(delegate, ""delegate"");
} 
{
    return delegate;
} 
{
    return new ProviderWithDependencies<T>() {

        @Override
        public T get() {
            Provider<T> local = delegate;
            if (local == null) {
                throw new IllegalStateException(""This Provider cannot be used until the Injector has been created."");
            }
            return local.get();
        }

        @Override
        public Set<Dependency<?>> getDependencies() {
            // We depend on Provider<T>, not T directly.  This is an important distinction
            // for dependency analysis tools that short-circuit on providers.
            Key<?> providerKey = getKey().ofType(Types.providerOf(getKey().getTypeLiteral().getType()));
            return ImmutableSet.<Dependency<?>>of(Dependency.get(providerKey));
        }

        @Override
        public String toString() {
            return ""Provider<"" + getKey().getTypeLiteral() + "">"";
        }
    };
} 
","/**
 * @since 4.0
 */
 
","{
    this.source = checkNotNull(source, ""source"");
    this.dependency = checkNotNull(dependency, ""dependency"");
} 
",,,9,346
InstanceBinding.java,39,10,3.9,"
 * A binding to a single instance. The same instance is returned for every injection.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns the user-supplied instance.
 */
 
/**
 * Returns the field and method injection points of the instance, injected at injector-creation
 * time only.
 *
 * @return a possibly empty set
 */
 
","getInstance 
getInjectionPoints 
",,,,,4,145
ModuleAnnotatedMethodScannerBinding.java,21,36,0.5833333333333334,"
 * Represents a call to {@link Binder#scanModulesForAnnotatedMethods} in a module.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 4.0
 ",,,,,,,4,134
InjectionRequest.java,42,50,0.84,"
 * A request to inject the instance fields and methods of an instance. Requests are created
 * explicitly in a module using {@link com.google.inject.Binder#requestInjection(Object)
 * requestInjection()} statements:
 *
 * <pre>
 *     requestInjection(serviceInstance);</pre>
 *
 * @author mikeward@google.com (Mike Ward)
 * @since 2.0
 ","/**
 * Returns the instance that injection is being requested on. This may be null for injection
 * requests returned from an Injector, to allow the injector to reclaim memory.
 */
 
/**
 * Returns the instance methods and fields of {@code instance} that will be injected to fulfill
 * this request.
 *
 * @return a possibly empty set of injection points. The set has a specified iteration order. All
 *     fields are returned and then all methods. Within the fields, supertype fields are returned
 *     before subtype fields. Similarly, supertype methods are returned before subtype methods.
 * @throws ConfigurationException if there is a malformed injection point on the class of {@code
 *     instance}, such as a field with multiple binding annotations. The exception's {@link
 *     ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>} of
 *     the valid injection points.
 */
 
","{
    return instance;
} 
{
    return InjectionPoint.forInstanceMethodsAndFields(instance != null ? TypeLiteral.get(instance.getClass()) : type);
} 
",,,,,9,319
ProviderWithExtensionVisitor.java,47,7,6.714285714285714,"
 * A Provider that is part of an extension which supports a custom BindingTargetVisitor.
 *
 * <p>When an extension binds a provider instance, the provider can implement this interface to
 * allow users using the {@link Binding#acceptTargetVisitor(BindingTargetVisitor)} method to visit a
 * custom visitor designed for that extension. A typical implementation within the extension would
 * look like
 *
 * <pre>
 * &lt;V, B> V acceptExtensionVisitor(BindingTargetVisitor&lt;B, V> visitor, ProviderInstanceBinding&lt;? extends B> binding) {
 *   if(visitor instanceof MyCustomExtensionVisitor) {
 *     return ((MyCustomExtensionVisitor&lt;B, V>)visitor).visitCustomExtension(customProperties, binding);
 *   } else {
 *     return visitor.visit(binding);
 *   }
 * }</pre>
 *
 * 'MyCustomExtensionVisitor' in the example above would be an interface the extension provides that
 * users can implement in order to be notified of custom extension information. These visitor
 * interfaces must extend from BindingTargetVisitor.
 *
 * @since 3.0
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Instructs the extension determine if the visitor is an instance of a custom extension visitor,
 * and if so, visit it using that method. If the visitor is not an instance of the custom
 * extension visitor, this method <b>MUST</b> call visitor.visit(binding).
 *
 * <p>Due to issues with generics, the type parameters of this method do not relate to the type of
 * the provider. In practice, the 'B' type will always be a supertype of 'T'.
 */
 
","acceptExtensionVisitor 
",,,,,22,1040
Dependency.java,41,70,0.5857142857142857,"
 * A variable that can be resolved by an injector.
 *
 * <p>Use {@link #get} to build a freestanding dependency, or {@link InjectionPoint} to build one
 * that's attached to a constructor, method or field.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns a new dependency that is not attached to an injection point. The returned dependency is
 * nullable.
 */
 
/**
 * Returns the dependencies from the given injection points.
 */
 
/**
 * Returns the key to the binding that satisfies this dependency.
 */
 
/**
 * Returns true if null is a legal value for this dependency.
 */
 
/**
 * Returns the injection point to which this dependency belongs, or null if this dependency isn't
 * attached to a particular injection point.
 */
 
/**
 * Returns the index of this dependency in the injection point's parameter list, or {@code -1} if
 * this dependency does not belong to a parameter list. Only method and constuctor dependencies
 * are elements in a parameter list.
 */
 
","{
    return new Dependency<T>(null, MoreTypes.canonicalizeKey(key), true, -1);
} 
{
    List<Dependency<?>> dependencies = Lists.newArrayList();
    for (InjectionPoint injectionPoint : injectionPoints) {
        dependencies.addAll(injectionPoint.getDependencies());
    }
    return ImmutableSet.copyOf(dependencies);
} 
{
    return this.key;
} 
{
    return nullable;
} 
{
    return injectionPoint;
} 
{
    return parameterIndex;
} 
",,,,,8,298
LinkedKeyBinding.java,25,6,4.166666666666667,"
 * A binding to a linked key. The other key's binding is used to resolve injections.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Returns the linked key used to resolve injections. That binding can be retrieved from an
 * injector using {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
 */
 
","getLinkedKey 
",,,,,4,144
ElementSource.java,111,65,1.7076923076923076,"
 * Contains information about where and how an {@link Element element} was bound.
 *
 * <p>The {@link #getDeclaringSource() declaring source} refers to a location in source code that
 * defines the Guice {@link Element element}. For example, if the element is created from a method
 * annotated by {@literal @Provides}, the declaring source of element would be the method itself.
 *
 * <p>The {@link #getStackTrace()} refers to the sequence of calls ends at one of {@link
 * com.google.inject.Binder} {@code bindXXX()} methods and eventually defines the element. Note that
 * {@link #getStackTrace()} lists {@link StackTraceElement StackTraceElements} in reverse
 * chronological order. The first element (index zero) is the last method call and the last element
 * is the first method invocation. By default, the stack trace is not collected. The default
 * behavior can be changed by setting the {@code guice_include_stack_traces} flag value. The value
 * can be either {@code OFF}, {@code ONLY_FOR_DECLARING_SOURCE} or {@code COMPLETE}. Note that
 * collecting stack traces for every binding can cause a performance hit when the injector is
 * created.
 *
 * <p>The sequence of class names of {@link com.google.inject.Module modules} involved in the
 * element creation can be retrieved by {@link #getModuleClassNames()}. Similar to {@link
 * #getStackTrace()}, the order is reverse chronological. The first module (index 0) is the module
 * that installs the {@link Element element}. The last module is the root module.
 *
 * <p>In order to support the cases where a Guice {@link Element element} is created from another
 * Guice {@link Element element} (original) (e.g., by {@link Element#applyTo}), it also provides a
 * reference to the original element source ({@link #getOriginalElementSource()}).
 *
 * @since 4.0
 ","/**
 * Returns the {@link ElementSource} of the element this was created or copied from. If this was
 * not created or copied from another element, returns {@code null}.
 */
 
/**
 * Returns a single location in source code that defines the element. It can be any object such as
 * {@link java.lang.reflect.Constructor}, {@link java.lang.reflect.Method}, {@link
 * java.lang.reflect.Field}, {@link StackTraceElement}, etc. For example, if the element is
 * created from a method annotated by {@literal @Provides}, the declaring source of element would
 * be the method itself.
 */
 
/**
 * Returns the class names of modules involved in creating this {@link Element}. The first element
 * (index 0) is the class name of module that defined the element, and the last element is the
 * class name of root module.
 */
 
/**
 * Returns the position of {@link com.google.inject.Module#configure configure(Binder)} method
 * call in the {@link #getStackTrace stack trace} for modules that their classes returned by
 * {@link #getModuleClassNames}. For example, if the stack trace looks like the following:
 *
 * <ol>
 *   <li>{@code Binder.bind()}
 *   <li>{@code ModuleTwo.configure()}
 *   <li>{@code Binder.install()}
 *   <li>{@code ModuleOne.configure()}
 *   <li>{@code theRest().
 * </ol>
 *
 * <p>1 and 3 are returned.
 *
 * <p>In the cases where stack trace is not available (i.e., the stack trace was not collected),
 * it returns -1 for all module positions.
 */
 
/**
 * Returns the sequence of method calls that ends at one of {@link com.google.inject.Binder}
 * {@code bindXXX()} methods and eventually defines the element. Note that {@link #getStackTrace}
 * lists {@link StackTraceElement StackTraceElements} in reverse chronological order. The first
 * element (index zero) is the last method call and the last element is the first method
 * invocation. In the cases where stack trace is not available (i.e.,the stack trace was not
 * collected), it returns an empty array.
 */
 
/**
 * Returns {@code getDeclaringSource().toString()} value.
 */
 
","{
    return originalElementSource;
} 
{
    return declaringSource;
} 
{
    return moduleSource.getModuleClassNames();
} 
{
    int size = moduleSource.size();
    Integer[] positions = new Integer[size];
    int chunkSize = partialCallStack.length;
    positions[0] = chunkSize - 1;
    ModuleSource current = moduleSource;
    for (int cursor = 1; cursor < size; cursor++) {
        chunkSize = current.getPartialCallStackSize();
        positions[cursor] = positions[cursor - 1] + chunkSize;
        current = current.getParent();
    }
    return ImmutableList.<Integer>copyOf(positions);
} 
{
    int modulesCallStackSize = moduleSource.getStackTraceSize();
    int chunkSize = partialCallStack.length;
    int size = moduleSource.getStackTraceSize() + chunkSize;
    StackTraceElement[] callStack = new StackTraceElement[size];
    System.arraycopy(StackTraceElements.convertToStackTraceElement(partialCallStack), 0, callStack, 0, chunkSize);
    System.arraycopy(moduleSource.getStackTrace(), 0, callStack, chunkSize, modulesCallStackSize);
    return callStack;
} 
{
    return getDeclaringSource().toString();
} 
","/**
 * Creates a new {@ElementSource} from the given parameters.
 *
 * @param originalElementSource The source of element that this element created from (if there is
 *     any), otherwise {@code null}.
 * @param declaringSource the source (in)directly declared the element.
 * @param moduleSource the moduleSource when the element is bound
 * @param partialCallStack the partial call stack from the top module to where the element is
 *     bound
 */
 
","{
    Preconditions.checkNotNull(declaringSource, ""declaringSource cannot be null."");
    Preconditions.checkNotNull(moduleSource, ""moduleSource cannot be null."");
    Preconditions.checkNotNull(partialCallStack, ""partialCallStack cannot be null."");
    this.originalElementSource = originalSource;
    this.declaringSource = declaringSource;
    this.moduleSource = moduleSource;
    this.partialCallStack = StackTraceElements.convertToInMemoryStackTraceElement(partialCallStack);
} 
","/**
 * The {@link ElementSource source} of element that this element created from (if there is any),
 * otherwise {@code null}.
 */
 
/**
 * The {@link ModuleSource source} of module creates the element.
 */
 
/**
 * The partial call stack that starts at the last module {@link Module#Configure(Binder)
 * configure(Binder)} call. The value is empty if stack trace collection is off.
 */
 
/**
 * Refers to a single location in source code that causes the element creation. It can be any
 * object such as {@link Constructor}, {@link Method}, {@link Field}, {@link StackTraceElement},
 * etc. For example, if the element is created from a method annotated by {@literal @Provides},
 * the declaring source of element would be the method itself.
 */
 
","Field originalElementSource
Field moduleSource
Field partialCallStack
Field declaringSource
",26,1773
BindingScopingVisitor.java,25,24,1.0416666666666667,"
 * Visits each of the strategies used to scope an injection.
 *
 * @param <V> any type to be returned by the visit method. Use {@link Void} with {@code return null}
 *     if no return type is needed.
 * @since 2.0
 ","/**
 * Visit an eager singleton or single instance. This scope strategy is found on both module and
 * injector bindings.
 */
 
/**
 * Visit a scope instance. This scope strategy is found on both module and injector bindings.
 */
 
/**
 * Visit a scope annotation. This scope strategy is found only on module bindings. The instance
 * that implements this scope is registered by {@link com.google.inject.Binder#bindScope(Class,
 * Scope) Binder.bindScope()}.
 */
 
/**
 * Visit an unspecified or unscoped strategy. On a module, this strategy indicates that the
 * injector should use scoping annotations to find a scope. On an injector, it indicates that no
 * scope is applied to the binding. An unscoped binding will behave like a scoped one when it is
 * linked to a scoped binding.
 */
 
","visitEagerSingleton 
visitScope 
visitScopeAnnotation 
visitNoScoping 
",,,,,5,206
RequireAtInjectOnConstructorsOption.java,21,22,0.9545454545454546,"
 * A request to require explicit {@literal @}{@link Inject} annotations on constructors.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 4.0
 ",,,,,,,4,140
TypeLiteral.java,97,203,0.47783251231527096,"
 * Represents a generic type {@code T}. Java doesn't yet provide a way to represent generic types,
 * so this class does. Forces clients to create a subclass of this class which enables retrieval of
 * the type information even at runtime.
 *
 * <p>For example, to create a type literal for {@code List<String>}, you can create an empty
 * anonymous inner class:
 *
 * <p>{@code TypeLiteral<List<String>> list = new TypeLiteral<List<String>>() {};}
 *
 * <p>Along with modeling generic types, this class can resolve type parameters. For example, to
 * figure out what type {@code keySet()} returns on a {@code Map<Integer, String>}, use this code:
 *
 * <pre>{@code
 * TypeLiteral<Map<Integer, String>> mapType
 *     = new TypeLiteral<Map<Integer, String>>() {};
 * TypeLiteral<?> keySetType
 *     = mapType.getReturnType(Map.class.getMethod(""keySet""));
 * System.out.println(keySetType); // prints ""Set<Integer>""
 * }</pre>
 *
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Returns the type from super class's type parameter in {@link MoreTypes#canonicalize(Type)
 * canonical form}.
 */
 
/**
 * Gets type literal from super class's type parameter.
 */
 
/**
 * Returns the raw (non-generic) type for this type.
 *
 * @since 2.0
 */
 
/**
 * Gets underlying {@code Type} instance.
 */
 
/**
 * Gets the type of this type's provider.
 */
 
/**
 * Gets type literal for the given {@code Type} instance.
 */
 
/**
 * Gets type literal for the given {@code Class} instance.
 */
 
/**
 * Returns an immutable list of the resolved types.
 */
 
/**
 * Resolves known type parameters in {@code toResolve} and returns the result.
 */
 
/**
 * Returns the generic form of {@code supertype}. For example, if this is {@code
 * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
 * Iterable.class}.
 *
 * @param supertype a superclass of, or interface implemented by, this.
 * @since 2.0
 */
 
/**
 * Returns the resolved generic type of {@code field}.
 *
 * @param field a field defined by this or any superclass.
 * @since 2.0
 */
 
/**
 * Returns the resolved generic parameter types of {@code methodOrConstructor}.
 *
 * @param methodOrConstructor a method or constructor defined by this or any supertype.
 * @since 2.0
 */
 
/**
 * Returns the resolved generic exception types thrown by {@code constructor}.
 *
 * @param methodOrConstructor a method or constructor defined by this or any supertype.
 * @since 2.0
 */
 
/**
 * Returns the resolved generic return type of {@code method}.
 *
 * @param method a method defined by this or any supertype.
 * @since 2.0
 */
 
","{
    Type superclass = subclass.getGenericSuperclass();
    if (superclass instanceof Class) {
        throw new RuntimeException(""Missing type parameter."");
    }
    ParameterizedType parameterized = (ParameterizedType) superclass;
    return canonicalize(parameterized.getActualTypeArguments()[0]);
} 
{
    return new TypeLiteral<Object>(getSuperclassTypeParameter(subclass));
} 
{
    return rawType;
} 
{
    return type;
} 
{
    // This cast is safe and wouldn't generate a warning if Type had a type
    // parameter.
    return (TypeLiteral<Provider<T>>) get(Types.providerOf(getType()));
} 
{
    return new TypeLiteral<Object>(type);
} 
{
    return new TypeLiteral<T>(type);
} 
{
    TypeLiteral<?>[] result = new TypeLiteral<?>[types.length];
    for (int t = 0; t < types.length; t++) {
        result[t] = resolve(types[t]);
    }
    return ImmutableList.copyOf(result);
} 
{
    return TypeLiteral.get(resolveType(toResolve));
} 
{
    checkArgument(supertype.isAssignableFrom(rawType), ""%s is not a supertype of %s"", supertype, this.type);
    return resolve(MoreTypes.getGenericSupertype(type, rawType, supertype));
} 
{
    checkArgument(field.getDeclaringClass().isAssignableFrom(rawType), ""%s is not defined by a supertype of %s"", field, type);
    return resolve(field.getGenericType());
} 
{
    Type[] genericParameterTypes;
    if (methodOrConstructor instanceof Method) {
        Method method = (Method) methodOrConstructor;
        checkArgument(method.getDeclaringClass().isAssignableFrom(rawType), ""%s is not defined by a supertype of %s"", method, type);
        genericParameterTypes = method.getGenericParameterTypes();
    } else if (methodOrConstructor instanceof Constructor) {
        Constructor<?> constructor = (Constructor<?>) methodOrConstructor;
        checkArgument(constructor.getDeclaringClass().isAssignableFrom(rawType), ""%s does not construct a supertype of %s"", constructor, type);
        genericParameterTypes = constructor.getGenericParameterTypes();
    } else {
        throw new IllegalArgumentException(""Not a method or a constructor: "" + methodOrConstructor);
    }
    return resolveAll(genericParameterTypes);
} 
{
    Type[] genericExceptionTypes;
    if (methodOrConstructor instanceof Method) {
        Method method = (Method) methodOrConstructor;
        checkArgument(method.getDeclaringClass().isAssignableFrom(rawType), ""%s is not defined by a supertype of %s"", method, type);
        genericExceptionTypes = method.getGenericExceptionTypes();
    } else if (methodOrConstructor instanceof Constructor) {
        Constructor<?> constructor = (Constructor<?>) methodOrConstructor;
        checkArgument(constructor.getDeclaringClass().isAssignableFrom(rawType), ""%s does not construct a supertype of %s"", constructor, type);
        genericExceptionTypes = constructor.getGenericExceptionTypes();
    } else {
        throw new IllegalArgumentException(""Not a method or a constructor: "" + methodOrConstructor);
    }
    return resolveAll(genericExceptionTypes);
} 
{
    checkArgument(method.getDeclaringClass().isAssignableFrom(rawType), ""%s is not defined by a supertype of %s"", method, type);
    return resolve(method.getGenericReturnType());
} 
","/**
 * Constructs a new type literal. Derives represented class from type parameter.
 *
 * <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the
 * anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.
 */
 
/**
 * Unsafe. Constructs a type literal manually.
 */
 
","{
    this.type = getSuperclassTypeParameter(getClass());
    this.rawType = (Class<? super T>) MoreTypes.getRawType(type);
    this.hashCode = type.hashCode();
} 
{
    this.type = canonicalize(checkNotNull(type, ""type""));
    this.rawType = (Class<? super T>) MoreTypes.getRawType(this.type);
    this.hashCode = this.type.hashCode();
} 
",,,22,977
Scope.java,146,142,1.028169014084507,"
 * A scope is a level of visibility that instances provided by Guice may have. By default, an
 * instance created by the {@link Injector} has <i>no scope</i>, meaning it has no state from the
 * framework's perspective -- the {@code Injector} creates it, injects it once into the class that
 * required it, and then immediately forgets it. Associating a scope with a particular binding
 * allows the created instance to be ""remembered"" and possibly used again for other injections.
 *
 * <p>An example of a scope is {@link Scopes#SINGLETON}.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Scopes a provider. The returned provider returns objects from this scope. If an object does not
 * exist in this scope, the provider can use the given unscoped provider to retrieve one.
 *
 * <p>Scope implementations are strongly encouraged to override {@link Object#toString} in the
 * returned provider and include the backing provider's {@code toString()} output.
 *
 * @param key binding key
 * @param unscoped locates an instance when one doesn't already exist in this scope.
 * @return a new provider which only delegates to the given unscoped provider when an instance of
 *     the requested object doesn't already exist in this scope
 */
 
/**
 * A short but useful description of this scope. For comparison, the standard scopes that ship
 * with guice use the descriptions {@code ""Scopes.SINGLETON""}, {@code ""ServletScopes.SESSION""} and
 * {@code ""ServletScopes.REQUEST""}.
 */
 
","scope 
toString 
",,,,,9,569
MembersInjector.java,34,4,8.5,"
 * Injects dependencies into the fields and methods on instances of type {@code T}. Ignores the
 * presence or absence of an injectable constructor.
 *
 * @param <T> type to inject members of
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 ","/**
 * Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
 * absence of an injectable constructor.
 *
 * <p>Whenever Guice creates an instance, it performs this injection automatically (after first
 * performing constructor injection), so if you're able to let Guice create all your objects for
 * you, you'll never need to use this method.
 *
 * @param instance to inject members on. May be {@code null}.
 */
 
","injectMembers 
",,,,,7,283
Key.java,127,288,0.4409722222222222,"
 * Binding key consisting of an injection type and an optional annotation. Matches the type and
 * annotation at a point of injection.
 *
 * <p>For example, {@code Key.get(Service.class, Transactional.class)} will match:
 *
 * <pre>
 *   {@literal @}Inject
 *   public void setService({@literal @}Transactional Service service) {
 *     ...
 *   }
 * </pre>
 *
 * <p>{@code Key} supports generic types via subclassing just like {@link TypeLiteral}.
 *
 * <p>Keys do not differentiate between primitive types (int, char, etc.) and their corresponding
 * wrapper types (Integer, Character, etc.). Primitive types will be replaced with their wrapper
 * types when keys are created.
 *
 * @author crazybob@google.com (Bob Lee)
 | This field is updated using the 'Data-Race-Ful' lazy intialization pattern| See http://jeremymanson.blogspot.com/2008/12/benign-data-races-in-java.html for a detailed|
   * Gets the annotation instance if available. Will be {@code null} if this key lacks an annotation
   * <i>or</i> the key was constructed with a {@code Class<Annotation>}.
   *
   * <p><b>Warning:</b> this can return null even if this key is annotated. To check whether a
   * {@code Key} has an annotation use {@link #hasAnnotationType} instead.
   | TODO(diamondm) consider deprecating this in favor of a method that ISEs if hasAnnotationType()| this class not test-covered","/**
 * Computes the hash code for this key.
 */
 
/**
 * Gets the key type.
 */
 
/**
 * Gets the annotation type. Will be {@code null} if this key lacks an annotation.
 */
 
/**
 * Gets the key of this key's provider.
 */
 
/**
 * Gets a key for an injection type and an annotation strategy.
 */
 
/**
 * Gets a key for an injection type.
 */
 
/**
 * Gets a key for an injection type and an annotation type.
 */
 
/**
 * Gets a key for an injection type and an annotation.
 */
 
/**
 * Gets a key for an injection type.
 */
 
/**
 * Gets a key for an injection type and an annotation type.
 */
 
/**
 * Gets a key for an injection type and an annotation.
 */
 
/**
 * Gets a key for an injection type.
 */
 
/**
 * Gets a key for an injection type and an annotation type.
 */
 
/**
 * Gets a key for an injection type and an annotation.
 */
 
/**
 * Returns a new key of the specified type with the same annotation as this key.
 *
 * @since 3.0
 */
 
/**
 * Returns a new key of the specified type with the same annotation as this key.
 *
 * @since 3.0
 */
 
/**
 * Returns a new key of the specified type with the same annotation as this key.
 *
 * @since 3.0
 */
 
/**
 * Returns true if this key has annotation attributes.
 *
 * @since 3.0
 */
 
/**
 * Returns this key without annotation attributes, i.e. with only the annotation type.
 *
 * @since 3.0
 */
 
/**
 * Gets the strategy for an annotation.
 */
 
/**
 * Gets the strategy for an annotation type.
 */
 
","{
    return typeLiteral.hashCode() * 31 + annotationStrategy.hashCode();
} 
{
    return typeLiteral;
} 
{
    return annotationStrategy.getAnnotationType();
} 
{
    return ofType(typeLiteral.providerType());
} 
{
    return new Key<T>(type, annotationStrategy);
} 
{
    return new Key<T>(type, NullAnnotationStrategy.INSTANCE);
} 
{
    return new Key<T>(type, strategyFor(annotationType));
} 
{
    return new Key<T>(type, strategyFor(annotation));
} 
{
    return new Key<Object>(type, NullAnnotationStrategy.INSTANCE);
} 
{
    return new Key<Object>(type, strategyFor(annotationType));
} 
{
    return new Key<Object>(type, strategyFor(annotation));
} 
{
    return new Key<T>(typeLiteral, NullAnnotationStrategy.INSTANCE);
} 
{
    return new Key<T>(typeLiteral, strategyFor(annotationType));
} 
{
    return new Key<T>(typeLiteral, strategyFor(annotation));
} 
{
    return new Key<T>(type, annotationStrategy);
} 
{
    return new Key<Object>(type, annotationStrategy);
} 
{
    return new Key<T>(type, annotationStrategy);
} 
{
    return annotationStrategy.hasAttributes();
} 
{
    return new Key<T>(typeLiteral, annotationStrategy.withoutAttributes());
} 
{
    checkNotNull(annotation, ""annotation"");
    Class<? extends Annotation> annotationType = annotation.annotationType();
    ensureRetainedAtRuntime(annotationType);
    ensureIsBindingAnnotation(annotationType);
    if (Annotations.isMarker(annotationType)) {
        return new AnnotationTypeStrategy(annotationType, annotation);
    }
    return new AnnotationInstanceStrategy(Annotations.canonicalizeIfNamed(annotation));
} 
{
    annotationType = Annotations.canonicalizeIfNamed(annotationType);
    if (isAllDefaultMethods(annotationType)) {
        return strategyFor(generateAnnotation(annotationType));
    }
    checkNotNull(annotationType, ""annotation type"");
    ensureRetainedAtRuntime(annotationType);
    ensureIsBindingAnnotation(annotationType);
    return new AnnotationTypeStrategy(annotationType, null);
} 
","/**
 * Constructs a new key. Derives the type from this class's type parameter.
 *
 * <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the
 * anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.
 *
 * <p>Example usage for a binding of type {@code Foo} annotated with {@code @Bar}:
 *
 * <p>{@code new Key<Foo>(Bar.class) {}}.
 */
 
/**
 * Constructs a new key. Derives the type from this class's type parameter.
 *
 * <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the
 * anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.
 *
 * <p>Example usage for a binding of type {@code Foo} annotated with {@code @Bar}:
 *
 * <p>{@code new Key<Foo>(new Bar()) {}}.
 */
 
/**
 * Constructs a new key. Derives the type from this class's type parameter.
 *
 * <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the
 * anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.
 *
 * <p>Example usage for a binding of type {@code Foo}:
 *
 * <p>{@code new Key<Foo>() {}}.
 */
 
/**
 * Unsafe. Constructs a key from a manually specified type.
 */
 
/**
 * Constructs a key from a manually specified type.
 */
 
","{
    this.annotationStrategy = strategyFor(annotationType);
    this.typeLiteral = MoreTypes.canonicalizeForKey((TypeLiteral<T>) TypeLiteral.fromSuperclassTypeParameter(getClass()));
    this.hashCode = computeHashCode();
} 
{
    // no usages, not test-covered
    this.annotationStrategy = strategyFor(annotation);
    this.typeLiteral = MoreTypes.canonicalizeForKey((TypeLiteral<T>) TypeLiteral.fromSuperclassTypeParameter(getClass()));
    this.hashCode = computeHashCode();
} 
{
    this.annotationStrategy = NullAnnotationStrategy.INSTANCE;
    this.typeLiteral = MoreTypes.canonicalizeForKey((TypeLiteral<T>) TypeLiteral.fromSuperclassTypeParameter(getClass()));
    this.hashCode = computeHashCode();
} 
{
    this.annotationStrategy = annotationStrategy;
    this.typeLiteral = MoreTypes.canonicalizeForKey((TypeLiteral<T>) TypeLiteral.get(type));
    this.hashCode = computeHashCode();
} 
{
    this.annotationStrategy = annotationStrategy;
    this.typeLiteral = MoreTypes.canonicalizeForKey(typeLiteral);
    this.hashCode = computeHashCode();
} 
",,,26,1322
Binding.java,31,50,0.62,"
 * A mapping from a key (type and optional annotation) to the strategy for getting instances of the
 * type. This interface is part of the introspection API and is intended primarily for use by tools.
 *
 * <p>Bindings are created in several ways:
 *
 * <ul>
 * <li>Explicitly in a module, via {@code bind()} and {@code bindConstant()} statements:
 *     <pre>
 *     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);
 *     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre>
 *
 * <li>Implicitly by the Injector by following a type's {@link ImplementedBy pointer} {@link
 *     ProvidedBy annotations} or by using its {@link Inject annotated} or default constructor.
 * <li>By converting a bound instance to a different type.
 * <li>For {@link Provider providers}, by delegating to the binding for the provided type.
 * </ul>
 *
 * <p>They exist on both modules and on injectors, and their behaviour is different for each:
 *
 * <ul>
 * <li><strong>Module bindings</strong> are incomplete and cannot be used to provide instances. This
 *     is because the applicable scopes and interceptors may not be known until an injector is
 *     created. From a tool's perspective, module bindings are like the injector's source code. They
 *     can be inspected or rewritten, but this analysis must be done statically.
 * <li><strong>Injector bindings</strong> are complete and valid and can be used to provide
 *     instances. From a tools' perspective, injector bindings are like reflection for an injector.
 *     They have full runtime information, including the complete graph of injections necessary to
 *     satisfy a binding.
 * </ul>
 *
 * @param <T> the bound type. The injected is always assignable to this type.
 * @author crazybob@google.com (Bob Lee)
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Returns the key for this binding.
 */
 
/**
 * Returns the scoped provider guice uses to fulfill requests for this binding.
 *
 * @throws UnsupportedOperationException when invoked on a {@link Binding} created via {@link
 *     com.google.inject.spi.Elements#getElements}. This method is only supported on {@link
 *     Binding}s returned from an injector.
 */
 
/**
 * Accepts a target visitor. Invokes the visitor method specific to this binding's target.
 *
 * @param visitor to call back on
 * @since 2.0
 */
 
/**
 * Accepts a scoping visitor. Invokes the visitor method specific to this binding's scoping.
 *
 * @param visitor to call back on
 * @since 2.0
 */
 
","getKey 
getProvider 
acceptTargetVisitor 
acceptScopingVisitor 
",,,,,33,1778
NamedImpl.java,16,36,0.4444444444444444,,,,,,,,1,0
Names.java,27,28,0.9642857142857143,"
 * Utility methods for use with {@code @}{@link Named}.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Creates a {@link Named} annotation with {@code name} as the value.
 */
 
/**
 * Creates a constant binding to {@code @Named(key)} for each entry in {@code properties}.
 */
 
/**
 * Creates a constant binding to {@code @Named(key)} for each property. This method binds all
 * properties including those inherited from {@link Properties#defaults defaults}.
 */
 
","{
    return new NamedImpl(name);
} 
{
    binder = binder.skipSources(Names.class);
    for (Map.Entry<String, String> entry : properties.entrySet()) {
        String key = entry.getKey();
        String value = entry.getValue();
        binder.bind(Key.get(String.class, new NamedImpl(key))).toInstance(value);
    }
} 
{
    binder = binder.skipSources(Names.class);
    // use enumeration to include the default properties
    for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements(); ) {
        String propertyName = (String) e.nextElement();
        String value = properties.getProperty(propertyName);
        binder.bind(Key.get(String.class, new NamedImpl(propertyName))).toInstance(value);
    }
} 
",,,,,3,95
Named.java,20,12,1.6666666666666667,"
 * Annotates named things.
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,3,66
BindingAnnotation.java,29,8,3.625,"
 * Annotates annotations which are used for binding. Only one such annotation may apply to a single
 * injection point. You must also annotate binder annotations with {@code @Retention(RUNTIME)}. For
 * example:
 *
 * <pre>
 *   {@code @}Retention(RUNTIME)
 *   {@code @}Target({ FIELD, PARAMETER, METHOD })
 *   {@code @}BindingAnnotation
 *   public {@code @}interface Transactional {}
 * </pre>
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,12,419
ProvidedBy.java,21,10,2.1,"
 * A pointer to the default provider type for a type.
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,3,93
Scopes.java,160,234,0.6837606837606838,"
 * Built-in scope implementations.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Returns true if {@code binding} is singleton-scoped. If the binding is a {@link
 * com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (ie. it
 * was retrieved via {@link Injector#getBinding Injector.getBinding()}), then this method will
 * also true if the target binding is singleton-scoped.
 *
 * @since 3.0
 */
 
/**
 * Returns true if {@code binding} has the given scope. If the binding is a {@link
 * com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (ie. it
 * was retrieved via {@link Injector#getBinding Injector.getBinding()}), then this method will
 * also true if the target binding has the given scope.
 *
 * @param binding binding to check
 * @param scope scope implementation instance
 * @param scopeAnnotation scope annotation class
 * @since 4.0
 */
 
/**
 * Returns true if the object is a proxy for a circular dependency, constructed by Guice because
 * it encountered a circular dependency. Scope implementations should be careful to <b>not cache
 * circular proxies</b>, because the proxies are not intended for general purpose use. (They are
 * designed just to fulfill the immediate injection, not all injections. Caching them can lead to
 * IllegalArgumentExceptions or ClassCastExceptions.)
 *
 * @since 4.0
 */
 
","{
    do {
        boolean singleton = binding.acceptScopingVisitor(IS_SINGLETON_VISITOR);
        if (singleton) {
            return true;
        }
        if (binding instanceof LinkedBindingImpl) {
            LinkedBindingImpl<?> linkedBinding = (LinkedBindingImpl) binding;
            Injector injector = linkedBinding.getInjector();
            if (injector != null) {
                binding = injector.getBinding(linkedBinding.getLinkedKey());
                continue;
            }
        } else if (binding instanceof ExposedBinding) {
            ExposedBinding<?> exposedBinding = (ExposedBinding) binding;
            Injector injector = exposedBinding.getPrivateElements().getInjector();
            if (injector != null) {
                binding = injector.getBinding(exposedBinding.getKey());
                continue;
            }
        }
        return false;
    } while (true);
} 
{
    do {
        boolean matches = binding.acceptScopingVisitor(new BindingScopingVisitor<Boolean>() {

            @Override
            public Boolean visitNoScoping() {
                return false;
            }

            @Override
            public Boolean visitScopeAnnotation(Class<? extends Annotation> visitedAnnotation) {
                return visitedAnnotation == scopeAnnotation;
            }

            @Override
            public Boolean visitScope(Scope visitedScope) {
                return visitedScope == scope;
            }

            @Override
            public Boolean visitEagerSingleton() {
                return false;
            }
        });
        if (matches) {
            return true;
        }
        if (binding instanceof LinkedBindingImpl) {
            LinkedBindingImpl<?> linkedBinding = (LinkedBindingImpl) binding;
            Injector injector = linkedBinding.getInjector();
            if (injector != null) {
                binding = injector.getBinding(linkedBinding.getLinkedKey());
                continue;
            }
        } else if (binding instanceof ExposedBinding) {
            ExposedBinding<?> exposedBinding = (ExposedBinding) binding;
            Injector injector = exposedBinding.getPrivateElements().getInjector();
            if (injector != null) {
                binding = injector.getBinding(exposedBinding.getKey());
                continue;
            }
        }
        return false;
    } while (true);
} 
{
    return object instanceof CircularDependencyProxy;
} 
",,,"/**
 * One instance per {@link Injector}. Also see {@code @}{@link Singleton}.
 */
 
/**
 * No scope; the same as not applying any scope at all. Each time the Injector obtains an instance
 * of an object with ""no scope"", it injects this instance then immediately forgets it. When the
 * next request for the same binding arrives it will need to obtain the instance over again.
 *
 * <p>This exists only in case a class has been annotated with a scope annotation such as {@link
 * Singleton @Singleton}, and you need to override this to ""no scope"" in your binding.
 *
 * @since 2.0
 */
 
","Field SINGLETON
Field NO_SCOPE
",3,74
ServletDefinitionTest.java,23,82,0.2804878048780488,"
 * Basic unit test for lifecycle of a ServletDefinition (wrapper).
 *
 * @author Dhanji R. Prasanna (dhanji@gmail com)
 ",,,,,,,3,114
MultipleServletInjectorsTest.java,28,65,0.4307692307692308,"
 * This gorgeous test asserts that multiple servlet pipelines can run in the SAME JVM. booya.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ",,,,,,,3,141
AllTests.java,31,115,0.26956521739130435," @author dhanji@gmail.com (Dhanji R. Prasanna) ",,,,,,,1,47
ServletScopesTest.java,22,167,0.1317365269461078,"
 * Tests for {@link ServletScopes}.
 *
 * @author forster@google.com (Mike Forster)
 ",,,,,,,3,79
ServletDefinitionPathsTest.java,39,226,0.17256637168141592,"
 * Ensures servlet spec compliance for CGI-style variables and general path/pattern matching.
 *
 * @author Dhanji R. Prasanna (dhanji@gmail com)
 ",,,,,,,3,141
ServletModuleTest.java,22,90,0.24444444444444444,"
 * Tests for ServletModule, to ensure it captures bindings correctly.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,109
DummyFilterImpl.java,20,23,0.8695652173913043,"
 * Used in unit tests to verify the EDSL.
 *
 * @author Dhanji R. Prasanna (dhanji@gmail com)
 ",,,,,,,3,89
FilterDispatchIntegrationTest.java,36,348,0.10344827586206896,"
 * This tests that filter stage of the pipeline dispatches correctly to guice-managed filters.
 *
 * <p>WARNING(dhanji): Non-parallelizable test =(
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 | A filter that keeps count of when it was called by increment a counter. ",,,,,,,6,265
VarargsServletDispatchIntegrationTest.java,30,169,0.17751479289940827,"
 * Tests the FilterPipeline that dispatches to guice-managed servlets, is a full integration test,
 * with a real injector.
 *
 * @author Dhanji R. Prasanna (dhanji gmail com)
 ",,,,,,,4,169
ScopeRequestIntegrationTest.java,23,136,0.16911764705882354,,,,,,,,1,0
ServletDispatchIntegrationTest.java,32,240,0.13333333333333333,"
 * Tests the FilterPipeline that dispatches to guice-managed servlets, is a full integration test,
 * with a real injector.
 *
 * @author Dhanji R. Prasanna (dhanji gmail com)
 ",,,,,,,4,169
ExtensionSpiTest.java,21,256,0.08203125,"
 * A very basic test that servletmodule works with bindings.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,100
DummyServlet.java,20,5,4.0,"
 * Used in unit tests to verify the EDSL.
 *
 * @author Dhanji R. Prasanna (dhanji@gmail com)
 ",,,,,,,3,89
EdslTest.java,22,66,0.3333333333333333,"
 * Sanity checks the EDSL and resultant bound module(s).
 *
 * @author Dhanji R. Prasanna (dhanji gmail com)
 ",,,,,,,3,104
ServletSpiVisitor.java,23,122,0.1885245901639344,"
 * A visitor for testing the servlet SPI extension.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,91
ContextPathTest.java,70,186,0.3763440860215054," Tests to make sure that servlets with a context path are handled right. ",,,,,,,1,73
FilterPipelineTest.java,21,116,0.1810344827586207,"
 * This is a basic whitebox test that verifies the glue between GuiceFilter and
 * ManagedFilterPipeline is working.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ",,,,,,,4,162
ServletUtilsTest.java,9,43,0.20930232558139536,"
 * Unit test for the servlet utility class.
 *
 * @author ntang@google.com (Michael Tang)
 ",,,,,,,3,85
ContinuingRequestIntegrationTest.java,21,170,0.12352941176470589,,,,,,,,1,0
ContinuingHttpServletRequestTest.java,20,61,0.32786885245901637,,,,,,,,1,0
InvalidScopeBindingTest.java,8,77,0.1038961038961039,"
 * Ensures that an error is thrown if a Servlet or Filter is bound under any scope other than
 * singleton, explicitly.
 *
 * @author dhanji@gmail.com
 ",,,,,,,4,144
ServletTest.java,18,439,0.04100227790432802," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
InjectedFilterPipelineTest.java,21,116,0.1810344827586207,"
 * Exactly the same as {@linkplain com.google.inject.servlet.FilterPipelineTest} except that we test
 * that the static pipeline is not used.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ",,,,,,,4,187
ServletPipelineRequestDispatcherTest.java,23,223,0.1031390134529148,"
 * Tests forwarding and inclusion (RequestDispatcher actions from the servlet spec).
 *
 * @author Dhanji R. Prasanna (dhanji@gmail com)
 ",,,,,,,3,132
VarargsFilterDispatchIntegrationTest.java,17,136,0.125,"
 * This tests that filter stage of the pipeline dispatches correctly to guice-managed filters.
 *
 * <p>WARNING(dhanji): Non-parallelizable test =(
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ",,,,,,,5,191
TransferRequestIntegrationTest.java,17,164,0.10365853658536585,,,,,,,,1,0
FilterDefinitionTest.java,13,243,0.053497942386831275,"
 * Tests the lifecycle of the encapsulated {@link FilterDefinition} class.
 *
 * @author Dhanji R. Prasanna (dhanji@gmail com)
 ",,,,,,,3,122
MultiModuleDispatchIntegrationTest.java,12,83,0.14457831325301204,"
 * This tests that filter stage of the pipeline dispatches correctly to guice-managed filters with
 * multiple modules.
 *
 * <p>WARNING(dhanji): Non-parallelizable test =(
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ",,,,,,,6,214
ServletTestUtils.java,12,99,0.12121212121212122,"
 * Utilities for servlet tests.
 *
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Returns a FilterChain that does nothing.
 */
 
/**
 * Returns a fake, HttpServletRequest which stores attributes in a HashMap.
 */
 
/**
 * Returns a fake, HttpServletResponse which throws an exception if any of its methods are called.
 */
 
/**
 * Returns a fake, serializable HttpSession which stores attributes in a HashMap.
 */
 
","{
    return new FilterChain() {

        @Override
        public void doFilter(ServletRequest request, ServletResponse response) {
        }
    };
} 
{
    HttpServletRequest delegate = (HttpServletRequest) Proxy.newProxyInstance(HttpServletRequest.class.getClassLoader(), new Class[] { HttpServletRequest.class }, new ThrowingInvocationHandler());
    return new HttpServletRequestWrapper(delegate) {

        final Map<String, Object> attributes = Maps.newHashMap();

        final HttpSession session = newFakeHttpSession();

        @Override
        public String getMethod() {
            return ""GET"";
        }

        @Override
        public Object getAttribute(String name) {
            return attributes.get(name);
        }

        @Override
        public void setAttribute(String name, Object value) {
            attributes.put(name, value);
        }

        @Override
        public Map getParameterMap() {
            return ImmutableMap.of();
        }

        @Override
        public String getRequestURI() {
            return ""/"";
        }

        @Override
        public String getContextPath() {
            return """";
        }

        @Override
        public HttpSession getSession() {
            return session;
        }
    };
} 
{
    return (HttpServletResponse) Proxy.newProxyInstance(HttpServletResponse.class.getClassLoader(), new Class[] { HttpServletResponse.class }, new ThrowingInvocationHandler());
} 
{
    return (HttpSession) Proxy.newProxyInstance(HttpSession.class.getClassLoader(), new Class[] { HttpSession.class }, new FakeHttpSessionHandler());
} 
",,,,,3,71
UriPatternTypeTest.java,15,45,0.3333333333333333,,,,,,,,1,0
FiltersModuleBuilder.java,23,79,0.2911392405063291,"
 * Builds the guice module that binds configured filters, with their wrapper FilterDefinitions. Is
 * part of the binding EDSL. All Filters and Servlets are always bound as singletons.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 |non-static inner class so it can access state of enclosing module class",,,,,,,5,302
ServletModule.java,32,93,0.34408602150537637,"
 * Configures the servlet scopes and creates bindings for the servlet API objects so you can inject
 * the request, response, session, etc.
 *
 * <p>You should subclass this module to register servlets and filters in the {@link
 * #configureServlets()} method.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 |
   * See the EDSL examples at {@link ServletModule#configureServlets()}
   *
   * @since 2.0
   |
   * See the EDSL examples at {@link ServletModule#configureServlets()}
   *
   * @since 2.0
   ","/**
 * <h3>Servlet Mapping EDSL</h3>
 *
 * <p>Part of the EDSL builder language for configuring servlets and filters with guice-servlet.
 * Think of this as an in-code replacement for web.xml. Filters and servlets are configured here
 * using simple java method calls. Here is a typical example of registering a filter when creating
 * your Guice injector:
 *
 * <pre>
 *   Guice.createInjector(..., new ServletModule() {
 *
 *     {@literal @}Override
 *     protected void configureServlets() {
 *       <b>serve(""*.html"").with(MyServlet.class)</b>
 *     }
 *   }
 * </pre>
 *
 * This registers a servlet (subclass of {@code HttpServlet}) called {@code MyServlet} to service
 * any web pages ending in {@code .html}. You can also use a path-style syntax to register
 * servlets:
 *
 * <pre>
 *       <b>serve(""/my/*"").with(MyServlet.class)</b>
 * </pre>
 *
 * Every servlet (or filter) is required to be a singleton. If you cannot annotate the class
 * directly, you should add a separate {@code bind(..).in(Singleton.class)} rule elsewhere in your
 * module. Mapping a servlet that is bound under any other scope is an error.
 *
 * <p>
 *
 * <h4>Dispatch Order</h4>
 *
 * You are free to register as many servlets and filters as you like this way. They will be
 * compared and dispatched in the order in which the filter methods are called:
 *
 * <pre>
 *
 *   Guice.createInjector(..., new ServletModule() {
 *
 *     {@literal @}Override
 *     protected void configureServlets() {
 *       filter(""/*"").through(MyFilter.class);
 *       filter(""*.css"").through(MyCssFilter.class);
 *       filter(""*.jpg"").through(new MyJpgFilter());
 *       // etc..
 *
 *       serve(""*.html"").with(MyServlet.class);
 *       serve(""/my/*"").with(MyServlet.class);
 *       serve(""*.jpg"").with(new MyServlet());
 *       // etc..
 *      }
 *    }
 * </pre>
 *
 * This will traverse down the list of rules in lexical order. For example, a url ""{@code
 * /my/file.js}"" (after it runs through the matching filters) will first be compared against the
 * servlet mapping:
 *
 * <pre>
 *       serve(""*.html"").with(MyServlet.class);
 * </pre>
 *
 * And failing that, it will descend to the next servlet mapping:
 *
 * <pre>
 *       serve(""/my/*"").with(MyServlet.class);
 * </pre>
 *
 * Since this rule matches, Guice Servlet will dispatch to {@code MyServlet}. These two mapping
 * rules can also be written in more compact form using varargs syntax:
 *
 * <pre>
 *       serve(<b>""*.html"", ""/my/*""</b>).with(MyServlet.class);
 * </pre>
 *
 * This way you can map several URI patterns to the same servlet. A similar syntax is also
 * available for filter mappings.
 *
 * <p>
 *
 * <h4>Regular Expressions</h4>
 *
 * You can also map servlets (or filters) to URIs using regular expressions:
 *
 * <pre>
 *    <b>serveRegex(""(.)*ajax(.)*"").with(MyAjaxServlet.class)</b>
 * </pre>
 *
 * This will map any URI containing the text ""ajax"" in it to {@code MyAjaxServlet}. Such as:
 *
 * <ul>
 * <li>http://www.google.com/ajax.html
 * <li>http://www.google.com/content/ajax/index
 * <li>http://www.google.com/it/is_totally_ajaxian
 * </ul>
 *
 * <h3>Initialization Parameters</h3>
 *
 * Servlets (and filters) allow you to pass in init params using the {@code <init-param>} tag in
 * web.xml. You can similarly pass in parameters to Servlets and filters registered in
 * Guice-servlet using a {@link java.util.Map} of parameter name/value pairs. For example, to
 * initialize {@code MyServlet} with two parameters ({@code name=""Dhanji"", site=""google.com""}) you
 * could write:
 *
 * <pre>
 *  Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
 *  params.put(""name"", ""Dhanji"");
 *  params.put(""site"", ""google.com"");
 *
 *  ...
 *      serve(""/*"").with(MyServlet.class, <b>params</b>)
 * </pre>
 *
 * <p>
 *
 * <h3>Binding Keys</h3>
 *
 * You can also bind keys rather than classes. This lets you hide implementations with
 * package-local visbility and expose them using only a Guice module and an annotation:
 *
 * <pre>
 *  ...
 *      filter(""/*"").through(<b>Key.get(Filter.class, Fave.class)</b>);
 * </pre>
 *
 * Where {@code Filter.class} refers to the Servlet API interface and {@code Fave.class} is a
 * custom binding annotation. Elsewhere (in one of your own modules) you can bind this filter's
 * implementation:
 *
 * <pre>
 *   bind(Filter.class)<b>.annotatedWith(Fave.class)</b>.to(MyFilterImpl.class);
 * </pre>
 *
 * See {@link com.google.inject.Binder} for more information on binding syntax.
 *
 * <p>
 *
 * <h3>Multiple Modules</h3>
 *
 * It is sometimes useful to capture servlet and filter mappings from multiple different modules.
 * This is essential if you want to package and offer drop-in Guice plugins that provide servlet
 * functionality.
 *
 * <p>Guice Servlet allows you to register several instances of {@code ServletModule} to your
 * injector. The order in which these modules are installed determines the dispatch order of
 * filters and the precedence order of servlets. For example, if you had two servlet modules,
 * {@code RpcModule} and {@code WebServiceModule} and they each contained a filter that mapped to
 * the same URI pattern, {@code ""/*""}:
 *
 * <p>In {@code RpcModule}:
 *
 * <pre>
 *     filter(""/*"").through(RpcFilter.class);
 * </pre>
 *
 * In {@code WebServiceModule}:
 *
 * <pre>
 *     filter(""/*"").through(WebServiceFilter.class);
 * </pre>
 *
 * Then the order in which these filters are dispatched is determined by the order in which the
 * modules are installed:
 *
 * <pre>
 *   <b>install(new WebServiceModule());</b>
 *   install(new RpcModule());
 * </pre>
 *
 * In the case shown above {@code WebServiceFilter} will run first.
 *
 * @since 2.0
 */
 
/**
 * @param urlPattern Any Servlet-style pattern. examples: /*, /html/*, *.html, etc.
 * @since 2.0
 */
 
/**
 * @param urlPatterns Any Servlet-style patterns. examples: /*, /html/*, *.html, etc.
 * @since 4.1
 */
 
/**
 * @param regex Any Java-style regular expression.
 * @since 2.0
 */
 
/**
 * @param regexes Any Java-style regular expressions.
 * @since 4.1
 */
 
/**
 * @param urlPattern Any Servlet-style pattern. examples: /*, /html/*, *.html, etc.
 * @since 2.0
 */
 
/**
 * @param urlPatterns Any Servlet-style patterns. examples: /*, /html/*, *.html, etc.
 * @since 4.1
 */
 
/**
 * @param regex Any Java-style regular expression.
 * @since 2.0
 */
 
/**
 * @param regexes Any Java-style regular expressions.
 * @since 4.1
 */
 
/**
 * This method only works if you are using the {@linkplain GuiceServletContextListener} to create
 * your injector. Otherwise, it returns null.
 *
 * @return The current servlet context.
 * @since 3.0
 */
 
/**
 * @since 3.0
 */
 
/**
 * @since 3.0
 */
 
/**
 * @since 3.0
 */
 
/**
 * @since 3.0
 */
 
","{
} 
{
    return getFiltersModuleBuilder().filter(ImmutableList.<String>builder().add(urlPattern).add(morePatterns).build());
} 
{
    return getFiltersModuleBuilder().filter(ImmutableList.copyOf(urlPatterns));
} 
{
    return getFiltersModuleBuilder().filterRegex(ImmutableList.<String>builder().add(regex).add(regexes).build());
} 
{
    return getFiltersModuleBuilder().filterRegex(ImmutableList.copyOf(regexes));
} 
{
    return getServletModuleBuilder().serve(ImmutableList.<String>builder().add(urlPattern).add(morePatterns).build());
} 
{
    return getServletModuleBuilder().serve(ImmutableList.copyOf(urlPatterns));
} 
{
    return getServletModuleBuilder().serveRegex(ImmutableList.<String>builder().add(regex).add(regexes).build());
} 
{
    return getServletModuleBuilder().serveRegex(ImmutableList.copyOf(regexes));
} 
{
    return GuiceFilter.getServletContext();
} 
through 
through 
with 
with 
",,,,,16,521
InstanceServletBinding.java,22,5,4.4,"
 * A binding to a single instance of a servlet.
 *
 * @author sameb@google.com
 * @since 3.0
 ","/**
 * Returns the servlet instance that will be used.
 */
 
","getServletInstance 
",,,,,4,86
ScopingException.java,21,6,3.5,"
 * Exception thrown when there was a failure entering request scope.
 *
 * @author Chris Nokleberg
 * @since 4.0
 ",,,,,,,4,106
LinkedServletBinding.java,22,6,3.6666666666666665,"
 * A linked binding to a servlet.
 *
 * @author sameb@google.com
 * @since 3.0
 ","/**
 * Returns the key used to lookup the servlet instance.
 */
 
","getLinkedKey 
",,,,,4,72
LinkedFilterBinding.java,22,6,3.6666666666666665,"
 * A linked binding to a filter.
 *
 * @author sameb@google.com
 * @since 3.0
 ","/**
 * Returns the key used to lookup the filter instance.
 */
 
","getLinkedKey 
",,,,,4,71
InstanceFilterBinding.java,22,5,4.4,"
 * A binding to a single instance of a filter.
 *
 * @author sameb@google.com
 * @since 3.0
 ","/**
 * Returns the filter instance that will be used.
 */
 
","getFilterInstance 
",,,,,4,85
RequestScoper.java,8,9,0.8888888888888888," Object that can be used to apply a request scope to a block of code. | Closeable subclass that does not throw any exceptions from close. ","/**
 * Opens up the request scope until the returned object is closed. Implementations should ensure
 * (e.g. by blocking) that multiple threads cannot open the same request scope concurrently. It is
 * allowable to open the same request scope on the same thread, as long as open/close calls are
 * correctly nested.
 */
 
","open 
",,,,,1,138
InternalServletModule.java,32,93,0.34408602150537637,"
 * This is a left-factoring of all ServletModules installed in the system. In other words, this
 * module contains the bindings common to all ServletModules, and is bound exactly once per
 * injector.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 |
   * Special Provider that tries to obtain an injected servlet context, specific to the current
   * injector, failing which, it falls back to the static singleton instance that is available in
   * the legacy Guice Servlet.
   ",,,,,,,9,467
ManagedServletPipeline.java,51,137,0.3722627737226277,"
 * A wrapping dispatcher for servlets, in much the same way as {@link ManagedFilterPipeline} is for
 * filters.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ","/**
 * Introspects the injector and collects all instances of bound {@code List<ServletDefinition>}
 * into a master list.
 *
 * <p>We have a guarantee that {@link com.google.inject.Injector#getBindings()} returns a map that
 * preserves insertion order in entry-set iterators.
 */
 
/**
 * @return Returns a request dispatcher wrapped with a servlet mapped to the given path or null if
 *     no mapping was found.
 */
 
","{
    List<ServletDefinition> servletDefinitions = Lists.newArrayList();
    for (Binding<ServletDefinition> entry : injector.findBindingsByType(SERVLET_DEFS)) {
        servletDefinitions.add(entry.getProvider().get());
    }
    // Copy to a fixed size array for speed.
    return servletDefinitions.toArray(new ServletDefinition[servletDefinitions.size()]);
} 
{
    final String newRequestUri = path;
    // TODO(dhanji): check servlet spec to see if the following is legal or not.
    // Need to strip query string if requested...
    for (final ServletDefinition servletDefinition : servletDefinitions) {
        if (servletDefinition.shouldServe(path)) {
            return new RequestDispatcher() {

                @Override
                public void forward(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
                    Preconditions.checkState(!servletResponse.isCommitted(), ""Response has been committed--you can only call forward before"" + "" committing the response (hint: don't flush buffers)"");
                    // clear buffer before forwarding
                    servletResponse.resetBuffer();
                    ServletRequest requestToProcess;
                    if (servletRequest instanceof HttpServletRequest) {
                        requestToProcess = wrapRequest((HttpServletRequest) servletRequest, newRequestUri);
                    } else {
                        // This should never happen, but instead of throwing an exception
                        // we will allow a happy case pass thru for maximum tolerance to
                        // legacy (and internal) code.
                        requestToProcess = servletRequest;
                    }
                    // now dispatch to the servlet
                    doServiceImpl(servletDefinition, requestToProcess, servletResponse);
                }

                @Override
                public void include(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
                    // route to the target servlet
                    doServiceImpl(servletDefinition, servletRequest, servletResponse);
                }

                private void doServiceImpl(ServletDefinition servletDefinition, ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
                    servletRequest.setAttribute(REQUEST_DISPATCHER_REQUEST, Boolean.TRUE);
                    try {
                        servletDefinition.doService(servletRequest, servletResponse);
                    } finally {
                        servletRequest.removeAttribute(REQUEST_DISPATCHER_REQUEST);
                    }
                }
            };
        }
    }
    // otherwise, can't process
    return null;
} 
",,,"/**
 * A Marker constant attribute that when present in the request indicates to Guice servlet that
 * this request has been generated by a request dispatcher rather than the servlet pipeline. In
 * accordance with section 8.4.2 of the Servlet 2.4 specification.
 */
 
","Field REQUEST_DISPATCHER_REQUEST
",4,157
GuiceFilter.java,56,162,0.345679012345679,"
 * Apply this filter in web.xml above all other filters (typically), to all requests where you plan
 * to use servlet scopes. This is also needed in order to dispatch requests to injectable filters
 * and servlets:
 *
 * <pre>
 *  &lt;filter&gt;
 *    &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
 *    &lt;filter-class&gt;<b>com.google.inject.servlet.GuiceFilter</b>&lt;/filter-class&gt;
 *  &lt;/filter&gt;
 *
 *  &lt;filter-mapping&gt;
 *    &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
 *    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
 *  &lt;/filter-mapping&gt;
 *  </pre>
 *
 * This filter must appear before every filter that makes use of Guice injection or servlet scopes
 * functionality. Typically, you will only register this filter in web.xml and register any other
 * filters (and servlets) using a {@link ServletModule}.
 *
 * @author crazybob@google.com (Bob Lee)
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ",,,,,"/**
 * We allow both the static and dynamic versions of the pipeline to exist.
 */
 
/**
 * Used to inject the servlets configured via {@link ServletModule}
 */
 
","Field injectedPipeline
Field servletContext
",22,895
RequestParameters.java,21,10,2.1,"
 * Apply this to field or parameters of type {@code Map<String, String[]>} when you want the HTTP
 * request parameter map to be injected.
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,4,176
FilterDefinition.java,33,115,0.28695652173913044,"
 * An internal representation of a filter definition against a particular URI pattern.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ",,,,,,,3,134
FilterPipeline.java,55,91,0.6043956043956044,"
 * An internal dispatcher for guice-servlet registered servlets and filters. By default, we assume a
 * Guice 1.0 style servlet module is in play. In other words, we dispatch directly to the web.xml
 * pipeline after setting up scopes.
 *
 * <p>If on the other hand, {@link ServletModule} is used to register managed servlets and/or
 * filters, then a different pipeline is bound instead. Which, after dispatching to Guice-injected
 * filters and servlets continues to the web.xml pipeline (if necessary).
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ",,,,,,,9,541
LinkedServletBindingImpl.java,20,27,0.7407407407407407,"
 * Default implementation of LinkedServletBinding.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,90
ServletUtils.java,56,137,0.40875912408759124,"
 * Some servlet utility methods.
 *
 * @author ntang@google.com (Michael Tang)
 |
   * Gets the context path relative path of the URI. Returns the path of the resource relative to
   * the context path for a request's URI, or null if no path can be extracted.
   *
   * <p>Also performs url decoding and normalization of the path.
   | Accumulates byte sequences while decoding strings, and encodes them into a StringBuilder. ","/**
 * Normalizes a path by unescaping all safe, percent encoded characters.
 */
 
/**
 * Percent-decodes a US-ASCII string into a Unicode string. The specified encoding is used to
 * determine what characters are represented by any consecutive sequences of the form
 * ""%<i>XX</i>"". This is the lenient kind of decoding that will simply ignore and copy as-is any
 * ""%XX"" sequence that is invalid (for example, ""%HH"").
 *
 * @param string a percent-encoded US-ASCII string
 * @param encoding a character encoding
 * @param decodePlus boolean to indicate whether to decode '+' as ' '
 * @return a Unicode string
 */
 
","{
    StringBuilder sb = new StringBuilder(path.length());
    int queryStart = path.indexOf('?');
    String query = null;
    if (queryStart != -1) {
        query = path.substring(queryStart);
        path = path.substring(0, queryStart);
    }
    // Normalize the path.  we need to decode path segments, normalize and rejoin in order to
    // 1. decode and normalize safe percent escaped characters.  e.g. %70 -> 'p'
    // 2. decode and interpret dangerous character sequences. e.g. /%2E/ -> '/./' -> '/'
    // 3. preserve dangerous encoded characters. e.g. '/%2F/' -> '///' -> '/%2F'
    List<String> segments = new ArrayList<>();
    for (String segment : SLASH_SPLITTER.split(path)) {
        // This decodes all non-special characters from the path segment.  so if someone passes
        // /%2E/foo we will normalize it to /./foo and then /foo
        String normalized = UrlEscapers.urlPathSegmentEscaper().escape(lenientDecode(segment, UTF_8, false));
        if (""."".equals(normalized)) {
        // skip
        } else if ("".."".equals(normalized)) {
            if (segments.size() > 1) {
                segments.remove(segments.size() - 1);
            }
        } else {
            segments.add(normalized);
        }
    }
    SLASH_JOINER.appendTo(sb, segments);
    if (query != null) {
        sb.append(query);
    }
    return sb.toString();
} 
{
    checkNotNull(string);
    checkNotNull(encoding);
    if (decodePlus) {
        string = string.replace('+', ' ');
    }
    int firstPercentPos = string.indexOf('%');
    if (firstPercentPos < 0) {
        return string;
    }
    ByteAccumulator accumulator = new ByteAccumulator(string.length(), encoding);
    StringBuilder builder = new StringBuilder(string.length());
    if (firstPercentPos > 0) {
        builder.append(string, 0, firstPercentPos);
    }
    for (int srcPos = firstPercentPos; srcPos < string.length(); srcPos++) {
        char c = string.charAt(srcPos);
        if (c < 0x80) {
            // ASCII
            boolean processed = false;
            if (c == '%' && string.length() >= srcPos + 3) {
                String hex = string.substring(srcPos + 1, srcPos + 3);
                try {
                    int encoded = Integer.parseInt(hex, 16);
                    if (encoded >= 0) {
                        accumulator.append((byte) encoded);
                        srcPos += 2;
                        processed = true;
                    }
                } catch (NumberFormatException ignore) {
                // Expected case (badly formatted % group)
                }
            }
            if (!processed) {
                if (accumulator.isEmpty()) {
                    // We're not accumulating elements of a multibyte encoded
                    // char, so just toss it right into the result string.
                    builder.append(c);
                } else {
                    accumulator.append((byte) c);
                }
            }
        } else {
            // Non-ASCII
            // A non-ASCII char marks the end of a multi-char encoding sequence,
            // if one is in progress.
            accumulator.dumpTo(builder);
            builder.append(c);
        }
    }
    accumulator.dumpTo(builder);
    return builder.toString();
} 
",,,,,9,411
UriPatternMatcher.java,34,7,4.857142857142857,"
 * A general interface for matching a URI against a URI pattern. Guice-servlet provides regex and
 * servlet-style pattern matching out of the box.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ","/**
 * @param uri A ""contextual"" (i.e. relative) and ""normalized"" Request URI, *not* a complete one.
 * @return Returns true if the uri matches the pattern.
 */
 
/**
 * @param pattern The Path that this service pattern can match against.
 * @return Returns a canonical servlet path from this pattern. For instance, if the pattern is
 *     {@code /home/*} then the path extracted will be {@code /home}. Each pattern matcher
 *     implementation must decide and publish what a canonical path represents.
 *     <p>NOTE(dhanji): This method returns null for the regex pattern matcher.
 */
 
/**
 * Returns the type of pattern this is.
 */
 
/**
 * Returns the original pattern that was registered.
 */
 
","matches 
extractPath 
getPatternType 
getOriginalPattern 
",,,,,4,193
ContinuingHttpServletRequest.java,28,102,0.27450980392156865,"
 * A wrapper for requests that makes requests immutable, taking a snapshot of the original request.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ",,,,,,,3,147
UriPatternType.java,38,131,0.2900763358778626,"
 * An enumeration of the available URI-pattern matching styles
 *
 * @since 3.0
 |
   * Matches URIs using the pattern grammar of the Servlet API and web.xml.
   *
   * @author dhanji@gmail.com (Dhanji R. Prasanna)
   |
   * Matches URIs using a regular expression.
   *
   * @author dhanji@gmail.com (Dhanji R. Prasanna)
   ",,,,,,,11,305
FilterChainInvocation.java,45,83,0.5421686746987951,"
 * A Filter chain impl which basically passes itself to the ""current"" filter and iterates the chain
 * on {@code doFilter()}. Modeled on something similar in Apache Tomcat.
 *
 * <p>Following this, it attempts to dispatch to guice-servlet's registered servlets using the
 * ManagedServletPipeline.
 *
 * <p>And the end, it proceeds to the web.xml (default) servlet filter chain, if needed.
 *
 * @author Dhanji R. Prasanna
 * @since 1.0
 ","/**
 * Iterates over the remaining filter definitions. Returns the first applicable filter, or null if
 * none apply.
 */
 
/**
 * Removes stacktrace elements related to AOP internal mechanics from the throwable's stack trace
 * and any causes it may have.
 */
 
","{
    while (++index < filterDefinitions.length) {
        Filter filter = filterDefinitions[index].getFilterIfMatching(request);
        if (filter != null) {
            return filter;
        }
    }
    return null;
} 
{
    for (Throwable t = throwable; t != null; t = t.getCause()) {
        StackTraceElement[] stackTrace = t.getStackTrace();
        List<StackTraceElement> pruned = Lists.newArrayList();
        for (StackTraceElement element : stackTrace) {
            String name = element.getClassName() + ""."" + element.getMethodName();
            if (!SERVLET_INTERNAL_METHODS.contains(name)) {
                pruned.add(element);
            }
        }
        t.setStackTrace(pruned.toArray(new StackTraceElement[pruned.size()]));
    }
} 
",,,,,10,418
InstanceServletBindingImpl.java,20,24,0.8333333333333334,"
 * Default implementation of InstanceServletBinding.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,92
LinkedFilterBindingImpl.java,20,27,0.7407407407407407,"
 * Default implementation of LinkedFilterBinding.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,89
InstanceFilterBindingImpl.java,20,24,0.8333333333333334,"
 * Default implementation of InstanceFilterBinding.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,91
AbstractServletModuleBinding.java,20,32,0.625,"
 * Abstract implementation for all servlet module bindings
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,98
ServletModuleTargetVisitor.java,46,12,3.8333333333333335,"
 * A visitor for the servlet extension.
 *
 * <p>If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 * {@link ServletModule} will be visited through this interface.
 *
 * @since 3.0
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Visits a filter binding created by {@link ServletModule#filter}, where {@link
 * FilterKeyBindingBuilder#through} is called with a Class or Key.
 *
 * <p>If multiple patterns were specified, this will be called multiple times.
 */
 
/**
 * Visits a filter binding created by {@link ServletModule#filter} where {@link
 * FilterKeyBindingBuilder#through} is called with a {@link Filter}.
 *
 * <p>If multiple patterns were specified, this will be called multiple times.
 */
 
/**
 * Visits a servlet binding created by {@link ServletModule#serve} where {@link
 * ServletKeyBindingBuilder#with}, is called with a Class or Key.
 *
 * <p>If multiple patterns were specified, this will be called multiple times.
 */
 
/**
 * Visits a servlet binding created by {@link ServletModule#serve} where {@link
 * ServletKeyBindingBuilder#with}, is called with an {@link HttpServlet}.
 *
 * <p>If multiple patterns were specified, this will be called multiple times.
 */
 
","visit 
visit 
visit 
visit 
",,,,,7,249
SessionScoped.java,21,10,2.1,"
 * Apply this to implementation classes when you want one instance per session.
 *
 * @see com.google.inject.Scopes#SINGLETON
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,4,160
ServletScopes.java,160,234,0.6837606837606838,"
 * Servlet scopes.
 *
 * @author crazybob@google.com (Bob Lee)
 | A sentinel attribute value representing null. ","/**
 * Wraps the given callable in a contextual callable that ""continues"" the HTTP request in another
 * thread. This acts as a way of transporting request context data from the request processing
 * thread to to worker threads.
 *
 * <p>There are some limitations:
 *
 * <ul>
 * <li>Derived objects (i.e. anything marked @RequestScoped will not be transported.
 * <li>State changes to the HttpServletRequest after this method is called will not be seen in the
 *     continued thread.
 * <li>Only the HttpServletRequest, ServletContext and request parameter map are available in the
 *     continued thread. The response and session are not available.
 * </ul>
 *
 * <p>The returned callable will throw a {@link ScopingException} when called if the HTTP request
 * scope is still active on the current thread.
 *
 * @param callable code to be executed in another thread, which depends on the request scope.
 * @param seedMap the initial set of scoped instances for Guice to seed the request scope with. To
 *     seed a key with null, use {@code null} as the value.
 * @return a callable that will invoke the given callable, making the request context available to
 *     it.
 * @throws OutOfScopeException if this method is called from a non-request thread, or if the
 *     request has completed.
 * @since 3.0
 * @deprecated You probably want to use {@code transferRequest} instead
 */
 
/**
 * Wraps the given callable in a contextual callable that ""transfers"" the request to another
 * thread. This acts as a way of transporting request context data from the current thread to a
 * future thread.
 *
 * <p>As opposed to {@link #continueRequest}, this method propagates all existing scoped objects.
 * The primary use case is in server implementations where you can detach the request processing
 * thread while waiting for data, and reattach to a different thread to finish processing at a
 * later time.
 *
 * <p>Because request-scoped objects are not typically thread-safe, the callable returned by this
 * method must not be run on a different thread until the current request scope has terminated.
 * The returned callable will block until the current thread has released the request scope.
 *
 * @param callable code to be executed in another thread, which depends on the request scope.
 * @return a callable that will invoke the given callable, making the request context available to
 *     it.
 * @throws OutOfScopeException if this method is called from a non-request thread, or if the
 *     request has completed.
 * @since 4.0
 */
 
/**
 * Returns an object that ""transfers"" the request to another thread. This acts as a way of
 * transporting request context data from the current thread to a future thread. The transferred
 * scope is the one active for the thread that calls this method. A later call to {@code open()}
 * activates the transferred the scope, including propagating any objects scoped at that time.
 *
 * <p>As opposed to {@link #continueRequest}, this method propagates all existing scoped objects.
 * The primary use case is in server implementations where you can detach the request processing
 * thread while waiting for data, and reattach to a different thread to finish processing at a
 * later time.
 *
 * <p>Because request-scoped objects are not typically thread-safe, it is important to avoid
 * applying the same request scope concurrently. The returned Scoper will block on open until the
 * current thread has released the request scope.
 *
 * @return an object that when opened will initiate the request scope
 * @throws OutOfScopeException if this method is called from a non-request thread, or if the
 *     request has completed.
 * @since 4.1
 */
 
/**
 * Returns true if {@code binding} is request-scoped. If the binding is a {@link
 * com.google.inject.spi.LinkedKeyBinding linked key binding} and belongs to an injector (i. e. it
 * was retrieved via {@link Injector#getBinding Injector.getBinding()}), then this method will
 * also return true if the target binding is request-scoped.
 *
 * @since 4.0
 */
 
/**
 * Scopes the given callable inside a request scope. This is not the same as the HTTP request
 * scope, but is used if no HTTP request scope is in progress. In this way, keys can be scoped
 * as @RequestScoped and exist in non-HTTP requests (for example: RPC requests) as well as in HTTP
 * request threads.
 *
 * <p>The returned callable will throw a {@link ScopingException} when called if there is a
 * request scope already active on the current thread.
 *
 * @param callable code to be executed which depends on the request scope. Typically in another
 *     thread, but not necessarily so.
 * @param seedMap the initial set of scoped instances for Guice to seed the request scope with. To
 *     seed a key with null, use {@code null} as the value.
 * @return a callable that when called will run inside the a request scope that exposes the
 *     instances in the {@code seedMap} as scoped keys.
 * @since 3.0
 */
 
/**
 * Returns an object that will apply request scope to a block of code. This is not the same as the
 * HTTP request scope, but is used if no HTTP request scope is in progress. In this way, keys can
 * be scoped as @RequestScoped and exist in non-HTTP requests (for example: RPC requests) as well
 * as in HTTP request threads.
 *
 * <p>The returned object will throw a {@link ScopingException} when opened if there is a request
 * scope already active on the current thread.
 *
 * @param seedMap the initial set of scoped instances for Guice to seed the request scope with. To
 *     seed a key with null, use {@code null} as the value.
 * @return an object that when opened will initiate the request scope
 * @since 4.1
 */
 
/**
 * Validates the key and object, ensuring the value matches the key type, and canonicalizing null
 * objects to the null sentinel.
 */
 
","{
    return wrap(callable, continueRequest(seedMap));
} 
{
    return wrap(callable, transferRequest());
} 
{
    return (GuiceFilter.localContext.get() != null) ? transferHttpRequest() : transferNonHttpRequest();
} 
{
    return Scopes.isScoped(binding, ServletScopes.REQUEST, RequestScoped.class);
} 
{
    return wrap(callable, scopeRequest(seedMap));
} 
{
    Preconditions.checkArgument(null != seedMap, ""Seed map cannot be null, try passing in Collections.emptyMap() instead."");
    // Copy the seed values into our local scope map.
    final Context context = new Context();
    Map<Key<?>, Object> validatedAndCanonicalizedMap = Maps.transformEntries(seedMap, ServletScopes::validateAndCanonicalizeValue);
    context.map.putAll(validatedAndCanonicalizedMap);
    return new RequestScoper() {

        @Override
        public CloseableScope open() {
            checkScopingState(null == GuiceFilter.localContext.get(), ""An HTTP request is already in progress, cannot scope a new request in this thread."");
            checkScopingState(null == requestScopeContext.get(), ""A request scope is already in progress, cannot scope a new request in this thread."");
            return context.open();
        }
    };
} 
{
    if (object == null || object == NullObject.INSTANCE) {
        return NullObject.INSTANCE;
    }
    Preconditions.checkArgument(key.getTypeLiteral().getRawType().isInstance(object), ""Value[%s] of type[%s] is not compatible with key[%s]"", object, object.getClass().getName(), key);
    return object;
} 
",,,"/**
 * A threadlocal scope map for non-http request scopes. The {@link #REQUEST} scope falls back to
 * this scope map if no http request is available, and requires {@link #scopeRequest} to be called
 * as an alternative.
 */
 
/**
 * HTTP servlet request scope.
 */
 
/**
 * Keys bound in request-scope which are handled directly by GuiceFilter.
 */
 
/**
 * HTTP session scope.
 */
 
","Field requestScopeContext
Field REQUEST
Field REQUEST_CONTEXT_KEYS
Field SESSION
",4,106
DefaultFilterPipeline.java,21,22,0.9545454545454546,"
 * This default pipeline simply dispatches to web.xml's servlet pipeline.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 * @see com.google.inject.servlet.ManagedFilterPipeline See Also ManagedFilterPipeline.
 ",,,,,,,4,207
ManagedFilterPipeline.java,55,91,0.6043956043956044,"
 * Central routing/dispatch class handles lifecycle of managed filters, and delegates to the servlet
 * pipeline.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ","/**
 * Introspects the injector and collects all instances of bound {@code List<FilterDefinition>}
 * into a master list.
 *
 * <p>We have a guarantee that {@link com.google.inject.Injector#getBindings()} returns a map that
 * preserves insertion order in entry-set iterators.
 */
 
/**
 * Used to create an proxy that dispatches either to the guice-servlet pipeline or the regular
 * pipeline based on uri-path match. This proxy also provides minimal forwarding support.
 *
 * <p>We cannot forward from a web.xml Servlet/JSP to a guice-servlet (because the filter pipeline
 * is not called again). However, we can wrap requests with our own dispatcher to forward the
 * *other* way. web.xml Servlets/JSPs can forward to themselves as per normal.
 *
 * <p>This is not a problem cuz we intend for people to migrate from web.xml to guice-servlet,
 * incrementally, but not the other way around (which, we should actively discourage).
 */
 
","{
    List<FilterDefinition> filterDefinitions = Lists.newArrayList();
    for (Binding<FilterDefinition> entry : injector.findBindingsByType(FILTER_DEFS)) {
        filterDefinitions.add(entry.getProvider().get());
    }
    // Copy to a fixed-size array for speed of iteration.
    return filterDefinitions.toArray(new FilterDefinition[filterDefinitions.size()]);
} 
{
    // don't wrap the request if there are no servlets mapped. This prevents us from inserting our
    // wrapper unless it's actually going to be used. This is necessary for compatibility for apps
    // that downcast their HttpServletRequests to a concrete implementation.
    if (!servletPipeline.hasServletsMapped()) {
        return servletRequest;
    }
    HttpServletRequest request = (HttpServletRequest) servletRequest;
    // noinspection OverlyComplexAnonymousInnerClass
    return new HttpServletRequestWrapper(request) {

        @Override
        public RequestDispatcher getRequestDispatcher(String path) {
            final RequestDispatcher dispatcher = servletPipeline.getRequestDispatcher(path);
            return (null != dispatcher) ? dispatcher : super.getRequestDispatcher(path);
        }
    };
} 
",,,,,4,159
ServletDefinition.java,59,199,0.2964824120603015,"
 * An internal representation of a servlet definition mapped to a particular URI pattern. Also
 * performs the request dispatch to that servlet. How nice and OO =)
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ","/**
 * Wrapper around the service chain to ensure a servlet is servicing what it must and provides it
 * with a wrapped request.
 *
 * @return Returns true if this servlet triggered for the given request. Or false if guice-servlet
 *     should continue dispatching down the servlet pipeline.
 * @throws IOException If thrown by underlying servlet
 * @throws ServletException If thrown by underlying servlet
 */
 
/**
 * Utility that delegates to the actual service method of the servlet wrapped with a contextual
 * request (i.e. with correctly computed path info).
 *
 * <p>We need to suppress deprecation coz we use HttpServletRequestWrapper, which implements
 * deprecated API for backwards compatibility.
 */
 
","{
    final HttpServletRequest request = (HttpServletRequest) servletRequest;
    final String path = ServletUtils.getContextRelativePath(request);
    final boolean serve = shouldServe(path);
    // invocations of the chain end at the first matched servlet
    if (serve) {
        doService(servletRequest, servletResponse);
    }
    // return false if no servlet matched (so we can proceed down to the web.xml servlets)
    return serve;
} 
{
    HttpServletRequest request = new HttpServletRequestWrapper((HttpServletRequest) servletRequest) {

        private boolean pathComputed;

        private String path;

        private boolean pathInfoComputed;

        private String pathInfo;

        @Override
        public String getPathInfo() {
            if (!isPathInfoComputed()) {
                String servletPath = getServletPath();
                int servletPathLength = servletPath.length();
                String requestUri = getRequestURI();
                pathInfo = requestUri.substring(getContextPath().length()).replaceAll(""[/]{2,}"", ""/"");
                // See: https://github.com/google/guice/issues/372
                if (pathInfo.startsWith(servletPath)) {
                    pathInfo = pathInfo.substring(servletPathLength);
                    // Corner case: when servlet path & request path match exactly (without trailing '/'),
                    // then pathinfo is null.
                    if (pathInfo.isEmpty() && servletPathLength > 0) {
                        pathInfo = null;
                    } else {
                        try {
                            pathInfo = new URI(pathInfo).getPath();
                        } catch (URISyntaxException e) {
                        // ugh, just leave it alone then
                        }
                    }
                } else {
                    // we know nothing additional about the URI.
                    pathInfo = null;
                }
                pathInfoComputed = true;
            }
            return pathInfo;
        }

        // NOTE(dhanji): These two are a bit of a hack to help ensure that request dispatcher-sent
        // requests don't use the same path info that was memoized for the original request.
        // NOTE(iqshum): I don't think this is possible, since the dispatcher-sent request would
        // perform its own wrapping.
        private boolean isPathInfoComputed() {
            return pathInfoComputed && servletRequest.getAttribute(REQUEST_DISPATCHER_REQUEST) == null;
        }

        private boolean isPathComputed() {
            return pathComputed && servletRequest.getAttribute(REQUEST_DISPATCHER_REQUEST) == null;
        }

        @Override
        public String getServletPath() {
            return computePath();
        }

        @Override
        public String getPathTranslated() {
            final String info = getPathInfo();
            return (null == info) ? null : getRealPath(info);
        }

        // Memoizer pattern.
        private String computePath() {
            if (!isPathComputed()) {
                String servletPath = super.getServletPath();
                path = patternMatcher.extractPath(servletPath);
                pathComputed = true;
                if (null == path) {
                    path = servletPath;
                }
            }
            return path;
        }
    };
    doServiceImpl(request, (HttpServletResponse) servletResponse);
} 
",,,,,4,209
RequestScoped.java,20,10,2.0,"
 * Apply this to implementation classes when you want one instance per request.
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,3,119
ScopingOnly.java,22,10,2.2,"
 * Annotates a {@link GuiceFilter} that provides scope functionality, but doesn't dispatch to {@link
 * ServletModule} bound servlets or filters.
 *
 * @author iqshum@google.com (Isaac Shum)
 * @since 4.0
 ",,,,,,,5,196
GuiceServletContextListener.java,26,25,1.04,"
 * As of Guice 2.0 you can still use (your subclasses of) {@code GuiceServletContextListener} class
 * as a logical place to create and configure your injector. This will ensure the injector is
 * created when the web application is deployed.
 *
 * @author Kevin Bourrillion (kevinb@google.com)
 * @since 2.0
 ","/**
 * Override this method to create (or otherwise obtain a reference to) your injector.
 */
 
","getInjector 
",,,,,6,298
ServletsModuleBuilder.java,23,89,0.25842696629213485,"
 * Builds the guice module that binds configured servlets, with their wrapper ServletDefinitions. Is
 * part of the binding EDSL. Very similar to {@link com.google.inject.servlet.FiltersModuleBuilder}.
 *
 * @author Dhanji R. Prasanna (dhanji@gmail.com)
 |non-static inner class so it can access state of enclosing module class",,,,,,,5,319
ServletModuleBinding.java,20,32,0.625,"
 * A binding created by {@link ServletModule}.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 3.0
 ","/**
 * Returns the pattern type that this binding was created with.
 */
 
/**
 * Returns the pattern used to match against the binding.
 */
 
/**
 * Returns any context params supplied when creating the binding.
 */
 
/**
 * Returns true if the given URI will match this binding.
 */
 
","getUriPatternType 
getPattern 
getInitParams 
matchesUri 
",,,,,4,98
MiniGuiceTest.java,15,255,0.058823529411764705,,,,,,,,1,0
MiniGuice.java,55,319,0.1724137931034483,"
 * Proof of concept. A tiny injector suitable for tiny applications.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 3.0
 ","/**
 * Creates an injector defined by {@code modules} and immediately uses it to create an instance of
 * {@code type}. The modules can be of any type, and must contain {@code @Provides} methods.
 *
 * <p>The following injection features are supported:
 *
 * <ul>
 * <li>Field injection. A class may have any number of field injections, and fields may be of any
 *     visibility. Static fields will be injected each time an instance is injected.
 * <li>Constructor injection. A class may have a single {@code @Inject}-annotated constructor.
 *     Classes that have fields injected may omit the {@link @Inject} annotation if they have a
 *     public no-arguments constructor.
 * <li>Injection of {@code @Provides} method parameters.
 * <li>{@code @Provides} methods annotated {@code @Singleton}.
 * <li>Constructor-injected classes annotated {@code @Singleton}.
 * <li>Injection of {@link Provider}s.
 * <li>Binding annotations on injected parameters and fields.
 * <li>Guice annotations.
 * <li>JSR 330 annotations.
 * <li>Eager loading of singletons.
 * </ul>
 *
 * <p><strong>Note that method injection is not supported.</strong>
 */
 
","{
    Key key = new Key(type, null);
    MiniGuice miniGuice = new MiniGuice();
    for (Object module : modules) {
        miniGuice.install(module);
    }
    miniGuice.requireKey(key, ""root injection"");
    miniGuice.addJitBindings();
    miniGuice.addProviderBindings();
    miniGuice.eagerlyLoadSingletons();
    Provider<?> provider = miniGuice.bindings.get(key);
    return type.cast(provider.get());
} 
",,,,,4,128
JmxTest.java,17,31,0.5483870967741935," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
Manager.java,34,58,0.5862068965517241,"
 * Provides a JMX interface to Guice.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Registers all the bindings of an Injector with the platform MBean server. Consider using the
 * name of your root {@link Module} class as the domain.
 */
 
/**
 * Registers all the bindings of an Injector with the given MBean server. Consider using the name
 * of your root {@link Module} class as the domain.
 */
 
/**
 * Run with no arguments for usage instructions.
 */
 
","{
    manage(ManagementFactory.getPlatformMBeanServer(), domain, injector);
} 
{
    // Register each binding independently.
    for (Binding<?> binding : injector.getBindings().values()) {
        // Construct the name manually so we can ensure proper ordering of the
        // key/value pairs.
        StringBuilder name = new StringBuilder();
        name.append(domain).append("":"");
        Key<?> key = binding.getKey();
        name.append(""type="").append(quote(key.getTypeLiteral().toString()));
        Annotation annotation = key.getAnnotation();
        if (annotation != null) {
            name.append("",annotation="").append(quote(annotation.toString()));
        } else {
            Class<? extends Annotation> annotationType = key.getAnnotationType();
            if (annotationType != null) {
                name.append("",annotation="").append(quote(""@"" + annotationType.getName()));
            }
        }
        try {
            server.registerMBean(new ManagedBinding(binding), new ObjectName(name.toString()));
        } catch (MalformedObjectNameException e) {
            throw new RuntimeException(""Bad object name: "" + name, e);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
} 
{
    if (args.length != 1) {
        System.err.println(""Usage: java -Dcom.sun.management.jmxremote "" + Manager.class.getName() + "" [module class name]"");
        System.err.println(""Then run 'jconsole' to connect."");
        System.exit(1);
    }
    Module module = (Module) Class.forName(args[0]).newInstance();
    Injector injector = Guice.createInjector(module);
    manage(args[0], injector);
    System.out.println(""Press Ctrl+C to exit..."");
    // Sleep forever.
    Thread.sleep(Long.MAX_VALUE);
} 
",,,,,3,77
ManagedBindingMBean.java,23,6,3.8333333333333335,"
 * JMX interface to bindings.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Gets the source of this binding.
 */
 
/**
 * Gets the provider to which this binding is bound.
 */
 
/**
 * Gets the binding key.
 */
 
","getSource 
getProvider 
getKey 
",,,,,3,69
ManagedBinding.java,15,20,0.75,,,,,,,,1,0
ThrowingProviderTest.java,25,863,0.028968713789107765,"
 * @author jmourits@google.com (Jerome Mourits)
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,2,94
CheckedProviderTest.java,34,1466,0.023192360163710776,"
 * @author jmourits@google.com (Jerome Mourits)
 * @author jessewilson@google.com (Jesse Wilson)
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,133
TestScope.java,20,33,0.6060606060606061,"
 * A simple scope that can be explicitly reset.
 *
 * @author jmourits@google.com (Jerome Mourits)
 ",,,,,,,3,94
CheckedProviderMethodsModuleTest.java,17,143,0.11888111888111888," Test methods for {@link CheckedProviderMethodsModule}. ",,,,,,,1,56
CheckedProvidersTest.java,7,125,0.056,"
 * Unit tests for {@link CheckedProviders}.
 *
 * @author eatnumber1@google.com (Russ Harmon)
 ",,,,,,,3,89
ThrowingProvider.java,34,6,5.666666666666667,"
 * Alternative to the Guice {@link com.google.inject.Provider} that throws a checked Exception.
 * Users may not inject {@code T} directly.
 *
 * <p>This interface must be extended to use application-specific exception types. Such
 * subinterfaces may not define new methods:
 *
 * <pre>
 * public interface RemoteProvider&lt;T&gt; extends ThrowingProvider&lt;T, RemoteException&gt; { }
 * </pre>
 *
 * <p>When this type is bound using {@link ThrowingProviderBinder}, the value returned or exception
 * thrown by {@link #get} will be scoped. As a consequence, {@link #get} will invoked at most once
 * within each scope.
 *
 * @author jmourits@google.com (Jerome Mourits)
 * @author jessewilson@google.com (Jesse Wilson)
 * @deprecated use {@link CheckedProvider} instead.
 ",,,,,,,17,740
CheckedProviders.java,51,155,0.32903225806451614,"
 * Static utility methods for creating and working with instances of {@link CheckedProvider}.
 *
 * @author eatnumber1@google.com (Russ Harmon)
 * @since 4.2
 ","/**
 * Returns a {@link CheckedProvider} which always provides {@code instance}.
 *
 * <p>The provider type passed as {@code providerType} must be an interface. Calls to methods
 * other than {@link CheckedProvider#get} will throw {@link UnsupportedOperationException}.
 *
 * @param providerType the type of the {@link CheckedProvider} to return
 * @param instance the instance that should always be provided
 */
 
/**
 * Returns a {@link CheckedProvider} which always provides {@code instance}.
 *
 * @param providerType the type of the {@link CheckedProvider} to return
 * @param instance the instance that should always be provided
 * @see #of(TypeLiteral, T)
 */
 
/**
 * Returns a {@link CheckedProvider} which always throws exceptions.
 *
 * <p>This method uses the nullary (no argument) constructor of {@code throwable} to create a new
 * instance of the given {@link Throwable} on each method invocation which is then thrown
 * immediately.
 *
 * <p>See {@link #of(TypeLiteral, T)} for more information.
 *
 * @param providerType the type of the {@link CheckedProvider} to return
 * @param throwable the type of the {@link Throwable} to throw
 * @see #of(TypeLiteral, T)
 */
 
/**
 * Returns a {@link CheckedProvider} which always throws exceptions.
 *
 * @param providerType the type of the {@link CheckedProvider} to return
 * @param throwable the type of the {@link Throwable} to throw
 * @see #throwing(TypeLiteral, Class)
 */
 
","{
    return generateProvider(providerType, Optional.fromNullable(instance), new ReturningHandler<T>(instance));
} 
{
    return of(TypeLiteral.get(providerType), instance);
} 
{
    // TODO(eatnumber1): Understand why TypeLiteral#getRawType returns a Class<? super T> rather
    // than a Class<T> and remove this unsafe cast.
    Class<P> providerRaw = (Class) providerType.getRawType();
    checkThrowable(providerRaw, throwable);
    return generateProvider(providerType, Optional.<T>absent(), ThrowingHandler.forClass(throwable));
} 
{
    return throwing(TypeLiteral.get(providerType), throwable);
} 
",,,,,4,151
CheckedProviderMethodsModule.java,28,116,0.2413793103448276,"
 * Creates bindings to methods annotated with {@literal @}{@link CheckedProvides}. Use the scope and
 * binding annotations on the provider method to configure the binding.
 *
 * @author sameb@google.com (Sam Berlin)
 | A provider that returns a logger based on the method name. ","/**
 * Returns a module which creates bindings for provider methods from the given module.
 */
 
","{
    // avoid infinite recursion, since installing a module always installs itself
    if (module instanceof CheckedProviderMethodsModule) {
        return Modules.EMPTY_MODULE;
    }
    return new CheckedProviderMethodsModule(module);
} 
",,,,,5,271
CheckedProviderWithDependencies.java,21,4,5.25,"
 * A checked provider with dependencies, so {@link HasDependencies} can be implemented when using
 * the {@link SecondaryBinder#using} methods.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,4,181
CheckedProvideUtils.java,24,72,0.3333333333333333,"
 * Utilities for the throwing provider module.
 *
 * @author sameb@google.com (Sam Berlin)
 ","/**
 * Adds errors to the binder if the exceptions aren't valid.
 */
 
","{
    // Validate the exceptions in the method match the exceptions
    // in the CheckedProvider.
    for (TypeLiteral<?> exType : actualExceptionTypes) {
        Class<?> exActual = exType.getRawType();
        // Ignore runtime exceptions & errors.
        if (RuntimeException.class.isAssignableFrom(exActual) || Error.class.isAssignableFrom(exActual)) {
            continue;
        }
        boolean notAssignable = true;
        for (Class<? extends Throwable> exExpected : expectedExceptionTypes) {
            if (exExpected.isAssignableFrom(exActual)) {
                notAssignable = false;
                break;
            }
        }
        if (notAssignable) {
            binder.addError(""%s is not compatible with the exceptions (%s) declared in "" + ""the CheckedProvider interface (%s)"", exActual, expectedExceptionTypes, checkedProvider);
        }
    }
} 
",,,,,3,86
ProviderChecker.java,5,104,0.04807692307692308," Helper methods to verify the correctness of CheckedProvider interfaces. ",,,,,,,1,73
CheckedProvides.java,33,13,2.5384615384615383,"
 * Annotates methods of a {@link com.google.inject.Module} to create a {@link CheckedProvider}
 * method binding that can throw exceptions. The method's return type is bound to a {@link
 * CheckedProvider} that can be injected. Guice will pass dependencies to the method as parameters.
 * Install {@literal @}CheckedProvides methods by using {@link
 * ThrowingProviderBinder#forModule(com.google.inject.Module)} on the module where the methods are
 * declared.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 3.0
 ",,,,,,,9,502
CheckedProvider.java,34,4,8.5,"
 * Alternative to the Guice {@link com.google.inject.Provider} that throws a checked Exception.
 * Users may not inject {@code T} directly.
 *
 * <p>This interface must be extended to use application-specific exception types. Such
 * subinterfaces may not define new methods, but may narrow the exception type.
 *
 * <pre>
 * public interface RemoteProvider&lt;T&gt; extends CheckedProvider&lt;T&gt; {
 *   T get() throws CustomExceptionOne, CustomExceptionTwo;
 * }
 * </pre>
 *
 * <p>When this type is bound using {@link ThrowingProviderBinder}, the value returned or exception
 * thrown by {@link #get} will be scoped. As a consequence, {@link #get} will invoked at most once
 * within each scope.
 *
 * @since 3.0
 ",,,,,,,17,685
ThrowingInject.java,28,11,2.5454545454545454,"
 * A version of {@literal @}{@link Inject} designed for ThrowingProviders. Use by:
 *
 * <pre><code>ThrowingProviderBinder.create(binder())
 *    .bind(RemoteProvider.class, Customer.class)
 *    .providing(CustomerImpl.class);
 * </code></pre>
 *
 * where CustomerImpl has a constructor annotated with ThrowingInject.
 *
 * @author sameb@google.com (Sam Berlin)
 * @since 4.0
 ",,,,,,,11,356
ThrowingProviderBinder.java,98,322,0.30434782608695654,"
 * Builds a binding for a {@link CheckedProvider}.
 *
 * <p>You can use a fluent API and custom providers:
 *
 * <pre><code>ThrowingProviderBinder.create(binder())
 *    .bind(RemoteProvider.class, Customer.class)
 *    .to(RemoteCustomerProvider.class)
 *    .in(RequestScope.class);
 * </code></pre>
 *
 * or, you can use throwing provider methods:
 *
 * <pre><code>class MyModule extends AbstractModule {
 *   configure() {
 *     install(ThrowingProviderBinder.forModule(this));
 *   }
 *
 *   {@literal @}CheckedProvides(RemoteProvider.class)
 *   {@literal @}RequestScope
 *   Customer provideCustomer(FlakyCustomerCreator creator) throws RemoteException {
 *     return creator.getCustomerOrThrow();
 *   }
 * }
 * </code></pre>
 *
 * You also can declare that a CheckedProvider construct a particular class whose constructor throws
 * an exception:
 *
 * <pre><code>ThrowingProviderBinder.create(binder())
 *    .bind(RemoteProvider.class, Customer.class)
 *    .providing(CustomerImpl.class)
 *    .in(RequestScope.class);
 * </code></pre>
 *
 * @author jmourits@google.com (Jerome Mourits)
 * @author jessewilson@google.com (Jesse Wilson)
 * @author sameb@google.com (Sam Berlin)
 |
   * Represents the returned value from a call to {@link CheckedProvider#get()}. This is the value
   * that will be scoped by Guice.
   |
   * RuntimeException class to wrap exceptions from the checked provider. The regular guice provider
   * can throw it and the checked provider proxy extracts the underlying exception and rethrows it.
   ","/**
 * Returns a module that installs {@literal @}{@link CheckedProvides} methods.
 *
 * @since 3.0
 */
 
/**
 * @deprecated Use {@link #bind(Class, Class)} or {@link #bind(Class, TypeLiteral)} instead.
 */
 
/**
 * @since 4.0
 */
 
/**
 * @since 4.0
 */
 
/**
 * Determines if exceptions should be scoped. By default exceptions are scoped.
 *
 * @param scopeExceptions whether exceptions should be scoped.
 * @since 4.0
 */
 
/**
 * @since 4.0
 */
 
/**
 * @since 4.0
 */
 
/**
 * Returns the exception type declared to be thrown by the get method of {@code interfaceType}.
 */
 
","{
    return CheckedProviderMethodsModule.forModule(module);
} 
{
    return new SecondaryBinder<P, Object>(interfaceType, clazz);
} 
{
    return new SecondaryBinder<P, T>(interfaceType, clazz);
} 
{
    return new SecondaryBinder<P, T>(interfaceType, typeLiteral.getType());
} 
{
    this.scopeExceptions = scopeExceptions;
    return this;
} 
{
    return providing(TypeLiteral.get(cxtorClass));
} 
{
    // Find a constructor that has @ThrowingInject.
    Constructor<? extends T> cxtor = CheckedProvideUtils.findThrowingConstructor(cxtorLiteral, binder);
    final Provider<T> typeProvider;
    final Key<? extends T> typeKey;
    // If we found an injection point, then bind the cxtor to a unique key
    if (cxtor != null) {
        // Validate the exceptions are consistent with the CheckedProvider interface.
        CheckedProvideUtils.validateExceptions(binder, cxtorLiteral.getExceptionTypes(cxtor), exceptionTypes, interfaceType);
        typeKey = Key.get(cxtorLiteral, UniqueAnnotations.create());
        binder.bind(typeKey).toConstructor((Constructor) cxtor).in(Scopes.NO_SCOPE);
        typeProvider = binder.getProvider((Key<T>) typeKey);
    } else {
        // never used, but need it assigned.
        typeProvider = null;
        typeKey = null;
    }
    // Create a CheckedProvider that calls our cxtor
    CheckedProvider<T> checkedProvider = new CheckedProviderWithDependencies<T>() {

        @Override
        public T get() throws Exception {
            try {
                return typeProvider.get();
            } catch (ProvisionException pe) {
                // Rethrow the provision cause as the actual exception
                if (pe.getCause() instanceof Exception) {
                    throw (Exception) pe.getCause();
                } else if (pe.getCause() instanceof Error) {
                    throw (Error) pe.getCause();
                } else {
                    // If this failed because of multiple reasons (ie, more than
                    // one dependency failed due to scoping errors), then
                    // the ProvisionException won't have a cause, so we need
                    // to rethrow it as-is.
                    throw pe;
                }
            }
        }

        @Override
        public Set<Dependency<?>> getDependencies() {
            return ImmutableSet.<Dependency<?>>of(Dependency.get(typeKey));
        }
    };
    Key<CheckedProvider<?>> targetKey = Key.get(CHECKED_PROVIDER_TYPE, UniqueAnnotations.create());
    binder.bind(targetKey).toInstance(checkedProvider);
    return toInternal(targetKey);
} 
{
    try {
        Method getMethod = interfaceType.getMethod(""get"");
        List<TypeLiteral<?>> exceptionLiterals = TypeLiteral.get(interfaceType).getExceptionTypes(getMethod);
        List<Class<? extends Throwable>> results = Lists.newArrayList();
        for (TypeLiteral<?> exLiteral : exceptionLiterals) {
            results.add(exLiteral.getRawType().asSubclass(Throwable.class));
        }
        return results;
    } catch (SecurityException e) {
        throw new IllegalStateException(""Not allowed to inspect exception types"", e);
    } catch (NoSuchMethodException e) {
        throw new IllegalStateException(""No 'get'method available"", e);
    }
} 
",,,,,43,1452
CheckedProviderMethod.java,23,102,0.22549019607843138,"
 * A provider that invokes a method and returns its result.
 *
 * @author sameb@google.com (Sam Berlin)
 ",,,,,,,3,99
Struts2FactoryTest.java,21,48,0.4375,"
 * Test for Struts2Factory
 *
 * @author benmccann.com
 ",,,,,,,3,50
ExampleListener.java,22,22,1.0,"
 * Example application module.
 *
 * @author crazybob@google.com (Bob Lee)
 ",,,,,,,3,70
ServiceImpl.java,0,6,0.0,,,,,,,,1,0
Count.java,15,28,0.5357142857142857,,,,,,,,1,0
Counter.java,17,9,1.8888888888888888," Session-scoped counter. ","/**
 * Increments the count and returns the new value.
 */
 
","{
    return count++;
} 
",,,,,1,25
Service.java,17,102,0.16666666666666666,,,,,,,,1,0
Main.java,16,24,0.6666666666666666," Starts the example web server on port 8080. Run from ""./struts2/example"". ",,,,,,,1,75
GuiceObjectFactory.java,34,182,0.18681318681318682," @deprecated Use {@link com.google.inject.struts2.Struts2Factory} instead. ","/**
 * Returns true if the given class has a scope annotation.
 */
 
","{
    for (Annotation annotation : interceptorClass.getAnnotations()) {
        if (Annotations.isScopeAnnotation(annotation.annotationType())) {
            return true;
        }
    }
    return false;
} 
",,,,,1,75
Struts2Factory.java,39,175,0.22285714285714286,"
 * Cleanup up version from Bob's GuiceObjectFactory. Now works properly with GS2 and fixes several
 * bugs.
 *
 * @author dhanji@gmail.com
 * @author benmccann.com
 ","/**
 * Returns true if the given class has a scope annotation.
 */
 
","{
    for (Annotation annotation : interceptorClass.getAnnotations()) {
        if (Annotations.isScopeAnnotation(annotation.annotationType())) {
            return true;
        }
    }
    return false;
} 
",,,,,5,155
Struts2GuicePluginModule.java,21,8,2.625,"
 * Initializes the Struts 2 Guice Plugin. Must be added to the injector returned by {@link
 * com.google.inject.servlet.GuiceServletContextListener#getInjector}.
 *
 * @author benmccann.com
 ",,,,,,,4,183
DanceParty.java,15,2,7.5,,,,,,,,1,0
AssistedInjectModule.java,20,12,1.6666666666666667,"
 * Module to add {@link AssistedInject}-based elements to the demo {@link Injector}.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,3,128
Inventor.java,15,10,1.5,,,,,,,,1,0
FluxCapacitor.java,15,2,7.5,,,,,,,,1,0
DocBrown.java,16,5,3.2,,,,,,,,1,0
Plutonium.java,15,2,7.5,,,,,,,,1,0
PrivateTestModule.java,20,11,1.8181818181818181,"
 * Module to test private modules and exposed bindings.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 ",,,,,,,3,102
PlutoniumProvider.java,15,11,1.3636363636363635,,,,,,,,1,0
EnergySourceProvider.java,16,14,1.1428571428571428,,,,,,,,1,0
Nuclear.java,15,10,1.5,,,,,,,,1,0
EnergySource.java,15,4,3.75,,,,,,,,1,0
BackToTheFutureModule.java,22,22,1.0,"
 * Module that adds a variety of different kinds of {@link Bindings} to be used to generate a
 * comprehensive sample graph.
 *
 * @see InjectorGrapherDemo
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,5,192
InjectorGrapherDemo.java,22,24,0.9166666666666666,"
 * Application that instantiates {@link BackToTheFutureModule} and graphs it, writing the output to
 * a DOT-formatted file (filename specified on the command line).
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,4,207
Driver.java,15,10,1.5,,,,,,,,1,0
DancePartyFactory.java,20,4,5.0,"
 * Interface to be used with {@link FactoryProvider}.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,3,97
Lightning.java,15,8,1.875,,,,,,,,1,0
DeLorian.java,17,10,1.7,,,,,,,,1,0
MultibinderModule.java,20,11,1.8181818181818181,"
 * Module to add {@link Multibinder}-based bindings to the injector.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,3,112
Person.java,15,2,7.5,,,,,,,,1,0
Used.java,15,10,1.5,,,,,,,,1,0
MartyMcFly.java,15,2,7.5,,,,,,,,1,0
PinballParts.java,17,6,2.8333333333333335,,,,,,,,1,0
DancePartyImpl.java,15,7,2.142857142857143,,,,,,,,1,0
Renewable.java,15,10,1.5,,,,,,,,1,0
AllTests.java,31,115,0.26956521739130435," @author phopkins@gmail.com (Pete Hopkins) ",,,,,,,1,43
TransitiveDependencyVisitorTest.java,26,156,0.16666666666666666,"
 * Tests for {@link TransitiveDependencyVisitor}.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,3,93
ShortNameFactoryTest.java,26,143,0.18181818181818182,"
 * Tests for {@link ShortNameFactory}.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 | Helper objects are up here because their line numbers are tested below.","/**
 * Tests the case where a provider method is the source of the
 *
 * @throws Exception
 */
 
","{
    Member method = Obj.class.getDeclaredMethod(""method"", String.class);
    assertEquals(""Method should be identified by its file name and line number"", ""ShortNameFactoryTest.java:53"", nameFactory.getSourceName(method));
} 
",,,,,4,155
AbstractInjectorGrapherTest.java,21,182,0.11538461538461539,,,,,,,,1,0
AliasCreator.java,22,20,1.1,"
 * Creator of node aliases. Used by dependency graphers to merge nodes in the internal Guice graph
 * into a single node on the rendered graph.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 * @since 4.0
 ","/**
 * Returns aliases for the given dependency graph. The aliases do not need to be transitively
 * resolved, i.e. it is valid to return an alias (X to Y) and an alias (Y to Z). It is the
 * responsibility of the caller to resolve this to (X to Z) and (Y to Z).
 *
 * @param bindings bindings that make up the dependency graph
 * @return aliases that should be applied on the graph
 */
 
","createAliases 
",,,,,5,200
AbstractInjectorGrapher.java,39,156,0.25,"
 * Abstract injector grapher that builds the dependency graph but doesn't render it.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 * @since 4.0
 |
   * Parameters used to override default settings of the grapher.
   *
   * @since 4.0
   ","/**
 * Resets the state of the grapher before rendering a new graph.
 */
 
/**
 * Adds a new interface node to the graph.
 */
 
/**
 * Adds a new implementation node to the graph.
 */
 
/**
 * Adds a new instance node to the graph.
 */
 
/**
 * Adds a new dependency edge to the graph.
 */
 
/**
 * Adds a new binding edge to the graph.
 */
 
/**
 * Performs any post processing required after all nodes and edges have been added.
 */
 
/**
 * Transitively resolves aliases. Given aliases (X to Y) and (Y to Z), it will return mappings (X
 * to Z) and (Y to Z).
 */
 
/**
 * Returns the bindings for the root keys and their transitive dependencies.
 */
 
","reset 
newInterfaceNode 
newImplementationNode 
newInstanceNode 
newDependencyEdge 
newBindingEdge 
postProcess 
{
    Map<NodeId, NodeId> resolved = Maps.newHashMap();
    SetMultimap<NodeId, NodeId> inverse = HashMultimap.create();
    for (Alias alias : aliases) {
        NodeId from = alias.getFromId();
        NodeId to = alias.getToId();
        if (resolved.containsKey(to)) {
            to = resolved.get(to);
        }
        resolved.put(from, to);
        inverse.put(to, from);
        Set<NodeId> prev = inverse.get(from);
        if (prev != null) {
            for (NodeId id : prev) {
                resolved.remove(id);
                inverse.remove(from, id);
                resolved.put(id, to);
                inverse.put(to, id);
            }
        }
    }
    return resolved;
} 
{
    Set<Key<?>> keys = Sets.newHashSet(root);
    Set<Key<?>> visitedKeys = Sets.newHashSet();
    List<Binding<?>> bindings = Lists.newArrayList();
    TransitiveDependencyVisitor keyVisitor = new TransitiveDependencyVisitor();
    while (!keys.isEmpty()) {
        Iterator<Key<?>> iterator = keys.iterator();
        Key<?> key = iterator.next();
        iterator.remove();
        if (!visitedKeys.contains(key)) {
            Binding<?> binding = injector.getBinding(key);
            bindings.add(binding);
            visitedKeys.add(key);
            keys.addAll(binding.acceptTargetVisitor(keyVisitor));
        }
    }
    return bindings;
} 
",,,,,8,228
NameFactory.java,30,92,0.32608695652173914,"
 * Interface for a service that provides nice {@link String}s that we can display in the graph for
 * the types that come up in {@link com.google.inject.Binding}s.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,4,205
Node.java,25,72,0.3472222222222222,"
 * Node in a guice dependency graph.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 * @since 4.0
 ","/**
 * Returns a copy of the node with a new ID.
 *
 * @param id new ID of the node
 * @return copy of the node with a new ID
 */
 
","copy 
",,,"/**
 * When set to true, the source object is ignored in {@link #equals} and {@link #hashCode}. Only
 * used in tests.
 */
 
","Field ignoreSourceInComparisons
",4,95
TransitiveDependencyVisitor.java,23,59,0.3898305084745763,"
 * {@link com.google.inject.spi.BindingTargetVisitor} that returns a {@link Collection} of the
 * {@link Key}s of each {@link Binding}'s dependencies. Used by {@link InjectorGrapher} to walk the
 * dependency graph from a starting set of {@link Binding}s.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ","/**
 * @since 4.0
 */
 
","{
    return ImmutableSet.of();
} 
",,,,,5,295
RootKeySetCreator.java,22,21,1.0476190476190477,"
 * Creator of the default starting set of keys to graph. These keys and their transitive
 * dependencies will be graphed.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 * @since 4.0
 ","/**
 * Returns the set of starting keys to graph.
 */
 
","getRootKeys 
",,,,,5,178
Alias.java,22,15,1.4666666666666666,"
 * Alias between two nodes. Causes the 'from' node to be aliased with the 'to' node, which means
 * that the 'from' node is not rendered and all edges going to it instead go to the 'to' node.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 * @since 4.0
 ",,,,,,,5,248
ShortNameFactory.java,30,92,0.32608695652173914,"
 * Reasonable implementation for {@link NameFactory}. Mostly takes various {@link
 * Object#toString()}s and strips package names out of them so that they'll fit on the graph.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ","/**
 * Returns a name for a Guice ""source"" object. This will typically be either a {@link
 * StackTraceElement} for when the binding is made to the instance, or a {@link Method} when a
 * provider method is used.
 */
 
/**
 * Eliminates runs of lowercase characters and numbers separated by periods. Seems to remove
 * packages from fully-qualified type names pretty well.
 */
 
","{
    if (source instanceof ElementSource) {
        source = ((ElementSource) source).getDeclaringSource();
    }
    if (source instanceof Method) {
        source = StackTraceElements.forMember((Method) source);
    }
    if (source instanceof StackTraceElement) {
        return getFileString((StackTraceElement) source);
    }
    return stripPackages(source.toString());
} 
{
    return str.replaceAll(""(^|[< .\\(])([a-z0-9]+\\.)*"", ""$1"");
} 
",,,,,4,217
EdgeCreator.java,62,101,0.6138613861386139,"
 * Creator of graph edges to render. All edges will be rendered on the graph after node aliasing is
 * performed.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 * @since 4.0
 ","/**
 * Returns edges for the given dependency graph.
 */
 
","getEdges 
",,,,,5,170
NodeCreator.java,51,71,0.7183098591549296,"
 * Creator of graph nodes.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 * @since 4.0
 ","/**
 * Returns nodes for the given dependency graph.
 */
 
","getNodes 
",,,,,4,85
ProviderAliasCreator.java,22,20,1.1,"
 * Alias creator that creates an alias for each {@link ProviderBinding}. These {@link Binding}s
 * arise from an {@link InjectionPoint} for the {@link Provider} interface. Since this isn't very
 * interesting information, we don't render this binding on the graph, and just alias the two nodes.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 ",,,,,,,5,337
ImplementationNode.java,24,40,0.6,"
 * Node for types that have {@link com.google.inject.spi.Dependency}s and are bound to {@link
 * InterfaceNode}s. These nodes will often have fields for {@link Member}s that are {@link
 * com.google.inject.spi.InjectionPoint}s.
 *
 * @see DependencyEdge
 * @author phopkins@gmail.com (Pete Hopkins)
 * @since 4.0 (since 2.0 as an interface)
 ",,,,,,,7,328
DependencyEdge.java,26,39,0.6666666666666666,"
 * Edge from a class or {@link InjectionPoint} to the interface node that will satisfy the
 * dependency.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 * @since 4.0 (since 2.0 as an interface)
 ",,,,,"/**
 * Injection point to which this dependency belongs, or null if the dependency isn't attached to a
 * particular injection point.
 */
 
","Field injectionPoint
",5,187
GraphvizNode.java,25,72,0.3472222222222222,"
 * Data object to encapsulate the attributes of Graphviz nodes that we're interested in drawing.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ","/**
 * @since 4.0
 */
 
/**
 * @since 4.0
 */
 
/**
 * @since 4.0
 */
 
","{
    return nodeId;
} 
{
    return identifier;
} 
{
    this.identifier = identifier;
} 
","/**
 * @since 4.0
 */
 
","{
    this.nodeId = nodeId;
} 
","/**
 * {@link Map} from port ID to field title
 */
 
","Field fields
",3,140
PortIdFactory.java,21,5,4.2,"
 * Interface for a service that returns Graphviz port IDs, used for naming the rows in {@link
 * com.google.inject.grapher.ImplementationNode}-displaying {@link GraphvizNode}s.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,4,218
Graphviz.java,20,7,2.857142857142857,"
 * Annotation for types used by the graphviz grapher.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 ",,,,,,,3,100
NodeShape.java,22,14,1.5714285714285714,"
 * Enum for the shapes that are most interesting for Guice graphing.
 *
 * <p>See: http://www.graphviz.org/doc/info/shapes.html
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,5,167
EdgeStyle.java,22,16,1.375,"
 * Styles for edges.
 *
 * <p>See: http://www.graphviz.org/doc/info/attrs.html#k:style
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,5,126
CompassPoint.java,23,21,1.0952380952380953,"
 * Enum for the ""compass point"" values used to control where edge end points appear on the graph.
 *
 * <p>See: http://www.graphviz.org/doc/info/attrs.html#k:portPos
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,"/**
 * Graphviz ""compass_pt"" value.
 */
 
","Field compassPt
",5,205
NodeStyle.java,22,19,1.1578947368421053,"
 * Styles for nodes. Similar to {@link EdgeStyle} but with a few more options.
 *
 * <p>See: http://www.graphviz.org/doc/info/attrs.html#k:style
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,5,184
GraphvizModule.java,20,11,1.8181818181818181,"
 * Module that provides classes needed by {@link GraphvizGrapher}.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,3,110
GraphvizGrapher.java,35,237,0.14767932489451477,"
 * {@link com.google.inject.grapher.InjectorGrapher} implementation that writes out a Graphviz DOT
 * file of the graph. Dependencies are bound in {@link GraphvizModule}.
 *
 * <p>Specify the {@link PrintWriter} to output to with {@link #setOut(PrintWriter)}.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 * @since 4.0
 ","/**
 * Creates the ""label"" for a node. This is a string of HTML that defines a table with a heading at
 * the top and (in the case of {@link ImplementationNode}s) rows for each of the member fields.
 */
 
/**
 * Turns a {@link List} of {@link ArrowType}s into a {@link String} that represents combining
 * them. With Graphviz, that just means concatenating them.
 */
 
","{
    String cellborder = node.getStyle() == NodeStyle.INVISIBLE ? ""1"" : ""0"";
    StringBuilder html = new StringBuilder();
    html.append(""<"");
    html.append(""<table cellspacing=\""0\"" cellpadding=\""5\"" cellborder=\"""");
    html.append(cellborder).append(""\"" border=\""0\"">"");
    html.append(""<tr>"").append(""<td align=\""left\"" port=\""header\"" "");
    html.append(""bgcolor=\"""" + node.getHeaderBackgroundColor() + ""\"">"");
    String subtitle = Joiner.on(""<br align=\""left\""/>"").join(node.getSubtitles());
    if (subtitle.length() != 0) {
        html.append(""<font color=\"""").append(node.getHeaderTextColor());
        html.append(""\"" point-size=\""10\"">"");
        html.append(subtitle).append(""<br align=\""left\""/>"").append(""</font>"");
    }
    html.append(""<font color=\"""" + node.getHeaderTextColor() + ""\"">"");
    html.append(htmlEscape(node.getTitle())).append(""<br align=\""left\""/>"");
    html.append(""</font>"").append(""</td>"").append(""</tr>"");
    for (Map.Entry<String, String> field : node.getFields().entrySet()) {
        html.append(""<tr>"");
        html.append(""<td align=\""left\"" port=\"""").append(htmlEscape(field.getKey())).append(""\"">"");
        html.append(htmlEscape(field.getValue()));
        html.append(""</td>"").append(""</tr>"");
    }
    html.append(""</table>"");
    html.append("">"");
    return html.toString();
} 
{
    return Joiner.on("""").join(arrows);
} 
",,,,,7,309
PortIdFactoryImpl.java,20,8,2.5,"
 * Implementation of {@link PortIdFactory}. Bound in {@link GraphvizModule}.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,3,120
GraphvizEdge.java,22,67,0.3283582089552239,"
 * Data object to encapsulate the attributes of Graphviz edges that we're interested in drawing.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ","/**
 * @since 4.0
 */
 
/**
 * @since 4.0
 */
 
","{
    return headNodeId;
} 
{
    return tailNodeId;
} 
",,,,,3,140
ArrowType.java,23,25,0.92,"
 * Arrow symbols that are available from Graphviz. These can be composed by concatenation to make
 * double arrows and such.
 *
 * <p>See: http://www.graphviz.org/doc/info/arrows.html
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 ",,,,,,,6,221
NodeId.java,31,40,0.775,"
 * ID of a node in the graph. An ID is given by a {@link Key} and a node type, which is used to
 * distinguish instances and implementation classes for the same key. For example {@code
 * bind(Integer.class).toInstance(42)} produces two nodes: an interface node with the key of {@code
 * Key<Integer>} and an instance node with the same {@link Key} and value of 42.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 * @since 4.0
 |
   * Type of node.
   *
   * @since 4.0
   ",,,,,,,11,456
DefaultRootKeySetCreator.java,22,21,1.0476190476190477,"
 * Root key set creator that starts with all types that are not Guice internal types or the {@link
 * Logger} type.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 * @since 4.0
 ",,,,,,,5,172
InstanceNode.java,21,48,0.4375,"
 * Node for instances. Used when a type is bound to an instance.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 * @since 4.0
 ",,,,,,,4,123
BindingEdge.java,25,37,0.6756756756756757,"
 * Edge that connects an interface to the type or instance that is bound to implement it.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 * @since 4.0 (since 2.0 as an interface)
 | Classification for what kind of binding this edge represents. ",,,,,,,5,237
Edge.java,22,67,0.3283582089552239,"
 * Edge in a guice dependency graph.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 * @since 4.0
 ","/**
 * Returns a copy of the edge with new node IDs.
 *
 * @param fromId new ID of the 'from' node
 * @param toId new ID of the 'to' node
 * @return copy of the edge with the new node IDs
 */
 
","copy 
",,,,,4,95
DefaultEdgeCreator.java,62,101,0.6138613861386139,"
 * Default edge creator.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 |
   * {@link BindingTargetVisitor} that adds edges to the graph based on the visited {@link Binding}.
   ","/**
 * Returns a dependency edge for each {@link Dependency} in the binding. These will be from the
 * given node ID to the {@link Dependency}'s {@link Key}.
 *
 * @param nodeId ID of the node that should be the tail of the dependency edges
 * @param binding {@link Binding} for the dependencies
 */
 
/**
 * Visitor for {@link ConstructorBinding}s. These are for classes that Guice will instantiate to
 * satisfy injection requests.
 */
 
/**
 * Visitor for {@link ConvertedConstantBinding}. The {@link Binding}'s {@link Key} will be of an
 * annotated primitive type, and the value of {@link ConvertedConstantBinding#getSourceKey()}
 * will be of a {@link String} with the same annotation.
 */
 
/**
 * Visitor for {@link InstanceBinding}. We then render any dependency edgess that the instance
 * may have, which come either from {@link InjectionPoint}s (method and field) on the instance,
 * or on {@link Dependency}s the instance declares through the {@link HasDependencies}
 * interface.
 */
 
/**
 * Visitor for {@link LinkedKeyBinding}. This is the standard {@link Binding} you get from
 * binding an interface class to an implementation class. We draw a {@link BindingEdge} from the
 * interface node to the node of the implementing class.
 */
 
/**
 * Visitor for {@link ProviderBinding}. These {@link Binding}s arise from an {@link
 * InjectionPoint} for the {@link Provider} interface.
 */
 
/**
 * Same as {@link #visit(InstanceBinding)}, but the binding edge is {@link
 * BindingEdge.Type#PROVIDER}.
 */
 
/**
 * Same as {@link #visit(LinkedKeyBinding)}, but the binding edge is {@link
 * BindingEdge.Type#PROVIDER}.
 */
 
","{
    ImmutableList.Builder<Edge> builder = ImmutableList.builder();
    for (Dependency<?> dependency : binding.getDependencies()) {
        NodeId to = NodeId.newTypeId(dependency.getKey());
        builder.add(new DependencyEdge(nodeId, to, dependency.getInjectionPoint()));
    }
    return builder.build();
} 
{
    return newDependencyEdges(NodeId.newTypeId(binding.getKey()), binding);
} 
{
    return ImmutableList.<Edge>of(new BindingEdge(NodeId.newTypeId(binding.getKey()), NodeId.newTypeId(binding.getSourceKey()), BindingEdge.Type.CONVERTED_CONSTANT));
} 
{
    return new ImmutableList.Builder<Edge>().add(new BindingEdge(NodeId.newTypeId(binding.getKey()), NodeId.newInstanceId(binding.getKey()), BindingEdge.Type.NORMAL)).addAll(newDependencyEdges(NodeId.newInstanceId(binding.getKey()), binding)).build();
} 
{
    return ImmutableList.<Edge>of(new BindingEdge(NodeId.newTypeId(binding.getKey()), NodeId.newTypeId(binding.getLinkedKey()), BindingEdge.Type.NORMAL));
} 
{
    return ImmutableList.<Edge>of(new BindingEdge(NodeId.newTypeId(binding.getKey()), NodeId.newTypeId(binding.getProvidedKey()), BindingEdge.Type.PROVIDER));
} 
{
    return new ImmutableList.Builder<Edge>().add(new BindingEdge(NodeId.newTypeId(binding.getKey()), NodeId.newInstanceId(binding.getKey()), BindingEdge.Type.PROVIDER)).addAll(newDependencyEdges(NodeId.newInstanceId(binding.getKey()), binding)).build();
} 
{
    return ImmutableList.<Edge>of(new BindingEdge(NodeId.newTypeId(binding.getKey()), NodeId.newTypeId(binding.getProviderKey()), BindingEdge.Type.PROVIDER));
} 
",,,,,5,174
InterfaceNode.java,22,18,1.2222222222222223,"
 * Node for an interface type that has been bound to an implementation class or instance.
 *
 * @see BindingEdge
 * @author phopkins@gmail.com (Pete Hopkins)
 * @since 4.0 (since 2.0 as an interface)
 ",,,,,,,5,191
DefaultNodeCreator.java,51,71,0.7183098591549296,"
 * Default node creator.
 *
 * @author bojand@google.com (Bojan Djordjevic)
 |
   * {@link BindingTargetVisitor} that adds nodes to the graph based on the visited {@link Binding}.
   ","/**
 * Returns a new interface node for the given {@link Binding}.
 */
 
/**
 * Returns a new implementation node for the given binding.
 *
 * @param binding binding for the node to create
 * @param members members to add to the node
 * @return implementation node for the given binding
 */
 
/**
 * Returns a new instance node for the given {@link Binding}.
 *
 * @param binding binding for the node to create
 * @param instance value of the instance
 * @return instance node for the given binding
 */
 
/**
 * Visitor for {@link ConstructorBinding}s. These are for classes that Guice will instantiate to
 * satisfy injection requests.
 */
 
/**
 * Visitor for {@link InstanceBinding}. We render two nodes in this case: an interface node for
 * the binding's {@link Key}, and then an implementation node for the instance {@link Object}
 * itself.
 */
 
/**
 * Same as {@link #visit(InstanceBinding)}, but the binding edge is {@link
 * BindingEdgeType#PROVIDER}.
 */
 
","{
    return new InterfaceNode(NodeId.newTypeId(binding.getKey()), binding.getSource());
} 
{
    return new ImplementationNode(NodeId.newTypeId(binding.getKey()), binding.getSource(), members);
} 
{
    Collection<Member> members = Lists.newArrayList();
    for (Dependency<?> dependency : binding.getDependencies()) {
        InjectionPoint injectionPoint = dependency.getInjectionPoint();
        if (injectionPoint != null) {
            members.add(injectionPoint.getMember());
        }
    }
    return new InstanceNode(NodeId.newInstanceId(binding.getKey()), binding.getSource(), instance, members);
} 
{
    Collection<Member> members = Lists.newArrayList();
    members.add(binding.getConstructor().getMember());
    for (InjectionPoint injectionPoint : binding.getInjectableMembers()) {
        members.add(injectionPoint.getMember());
    }
    return ImmutableList.<Node>of(newImplementationNode(binding, members));
} 
{
    return ImmutableList.<Node>of(newInterfaceNode(binding), newInstanceNode(binding, binding.getInstance()));
} 
{
    return ImmutableList.<Node>of(newInterfaceNode(binding), newInstanceNode(binding, binding.getUserSuppliedProvider()));
} 
",,,,,5,174
InjectorGrapher.java,39,156,0.25,"
 * Guice injector grapher. Renders the guice dependency graph for an injector. It can render the
 * whole dependency graph or just transitive dependencies of a given set of nodes.
 *
 * @author phopkins@gmail.com (Pete Hopkins)
 * @since 4.0 (since 2.0 as a concrete class with a different API)
 ","/**
 * Graphs the guice dependency graph for the given injector using default starting keys.
 */
 
/**
 * Graphs the guice dependency graph for the given injector using the given starting keys and
 * their transitive dependencies.
 */
 
","graph 
graph 
",,,,,5,286
JndiIntegration.java,27,28,0.9642857142857143,"
 * Integrates Guice with JNDI. Requires a binding to {@link javax.naming.Context}.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Creates a provider which looks up objects in JNDI using the given name. Example usage:
 *
 * <pre>
 * bind(DataSource.class).toProvider(fromJndi(DataSource.class, ""java:...""));
 * </pre>
 */
 
","{
    return new JndiProvider<T>(type, name);
} 
",,,,,3,122
ExtensionSpiTest.java,21,256,0.08203125,"
 * Tests for AssistedInject Spi.
 *
 * @author ramakrishna@google.com (Ramakrishna Rajanna)
 ",,,,,,,3,87
FactoryModuleBuilderTest.java,19,545,0.03486238532110092,,,,,,,,1,0
FactoryProvider2Test.java,26,1191,0.0218303946263644,,"/**
 * Our factories aren't reusable across injectors. Although this behaviour isn't something we
 * like, I have a test case to make sure the error message is pretty.
 */
 
","{
    final Provider<ColoredCarFactory> factoryProvider = FactoryProvider.newFactory(ColoredCarFactory.class, Mustang.class);
    Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Double.class).toInstance(5.0d);
            bind(ColoredCarFactory.class).toProvider(factoryProvider);
        }
    });
    try {
        Guice.createInjector(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Double.class).toInstance(5.0d);
                bind(ColoredCarFactory.class).toProvider(factoryProvider);
            }
        });
        fail();
    } catch (CreationException expected) {
        assertContains(expected.getMessage(), ""Factories.create() factories may only be used in one Injector!"");
    }
} 
",,,,,1,0
FactoryProviderTest.java,19,783,0.024265644955300127,"
 * @author jmourits@google.com (Jerome Mourits)
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,2,94
ManyConstructorsTest.java,16,256,0.0625," @author sameb@google.com (Sam Berlin) ",,,,,,,1,39
FactoryProvider.java,141,247,0.5708502024291497,"
 * <strong>Obsolete.</strong> Prefer {@link FactoryModuleBuilder} for its more concise API and
 * additional capability.
 *
 * <p>Provides a factory that combines the caller's arguments with injector-supplied values to
 * construct objects.
 *
 * <h3>Defining a factory</h3>
 *
 * Create an interface whose methods return the constructed type, or any of its supertypes. The
 * method's parameters are the arguments required to build the constructed type.
 *
 * <pre>public interface PaymentFactory {
 *   Payment create(Date startDate, Money amount);
 * }</pre>
 *
 * You can name your factory methods whatever you like, such as <i>create</i>, <i>createPayment</i>
 * or <i>newPayment</i>.
 *
 * <h3>Creating a type that accepts factory parameters</h3>
 *
 * {@code constructedType} is a concrete class with an {@literal @}{@link Inject}-annotated
 * constructor. In addition to injector-supplied parameters, the constructor should have parameters
 * that match each of the factory method's parameters. Each factory-supplied parameter requires an
 * {@literal @}{@link Assisted} annotation. This serves to document that the parameter is not bound
 * by your application's modules.
 *
 * <pre>public class RealPayment implements Payment {
 *   {@literal @}Inject
 *   public RealPayment(
 *      CreditService creditService,
 *      AuthService authService,
 *      <strong>{@literal @}Assisted Date startDate</strong>,
 *      <strong>{@literal @}Assisted Money amount</strong>) {
 *     ...
 *   }
 * }</pre>
 *
 * Any parameter that permits a null value should also be annotated {@code @Nullable}.
 *
 * <h3>Configuring factories</h3>
 *
 * In your {@link com.google.inject.Module module}, bind the factory interface to the returned
 * factory:
 *
 * <pre>bind(PaymentFactory.class).toProvider(
 *     FactoryProvider.newFactory(PaymentFactory.class, RealPayment.class));</pre>
 *
 * As a side-effect of this binding, Guice will inject the factory to initialize it for use. The
 * factory cannot be used until the injector has been initialized.
 *
 * <h3>Using the factory</h3>
 *
 * Inject your factory into your application classes. When you use the factory, your arguments will
 * be combined with values from the injector to construct an instance.
 *
 * <pre>public class PaymentAction {
 *   {@literal @}Inject private PaymentFactory paymentFactory;
 *
 *   public void doPayment(Money amount) {
 *     Payment payment = paymentFactory.create(new Date(), amount);
 *     payment.apply();
 *   }
 * }</pre>
 *
 * <h3>Making parameter types distinct</h3>
 *
 * The types of the factory method's parameters must be distinct. To use multiple parameters of the
 * same type, use a named {@literal @}{@link Assisted} annotation to disambiguate the parameters.
 * The names must be applied to the factory method's parameters:
 *
 * <pre>public interface PaymentFactory {
 *   Payment create(
 *       <strong>{@literal @}Assisted(""startDate"")</strong> Date startDate,
 *       <strong>{@literal @}Assisted(""dueDate"")</strong> Date dueDate,
 *       Money amount);
 * } </pre>
 *
 * ...and to the concrete type's constructor parameters:
 *
 * <pre>public class RealPayment implements Payment {
 *   {@literal @}Inject
 *   public RealPayment(
 *      CreditService creditService,
 *      AuthService authService,
 *      <strong>{@literal @}Assisted(""startDate"")</strong> Date startDate,
 *      <strong>{@literal @}Assisted(""dueDate"")</strong> Date dueDate,
 *      <strong>{@literal @}Assisted</strong> Money amount) {
 *     ...
 *   }
 * }</pre>
 *
 * <h3>Values are created by Guice</h3>
 *
 * Returned factories use child injectors to create values. The values are eligible for method
 * interception. In addition, {@literal @}{@literal Inject} members will be injected before they are
 * returned.
 *
 * <h3>Backwards compatibility using {@literal @}AssistedInject</h3>
 *
 * Instead of the {@literal @}Inject annotation, you may annotate the constructed classes with
 * {@literal @}{@link AssistedInject}. This triggers a limited backwards-compatability mode.
 *
 * <p>Instead of matching factory method arguments to constructor parameters using their names, the
 * <strong>parameters are matched by their order</strong>. The first factory method argument is used
 * for the first {@literal @}Assisted constructor parameter, etc.. Annotation names have no effect.
 *
 * <p>Returned values are <strong>not created by Guice</strong>. These types are not eligible for
 * method interception. They do receive post-construction member injection.
 *
 * @param <F> The factory interface
 * @author jmourits@google.com (Jerome Mourits)
 * @author jessewilson@google.com (Jesse Wilson)
 * @author dtm@google.com (Daniel Martin)
 * @deprecated use {@link FactoryModuleBuilder} instead.
 ",,,,,,,114,4556
ParameterListKey.java,22,34,0.6470588235294118,"
 * A list of {@link TypeLiteral}s to match an injectable Constructor's assited parameter types to
 * the corresponding factory method.
 *
 * @author jmourits@google.com (Jerome Mourits)
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,5,226
Parameter.java,36,104,0.34615384615384615,"
 * Models a method or constructor parameter.
 *
 * @author jmourits@google.com (Jerome Mourits)
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Returns the Guice {@link Key} for this parameter.
 */
 
/**
 * Replace annotation instances with annotation types, this is only appropriate for testing if a
 * key is bound and not for injecting.
 *
 * <p>See Guice bug 125, https://github.com/google/guice/issues/125
 */
 
/**
 * Returns the unique binding annotation from the specified list, or {@code null} if there are
 * none.
 *
 * @throws IllegalStateException if multiple binding annotations exist.
 */
 
","{
    if (null == provider) {
        synchronized (this) {
            if (null == provider) {
                provider = isProvider ? injector.getProvider(getBindingForType(getProvidedType(type))) : injector.getProvider(getPrimaryBindingKey());
            }
        }
    }
    return isProvider ? provider : provider.get();
} 
{
    return key.getAnnotation() == null ? key : Key.get(key.getTypeLiteral(), key.getAnnotation().annotationType());
} 
{
    Annotation bindingAnnotation = null;
    for (Annotation annotation : annotations) {
        if (Annotations.isBindingAnnotation(annotation.annotationType())) {
            checkArgument(bindingAnnotation == null, ""Parameter has multiple binding annotations: %s and %s"", bindingAnnotation, annotation);
            bindingAnnotation = annotation;
        }
    }
    return bindingAnnotation;
} 
",,,,,4,138
FactoryProvider2.java,139,710,0.19577464788732393,"
 * The newer implementation of factory provider. This implementation uses a child injector to create
 * values.
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @author dtm@google.com (Daniel Martin)
 * @author schmitt@google.com (Peter Schmitt)
 * @author sameb@google.com (Sam Berlin)
 | Safe cast because values are typed to AssistedData, which is an AssistedMethod, and| Note: this isn't a public API, but we need to use it in order to call default methods on (or| All the data necessary to perform an assisted inject. | Safe cast because values are typed to AssistedData, which is an AssistedMethod, and| Note: this isn't a public API, but we need to use it in order to call default methods on (or| not <T> because we'll never know and this is easier than suppressing warnings.","/**
 * Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully
 * specified.
 */
 
/**
 * Finds a constructor suitable for the method. If the implementation contained any constructors
 * marked with {@link AssistedInject}, this requires all {@link Assisted} parameters to exactly
 * match the parameters (in any order) listed in the method. Otherwise, if no {@link
 * AssistedInject} constructors exist, this will default to looking for an {@literal @}{@link
 * Inject} constructor.
 */
 
/**
 * Matching logic for constructors annotated with AssistedInject. This returns true if and only if
 * all @Assisted parameters in the constructor exactly match (in any order) all @Assisted
 * parameters the method's parameter.
 */
 
/**
 * Calculates all dependencies required by the implementation and constructor.
 */
 
/**
 * Return all non-assisted dependencies.
 */
 
/**
 * Returns true if all dependencies are suitable for the optimized version of AssistedInject. The
 * optimized version caches the binding & uses a ThreadLocal Provider, so can only be applied if
 * the assisted bindings are immediately provided. This looks for hints that the values may be
 * lazily retrieved, by looking for injections of Injector or a Provider for the assisted values.
 */
 
/**
 * Returns true if the dependency is for {@link Injector} or if the dependency is a {@link
 * Provider} for a parameter that is {@literal @}{@link Assisted}.
 */
 
/**
 * Returns a key similar to {@code key}, but with an {@literal @}Assisted binding annotation. This
 * fails if another binding annotation is clobbered in the process. If the key already has the
 * {@literal @}Assisted annotation, it is returned as-is to preserve any String value.
 */
 
/**
 * At injector-creation time, we initialize the invocation handler. At this time we make sure all
 * factory methods will be able to build the target types.
 */
 
/**
 * Creates a child injector that binds the args, and returns the binding for the method's result.
 */
 
/**
 * When a factory method is invoked, we create a child injector that binds all parameters, then
 * use that to get an instance of the return type.
 */
 
/**
 * Returns true if {@code thrown} can be thrown by {@code invoked} without wrapping.
 */
 
","{
    Collection<Message> messages = ce.getErrorMessages();
    if (messages.size() == 1) {
        Message msg = Iterables.getOnlyElement(new Errors().keyNotFullySpecified(typeLiteral).getMessages());
        return msg.getMessage().equals(Iterables.getOnlyElement(messages).getMessage());
    } else {
        return false;
    }
} 
{
    Errors errors = new Errors(method);
    if (returnType.getTypeLiteral().equals(implementation)) {
        errors = errors.withSource(implementation);
    } else {
        errors = errors.withSource(returnType).withSource(implementation);
    }
    Class<?> rawType = implementation.getRawType();
    if (Modifier.isInterface(rawType.getModifiers())) {
        errors.addMessage(""%s is an interface, not a concrete class.  Unable to create AssistedInject factory."", implementation);
        throw errors.toException();
    } else if (Modifier.isAbstract(rawType.getModifiers())) {
        errors.addMessage(""%s is abstract, not a concrete class.  Unable to create AssistedInject factory."", implementation);
        throw errors.toException();
    } else if (Classes.isInnerClass(rawType)) {
        errors.cannotInjectInnerClass(rawType);
        throw errors.toException();
    }
    Constructor<?> matchingConstructor = null;
    boolean anyAssistedInjectConstructors = false;
    // Look for AssistedInject constructors...
    for (Constructor<?> constructor : rawType.getDeclaredConstructors()) {
        if (constructor.isAnnotationPresent(AssistedInject.class)) {
            anyAssistedInjectConstructors = true;
            if (constructorHasMatchingParams(implementation, constructor, paramList, errors)) {
                if (matchingConstructor != null) {
                    errors.addMessage(""%s has more than one constructor annotated with @AssistedInject"" + "" that matches the parameters in method %s.  Unable to create "" + ""AssistedInject factory."", implementation, method);
                    throw errors.toException();
                } else {
                    matchingConstructor = constructor;
                }
            }
        }
    }
    if (!anyAssistedInjectConstructors) {
        // If none existed, use @Inject.
        try {
            return InjectionPoint.forConstructorOf(implementation);
        } catch (ConfigurationException e) {
            errors.merge(e.getErrorMessages());
            throw errors.toException();
        }
    } else {
        // Otherwise, use it or fail with a good error message.
        if (matchingConstructor != null) {
            // safe because we got the constructor from this implementation.
            @SuppressWarnings(""unchecked"")
            InjectionPoint ip = InjectionPoint.forConstructor((Constructor<? super T>) matchingConstructor, implementation);
            return ip;
        } else {
            errors.addMessage(""%s has @AssistedInject constructors, but none of them match the"" + "" parameters in method %s.  Unable to create AssistedInject factory."", implementation, method);
            throw errors.toException();
        }
    }
} 
{
    List<TypeLiteral<?>> params = type.getParameterTypes(constructor);
    Annotation[][] paramAnnotations = constructor.getParameterAnnotations();
    int p = 0;
    List<Key<?>> constructorKeys = Lists.newArrayList();
    for (TypeLiteral<?> param : params) {
        Key<?> paramKey = Annotations.getKey(param, constructor, paramAnnotations[p++], errors);
        constructorKeys.add(paramKey);
    }
    // Require that every key exist in the constructor to match up exactly.
    for (Key<?> key : paramList) {
        // If it didn't exist in the constructor set, we can't use it.
        if (!constructorKeys.remove(key)) {
            return false;
        }
    }
    // If any keys remain and their annotation is Assisted, we can't use it.
    for (Key<?> key : constructorKeys) {
        if (key.getAnnotationType() == Assisted.class) {
            return false;
        }
    }
    // All @Assisted params match up to the method's parameters.
    return true;
} 
{
    ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder();
    builder.addAll(ctorPoint.getDependencies());
    if (!implementation.getRawType().isInterface()) {
        for (InjectionPoint ip : InjectionPoint.forInstanceMethodsAndFields(implementation)) {
            builder.addAll(ip.getDependencies());
        }
    }
    return builder.build();
} 
{
    ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder();
    for (Dependency<?> dep : deps) {
        Class<?> annotationType = dep.getKey().getAnnotationType();
        if (annotationType == null || !annotationType.equals(Assisted.class)) {
            builder.add(dep);
        }
    }
    return builder.build();
} 
{
    // optimization: create lazily
    Set<Dependency<?>> badDeps = null;
    for (Dependency<?> dep : dependencies) {
        if (isInjectorOrAssistedProvider(dep)) {
            if (badDeps == null) {
                badDeps = Sets.newHashSet();
            }
            badDeps.add(dep);
        }
    }
    if (badDeps != null && !badDeps.isEmpty()) {
        logger.log(Level.WARNING, ""AssistedInject factory {0} will be slow "" + ""because {1} has assisted Provider dependencies or injects the Injector. "" + ""Stop injecting @Assisted Provider<T> (instead use @Assisted T) "" + ""or Injector to speed things up. (It will be a ~6500% speed bump!)  "" + ""The exact offending deps are: {2}"", new Object[] { factoryType, implementation, badDeps });
        return false;
    }
    return true;
} 
{
    Class<?> annotationType = dependency.getKey().getAnnotationType();
    if (annotationType != null && annotationType.equals(Assisted.class)) {
        // If it's assisted..
        if (dependency.getKey().getTypeLiteral().getRawType().equals(Provider.class)) {
            // And a Provider...
            return true;
        }
    } else if (dependency.getKey().getTypeLiteral().getRawType().equals(Injector.class)) {
        // If it's the Injector...
        return true;
    }
    return false;
} 
{
    if (key.getAnnotationType() == null) {
        return Key.get(key.getTypeLiteral(), DEFAULT_ANNOTATION);
    } else if (key.getAnnotationType() == Assisted.class) {
        return key;
    } else {
        errors.withSource(method).addMessage(""Only @Assisted is allowed for factory parameters, but found @%s"", key.getAnnotationType());
        throw errors.toException();
    }
} 
{
    if (this.injector != null) {
        throw new ConfigurationException(ImmutableList.of(new Message(FactoryProvider2.class, ""Factories.create() factories may only be used in one Injector!"")));
    }
    this.injector = injector;
    for (Map.Entry<Method, AssistData> entry : assistDataByMethod.entrySet()) {
        Method method = entry.getKey();
        AssistData data = entry.getValue();
        Object[] args;
        if (!data.optimized) {
            args = new Object[method.getParameterTypes().length];
            Arrays.fill(args, ""dummy object for validating Factories"");
        } else {
            // won't be used -- instead will bind to data.providers.
            args = null;
        }
        getBindingFromNewInjector(method, args, // throws if the binding isn't properly configured
        data);
    }
} 
{
    checkState(injector != null, ""Factories.create() factories cannot be used until they're initialized by Guice."");
    final Key<?> returnType = data.returnType;
    // We ignore any pre-existing binding annotation.
    final Key<?> returnKey = Key.get(returnType.getTypeLiteral(), RETURN_ANNOTATION);
    Module assistedModule = new AbstractModule() {

        @Override
        @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
        protected // raw keys are necessary for the args array and return value
        void configure() {
            Binder binder = binder().withSource(method);
            int p = 0;
            if (!data.optimized) {
                for (Key<?> paramKey : data.paramTypes) {
                    // Wrap in a Provider to cover null, and to prevent Guice from injecting the
                    // parameter
                    binder.bind((Key) paramKey).toProvider(Providers.of(args[p++]));
                }
            } else {
                for (Key<?> paramKey : data.paramTypes) {
                    // Bind to our ThreadLocalProviders.
                    binder.bind((Key) paramKey).toProvider(data.providers.get(p++));
                }
            }
            Constructor constructor = data.constructor;
            // Constructor *should* always be non-null here,
            // but if it isn't, we'll end up throwing a fairly good error
            // message for the user.
            if (constructor != null) {
                binder.bind(returnKey).toConstructor(constructor, (TypeLiteral) data.implementationType).in(// make sure we erase any scope on the implementation type
                Scopes.NO_SCOPE);
            }
        }
    };
    Injector forCreate = injector.createChildInjector(assistedModule);
    Binding<?> binding = forCreate.getBinding(returnKey);
    // If we have providers cached in data, cache the binding for future optimizations.
    if (data.optimized) {
        data.cachedBinding = binding;
    }
    return binding;
} 
{
    // If we setup a method handle earlier for this method, call it.
    // This is necessary for default methods that java8 creates, so we
    // can call the default method implementation (and not our proxied version of it).
    if (methodHandleByMethod.containsKey(method)) {
        return methodHandleByMethod.get(method).invokeWithArguments(args);
    }
    if (method.getDeclaringClass().equals(Object.class)) {
        if (""equals"".equals(method.getName())) {
            return proxy == args[0];
        } else if (""hashCode"".equals(method.getName())) {
            return System.identityHashCode(proxy);
        } else {
            return method.invoke(this, args);
        }
    }
    AssistData data = assistDataByMethod.get(method);
    checkState(data != null, ""No data for method: %s"", method);
    Provider<?> provider;
    if (data.cachedBinding != null) {
        // Try to get optimized form...
        provider = data.cachedBinding.getProvider();
    } else {
        provider = getBindingFromNewInjector(method, args, data).getProvider();
    }
    try {
        int p = 0;
        for (ThreadLocalProvider tlp : data.providers) {
            tlp.set(args[p++]);
        }
        return provider.get();
    } catch (ProvisionException e) {
        // if this is an exception declared by the factory method, throw it as-is
        if (e.getErrorMessages().size() == 1) {
            Message onlyError = getOnlyElement(e.getErrorMessages());
            Throwable cause = onlyError.getCause();
            if (cause != null && canRethrow(method, cause)) {
                throw cause;
            }
        }
        throw e;
    } finally {
        for (ThreadLocalProvider tlp : data.providers) {
            tlp.remove();
        }
    }
} 
{
    if (thrown instanceof Error || thrown instanceof RuntimeException) {
        return true;
    }
    for (Class<?> declared : invoked.getExceptionTypes()) {
        if (declared.isInstance(thrown)) {
            return true;
        }
    }
    return false;
} 
","/**
 * @param factoryKey a key for a Java interface that defines one or more create methods.
 * @param collector binding configuration that maps method return types to implementation types.
 */
 
","{
    this.factoryKey = factoryKey;
    this.collector = collector;
    TypeLiteral<F> factoryType = factoryKey.getTypeLiteral();
    Errors errors = new Errors();
    // we imprecisely treat the class literal of T as a Class<T>
    @SuppressWarnings(""unchecked"")
    Class<F> factoryRawType = (Class<F>) (Class<?>) factoryType.getRawType();
    try {
        if (!factoryRawType.isInterface()) {
            throw errors.addMessage(""%s must be an interface."", factoryRawType).toException();
        }
        Multimap<String, Method> defaultMethods = HashMultimap.create();
        Multimap<String, Method> otherMethods = HashMultimap.create();
        ImmutableMap.Builder<Method, AssistData> assistDataBuilder = ImmutableMap.builder();
        // TODO: also grab methods from superinterfaces
        for (Method method : factoryRawType.getMethods()) {
            // Skip static methods
            if (Modifier.isStatic(method.getModifiers())) {
                continue;
            }
            // Skip default methods that java8 may have created.
            if (isDefault(method) && (method.isBridge() || method.isSynthetic())) {
                // Even synthetic default methods need the return type validation...
                // unavoidable consequence of javac8. :-(
                validateFactoryReturnType(errors, method.getReturnType(), factoryRawType);
                defaultMethods.put(method.getName(), method);
                continue;
            }
            otherMethods.put(method.getName(), method);
            TypeLiteral<?> returnTypeLiteral = factoryType.getReturnType(method);
            Key<?> returnType;
            try {
                returnType = Annotations.getKey(returnTypeLiteral, method, method.getAnnotations(), errors);
            } catch (ConfigurationException ce) {
                // If this was an error due to returnTypeLiteral not being specified, rephrase
                // it as our factory not being specified, so it makes more sense to users.
                if (isTypeNotSpecified(returnTypeLiteral, ce)) {
                    throw errors.keyNotFullySpecified(TypeLiteral.get(factoryRawType)).toException();
                } else {
                    throw ce;
                }
            }
            validateFactoryReturnType(errors, returnType.getTypeLiteral().getRawType(), factoryRawType);
            List<TypeLiteral<?>> params = factoryType.getParameterTypes(method);
            Annotation[][] paramAnnotations = method.getParameterAnnotations();
            int p = 0;
            List<Key<?>> keys = Lists.newArrayList();
            for (TypeLiteral<?> param : params) {
                Key<?> paramKey = Annotations.getKey(param, method, paramAnnotations[p++], errors);
                Class<?> underlylingType = paramKey.getTypeLiteral().getRawType();
                if (underlylingType.equals(Provider.class) || underlylingType.equals(javax.inject.Provider.class)) {
                    errors.addMessage(""A Provider may not be a type in a factory method of an AssistedInject."" + ""\n  Offending instance is parameter [%s] with key [%s] on method [%s]"", p, paramKey, method);
                }
                keys.add(assistKey(method, paramKey, errors));
            }
            ImmutableList<Key<?>> immutableParamList = ImmutableList.copyOf(keys);
            // try to match up the method to the constructor
            TypeLiteral<?> implementation = collector.getBindings().get(returnType);
            if (implementation == null) {
                implementation = returnType.getTypeLiteral();
            }
            Class<? extends Annotation> scope = Annotations.findScopeAnnotation(errors, implementation.getRawType());
            if (scope != null) {
                errors.addMessage(""Found scope annotation [%s] on implementation class "" + ""[%s] of AssistedInject factory [%s].\nThis is not allowed, please"" + "" remove the scope annotation."", scope, implementation.getRawType(), factoryType);
            }
            InjectionPoint ctorInjectionPoint;
            try {
                ctorInjectionPoint = findMatchingConstructorInjectionPoint(method, returnType, implementation, immutableParamList);
            } catch (ErrorsException ee) {
                errors.merge(ee.getErrors());
                continue;
            }
            Constructor<?> constructor = (Constructor<?>) ctorInjectionPoint.getMember();
            List<ThreadLocalProvider> providers = Collections.emptyList();
            Set<Dependency<?>> deps = getDependencies(ctorInjectionPoint, implementation);
            boolean optimized = false;
            // Now go through all dependencies of the implementation and see if it is OK to
            // use an optimized form of assistedinject2.  The optimized form requires that
            // all injections directly inject the object itself (and not a Provider of the object,
            // or an Injector), because it caches a single child injector and mutates the Provider
            // of the arguments in a ThreadLocal.
            if (isValidForOptimizedAssistedInject(deps, implementation.getRawType(), factoryType)) {
                ImmutableList.Builder<ThreadLocalProvider> providerListBuilder = ImmutableList.builder();
                for (int i = 0; i < params.size(); i++) {
                    providerListBuilder.add(new ThreadLocalProvider());
                }
                providers = providerListBuilder.build();
                optimized = true;
            }
            AssistData data = new AssistData(constructor, returnType, immutableParamList, implementation, method, removeAssistedDeps(deps), optimized, providers);
            assistDataBuilder.put(method, data);
        }
        factory = factoryRawType.cast(Proxy.newProxyInstance(BytecodeGen.getClassLoader(factoryRawType), new Class<?>[] { factoryRawType }, this));
        // Now go back through default methods. Try to use MethodHandles to make things
        // work.  If that doesn't work, fallback to trying to find compatible method
        // signatures.
        Map<Method, AssistData> dataSoFar = assistDataBuilder.build();
        ImmutableMap.Builder<Method, MethodHandle> methodHandleBuilder = ImmutableMap.builder();
        for (Map.Entry<String, Method> entry : defaultMethods.entries()) {
            Method defaultMethod = entry.getValue();
            MethodHandle handle = createMethodHandle(defaultMethod, factory);
            if (handle != null) {
                methodHandleBuilder.put(defaultMethod, handle);
            } else {
                boolean foundMatch = false;
                for (Method otherMethod : otherMethods.get(defaultMethod.getName())) {
                    if (dataSoFar.containsKey(otherMethod) && isCompatible(defaultMethod, otherMethod)) {
                        if (foundMatch) {
                            errors.addMessage(""Generated default method %s with parameters %s is"" + "" signature-compatible with more than one non-default method."" + "" Unable to create factory. As a workaround, remove the override"" + "" so javac stops generating a default method."", defaultMethod, Arrays.asList(defaultMethod.getParameterTypes()));
                        } else {
                            assistDataBuilder.put(defaultMethod, dataSoFar.get(otherMethod));
                            foundMatch = true;
                        }
                    }
                }
                if (!foundMatch) {
                    throw new IllegalStateException(""Can't find method compatible with: "" + defaultMethod);
                }
            }
        }
        // If we generated any errors (from finding matching constructors, for instance), throw an
        // exception.
        if (errors.hasErrors()) {
            throw errors.toException();
        }
        assistDataByMethod = assistDataBuilder.build();
        methodHandleByMethod = methodHandleBuilder.build();
    } catch (ErrorsException e) {
        throw new ConfigurationException(e.getErrors().getMessages());
    }
} 
","/**
 * A constant annotation to denote the return value, instead of creating a new one each time.
 */
 
/**
 * if a factory method parameter isn't annotated, it gets this annotation.
 */
 
/**
 * the constructor the implementation is constructed with.
 */
 
/**
 * the return type in the factory method that the constructor is bound to.
 */
 
/**
 * the parameters in the factory method associated with this data.
 */
 
/**
 * the type of the implementation constructed
 */
 
/**
 * All non-assisted dependencies required by this method.
 */
 
/**
 * The factory method associated with this data
 */
 
/**
 * true if {@link #isValidForOptimizedAssistedInject} returned true.
 */
 
/**
 * the list of optimized providers, empty if not optimized.
 */
 
/**
 * Mapping from method to the data about how the method will be assisted.
 */
 
/**
 * Mapping from method to method handle, for generated default methods.
 */
 
/**
 * the hosting injector, or null if we haven't been initialized yet
 */
 
/**
 * the factory interface, implemented and provided
 */
 
/**
 * The key that this is bound to.
 */
 
/**
 * The binding collector, for equality/hashing purposes.
 */
 
","Field RETURN_ANNOTATION
Field DEFAULT_ANNOTATION
Field constructor
Field returnType
Field paramTypes
Field implementationType
Field dependencies
Field factoryMethod
Field optimized
Field providers
Field assistDataByMethod
Field methodHandleByMethod
Field injector
Field factory
Field factoryKey
Field collector
",8,774
FactoryModuleBuilder.java,217,83,2.6144578313253013,"
 * Provides a factory that combines the caller's arguments with injector-supplied values to
 * construct objects.
 *
 * <h3>Defining a factory</h3>
 *
 * Create an interface whose methods return the constructed type, or any of its supertypes. The
 * method's parameters are the arguments required to build the constructed type.
 *
 * <pre>public interface PaymentFactory {
 *   Payment create(Date startDate, Money amount);
 * }</pre>
 *
 * You can name your factory methods whatever you like, such as <i>create</i>, <i>createPayment</i>
 * or <i>newPayment</i>.
 *
 * <h3>Creating a type that accepts factory parameters</h3>
 *
 * {@code constructedType} is a concrete class with an {@literal @}{@link com.google.inject.Inject
 * Inject}-annotated constructor. In addition to injector-supplied parameters, the constructor
 * should have parameters that match each of the factory method's parameters. Each factory-supplied
 * parameter requires an {@literal @}{@link Assisted} annotation. This serves to document that the
 * parameter is not bound by your application's modules.
 *
 * <pre>public class RealPayment implements Payment {
 *   {@literal @}Inject
 *   public RealPayment(
 *      CreditService creditService,
 *      AuthService authService,
 *      <strong>{@literal @}Assisted Date startDate</strong>,
 *      <strong>{@literal @}Assisted Money amount</strong>) {
 *     ...
 *   }
 * }</pre>
 *
 * <h3>Multiple factory methods for the same type</h3>
 *
 * If the factory contains many methods that return the same type, you can create multiple
 * constructors in your concrete class, each constructor marked with with {@literal @}{@link
 * AssistedInject}, in order to match the different parameters types of the factory methods.
 *
 * <pre>public interface PaymentFactory {
 *    Payment create(Date startDate, Money amount);
 *    Payment createWithoutDate(Money amount);
 * }
 *
 * public class RealPayment implements Payment {
 *  {@literal @}AssistedInject
 *   public RealPayment(
 *      CreditService creditService,
 *      AuthService authService,
 *     <strong>{@literal @}Assisted Date startDate</strong>,
 *     <strong>{@literal @}Assisted Money amount</strong>) {
 *     ...
 *   }
 *
 *  {@literal @}AssistedInject
 *   public RealPayment(
 *      CreditService creditService,
 *      AuthService authService,
 *     <strong>{@literal @}Assisted Money amount</strong>) {
 *     ...
 *   }
 * }</pre>
 *
 * <h3>Configuring simple factories</h3>
 *
 * In your {@link Module module}, install a {@code FactoryModuleBuilder} that creates the factory:
 *
 * <pre>install(new FactoryModuleBuilder()
 *     .implement(Payment.class, RealPayment.class)
 *     .build(PaymentFactory.class));</pre>
 *
 * As a side-effect of this binding, Guice will inject the factory to initialize it for use. The
 * factory cannot be used until the injector has been initialized.
 *
 * <h3>Configuring complex factories</h3>
 *
 * Factories can create an arbitrary number of objects, one per each method. Each factory method can
 * be configured using <code>.implement</code>.
 *
 * <pre>public interface OrderFactory {
 *    Payment create(Date startDate, Money amount);
 *    Shipment create(Customer customer, Item item);
 *    Receipt create(Payment payment, Shipment shipment);
 * }
 *
 * [...]
 *
 * install(new FactoryModuleBuilder()
 *     .implement(Payment.class, RealPayment.class)
 *     // excluding .implement for Shipment means the implementation class
 *     // will be 'Shipment' itself, which is legal if it's not an interface.
 *     .implement(Receipt.class, RealReceipt.class)
 *     .build(OrderFactory.class));</pre>
 *
 * </pre>
 *
 * <h3>Using the factory</h3>
 *
 * Inject your factory into your application classes. When you use the factory, your arguments will
 * be combined with values from the injector to construct an instance.
 *
 * <pre>public class PaymentAction {
 *   {@literal @}Inject private PaymentFactory paymentFactory;
 *
 *   public void doPayment(Money amount) {
 *     Payment payment = paymentFactory.create(new Date(), amount);
 *     payment.apply();
 *   }
 * }</pre>
 *
 * <h3>Making parameter types distinct</h3>
 *
 * The types of the factory method's parameters must be distinct. To use multiple parameters of the
 * same type, use a named {@literal @}{@link Assisted} annotation to disambiguate the parameters.
 * The names must be applied to the factory method's parameters:
 *
 * <pre>public interface PaymentFactory {
 *   Payment create(
 *       <strong>{@literal @}Assisted(""startDate"")</strong> Date startDate,
 *       <strong>{@literal @}Assisted(""dueDate"")</strong> Date dueDate,
 *       Money amount);
 * } </pre>
 *
 * ...and to the concrete type's constructor parameters:
 *
 * <pre>public class RealPayment implements Payment {
 *   {@literal @}Inject
 *   public RealPayment(
 *      CreditService creditService,
 *      AuthService authService,
 *      <strong>{@literal @}Assisted(""startDate"")</strong> Date startDate,
 *      <strong>{@literal @}Assisted(""dueDate"")</strong> Date dueDate,
 *      <strong>{@literal @}Assisted</strong> Money amount) {
 *     ...
 *   }
 * }</pre>
 *
 * <h3>Values are created by Guice</h3>
 *
 * Returned factories use child injectors to create values. The values are eligible for method
 * interception. In addition, {@literal @}{@literal Inject} members will be injected before they are
 * returned.
 *
 * <h3>More configuration options</h3>
 *
 * In addition to simply specifying an implementation class for any returned type, factories' return
 * values can be automatic or can be configured to use annotations:
 *
 * <p>If you just want to return the types specified in the factory, do not configure any
 * implementations:
 *
 * <pre>public interface FruitFactory {
 *   Apple getApple(Color color);
 * }
 * ...
 * protected void configure() {
 *   install(new FactoryModuleBuilder().build(FruitFactory.class));
 * }</pre>
 *
 * Note that any type returned by the factory in this manner needs to be an implementation class.
 *
 * <p>To return two different implementations for the same interface from your factory, use binding
 * annotations on your return types:
 *
 * <pre>interface CarFactory {
 *   {@literal @}Named(""fast"") Car getFastCar(Color color);
 *   {@literal @}Named(""clean"") Car getCleanCar(Color color);
 * }
 * ...
 * protected void configure() {
 *   install(new FactoryModuleBuilder()
 *       .implement(Car.class, Names.named(""fast""), Porsche.class)
 *       .implement(Car.class, Names.named(""clean""), Prius.class)
 *       .build(CarFactory.class));
 * }</pre>
 *
 * <h3>Implementation limitations</h3>
 *
 * As a limitation of the implementation, it is prohibited to declare a factory method that accepts
 * a {@code Provider} as one of its arguments.
 *
 * @since 3.0
 * @author schmitt@google.com (Peter Schmitt)
 ","/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
/**
 * See the factory configuration examples at {@link FactoryModuleBuilder}.
 */
 
","{
    return implement(source, TypeLiteral.get(target));
} 
{
    return implement(TypeLiteral.get(source), target);
} 
{
    return implement(source, TypeLiteral.get(target));
} 
{
    return implement(Key.get(source), target);
} 
{
    return implement(source, annotation, TypeLiteral.get(target));
} 
{
    return implement(TypeLiteral.get(source), annotation, target);
} 
{
    return implement(source, annotation, TypeLiteral.get(target));
} 
{
    return implement(Key.get(source, annotation), target);
} 
{
    return implement(source, annotationType, TypeLiteral.get(target));
} 
{
    return implement(TypeLiteral.get(source), annotationType, target);
} 
{
    return implement(source, annotationType, TypeLiteral.get(target));
} 
{
    return implement(Key.get(source, annotationType), target);
} 
{
    return implement(source, TypeLiteral.get(target));
} 
{
    bindings.addBinding(source, target);
    return this;
} 
{
    return build(TypeLiteral.get(factoryInterface));
} 
{
    return build(Key.get(factoryInterface));
} 
",,,,,184,6493
AssistedConstructor.java,31,57,0.543859649122807,"
 * Internal respresentation of a constructor annotated with {@link AssistedInject}
 *
 * @author jmourits@google.com (Jerome Mourits)
 * @author jessewilson@google.com (Jesse Wilson)
 ","/**
 * Returns the {@link ParameterListKey} for this constructor. The {@link ParameterListKey} is
 * created from the ordered list of {@link Assisted} constructor parameters.
 */
 
/**
 * Returns an ordered list of all constructor parameters (both {@link Assisted} and {@link
 * Inject}ed).
 */
 
/**
 * Returns an instance of T, constructed using this constructor, with the supplied arguments.
 */
 
","{
    return assistedParameters;
} 
{
    return allParameters;
} 
{
    constructor.setAccessible(true);
    try {
        return constructor.newInstance(args);
    } catch (InvocationTargetException e) {
        throw e.getCause();
    }
} 
",,,,,4,176
AssistedInjectTargetVisitor.java,25,5,5.0,"
 * A visitor for the AssistedInject extension.
 *
 * <p>If your {@link BindingTargetVisitor} implements this interface, bindings created by using
 * {@link FactoryModuleBuilder} will be visited through this interface.
 *
 * @since 3.0
 * @author ramakrishna@google.com (Ramakrishna Rajanna)
 ","/**
 * Visits an {@link AssistedInjectBinding} created through {@link FactoryModuleBuilder}.
 */
 
","visit 
",,,,,7,278
AssistedInjectBinding.java,24,7,3.4285714285714284,"
 * A binding for a factory created by FactoryModuleBuilder.
 *
 * @param <T> The fully qualified type of the factory.
 * @since 3.0
 * @author ramakrishna@google.com (Ramakrishna Rajanna)
 ","/**
 * Returns the {@link Key} for the factory binding.
 */
 
/**
 * Returns an {@link AssistedMethod} for each method in the factory.
 */
 
","getKey 
getAssistedMethods 
",,,,,5,179
BindingCollector.java,20,31,0.6451612903225806,"
 * Utility class for collecting factory bindings. Used for configuring {@link FactoryProvider2}.
 *
 * @author schmitt@google.com (Peter Schmitt)
 ",,,,,,,3,141
AssistedMethod.java,25,12,2.0833333333333335,"
 * Details about how a method in an assisted inject factory will be assisted.
 *
 * @since 3.0
 * @author ramakrishna@google.com (Ramakrishna Rajanna)
 ","/**
 * Returns the factory method that is being assisted.
 */
 
/**
 * Returns the implementation type that will be created when the method is used.
 */
 
/**
 * Returns the constructor that will be used to construct instances of the implementation.
 */
 
/**
 * Returns all non-assisted dependencies required to construct and inject the implementation.
 */
 
","getFactoryMethod 
getImplementationType 
getImplementationConstructor 
getDependencies 
",,,,,4,144
Assisted.java,25,14,1.7857142857142858,"
 * Annotates an injected parameter or field whose value comes from an argument to a factory method.
 *
 * @author jmourits@google.com (Jerome Mourits)
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,4,193
AssistedInject.java,37,9,4.111111111111111,"
 * When used in tandem with {@link FactoryModuleBuilder}, constructors annotated with
 * {@code @AssistedInject} indicate that multiple constructors can be injected, each with different
 * parameters. AssistedInject annotations should not be mixed with {@literal @}{@link Inject}
 * annotations. The assisted parameters must exactly match one corresponding factory method within
 * the factory interface, but the parameters do not need to be in the same order. Constructors
 * annotated with AssistedInject <b>are</b> created by Guice and receive all the benefits (such as
 * AOP).
 *
 * <p><strong>Obsolete Usage:</strong> When used in tandem with {@link FactoryProvider},
 * constructors annotated with {@code @AssistedInject} trigger a ""backwards compatibility mode"". The
 * assisted parameters must exactly match one corresponding factory method within the factory
 * interface and all must be in the same order as listed in the factory. In this backwards
 * compatable mode, constructors annotated with AssistedInject <b>are not</b> created by Guice and
 * thus receive none of the benefits.
 *
 * <p>Constructor parameters must be either supplied by the factory interface and marked with <code>
 * @Assisted</code>, or they must be injectable.
 *
 * @author jmourits@google.com (Jerome Mourits)
 * @author jessewilson@google.com (Jesse Wilson)
 ",,,,,,,20,1311
BoundFieldModuleTest.java,19,827,0.022974607013301087," Unit tests for {@link BoundFieldModule}. ",,,,,,,1,42
CheckedProviderSubjectTest.java,5,100,0.05,"
 * Unit tests for {@link CheckedProviderSubject}.
 *
 * @author eatnumber1@google.com (Russ Harmon)
 ",,,,,,,3,95
Bind.java,40,11,3.6363636363636362,"
 * Annotation used by {@link BoundFieldModule} to indicate that a field should be bound to its value
 * using Guice.
 *
 * <p>{@Bind} supports binding annotations. For example, to bind a {@code @Fast Car}, use
 * {@code @Bind @Fast Car}.
 *
 * <p>Binding to {@code null} is only allowed for fields that are annotated {@code @Nullable}. See
 * <a
 * href=""https://github.com/google/guice/wiki/UseNullable"">https://github.com/google/guice/wiki/UseNullable</a>
 *
 * @see BoundFieldModule
 * @author eatnumber1@google.com (Russ Harmon)
 ",,,,,,,12,510
BoundFieldModule.java,175,290,0.603448275862069,"
 * Automatically creates Guice bindings for fields in an object annotated with {@link Bind}.
 *
 * <p>This module is intended for use in tests to reduce the code needed to bind local fields
 * (usually mocks) for injection.
 *
 * <p>The following rules are followed in determining how fields are bound using this module:
 *
 * <ul>
 *   <li>For each {@link Bind} annotated field of an object and its superclasses, this module will
 *       bind that field's type to that field's value at injector creation time. This includes both
 *       instance and static fields.
 *   <li>If {@link Bind#to} is specified, the field's value will be bound to the class specified by
 *       {@link Bind#to} instead of the field's actual type.
 *   <li>If {@link Bind#lazy} is true, this module will delay reading the value from the field until
 *       injection time, allowing the field's value to be reassigned during the course of a test's
 *       execution.
 *   <li>If a {@link BindingAnnotation} or {@link javax.inject.Qualifier} is present on the field,
 *       that field will be bound using that annotation via {@link
 *       AnnotatedBindingBuilder#annotatedWith}. For example, {@code
 *       bind(Foo.class).annotatedWith(BarAnnotation.class).toInstance(theValue)}. It is an error to
 *       supply more than one {@link BindingAnnotation} or {@link javax.inject.Qualifier}.
 *   <li>If the field is of type {@link Provider}, the field's value will be bound as a {@link
 *       Provider} using {@link LinkedBindingBuilder#toProvider} to the provider's parameterized
 *       type. For example, {@code Provider<Integer>} binds to {@link Integer}. Attempting to bind a
 *       non-parameterized {@link Provider} without a {@link Bind#to} clause is an error.
 * </ul>
 *
 * <p>Example use:
 *
 * <pre><code>
 * public class TestFoo {
 *   // bind(new TypeLiteral{@code <List<Object>>}() {}).toInstance(listOfObjects);
 *   {@literal @}Bind private List{@code <Object>} listOfObjects = Lists.of();
 *
 *   // private String userName = ""string_that_changes_over_time"";
 *   // bind(String.class).toProvider(new Provider() { public String get() { return userName; }});
 *   {@literal @}Bind(lazy = true) private String userName;
 *
 *   // bind(SuperClass.class).toInstance(aSubClass);
 *   {@literal @}Bind(to = SuperClass.class) private SubClass aSubClass = new SubClass();
 *
 *   // bind(String.class).annotatedWith(MyBindingAnnotation.class).toInstance(myString);
 *   {@literal @}Bind
 *   {@literal @}MyBindingAnnotation
 *   private String myString = ""hello"";
 *
 *   // bind(Object.class).toProvider(myProvider);
 *   {@literal @}Bind private Provider{@code <Object>} myProvider = getProvider();
 *
 *   {@literal @}Before public void setUp() {
 *     Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
 *   }
 * }
 * </code></pre>
 *
 * @see Bind
 * @author eatnumber1@google.com (Russ Harmon)
 | @Nullable| Information about a field bound by {@link BoundFieldModule}. ","/**
 * Create a BoundFieldModule which binds the {@link Bind} annotated fields of {@code instance}.
 *
 * @param instance the instance whose fields will be bound.
 * @return a module which will bind the {@link Bind} annotated fields of {@code instance}.
 */
 
/**
 * The field itself.
 */
 
/**
 * The actual type of the field.
 *
 * <p>For example, {@code @Bind(to = Object.class) Number one = new Integer(1);} will be {@code
 * Number}. {@code @Bind Provider<Number>} will be {@code Provider<Number>}.
 */
 
/**
 * The {@literal @}{@link Bind} annotation which is present on the field.
 *
 * <p>Note this is not the same as the binding annotation (or qualifier) for {@link
 * #getBoundKey()}
 */
 
/**
 * The key this field will bind to.
 *
 * <ul>
 *   <li>{@code @Bind(to = Object.class) @MyQualifier Number one = new Integer(1);} will be
 *       {@code @MyQualifier Object}.
 *   <li>{@code @Bind @MyQualifier(2) Number one = new Integer(1);} will be
 *       {@code @MyQualifier(2) Number}.
 *   <li>{@code @Bind @MyQualifier Provider<String> three = ""default""} will be
 *       {@code @MyQualfier String}
 * </ul>
 */
 
/**
 * Returns the current value of this field.
 */
 
/**
 * Retrieves the type this field binds to naturally.
 *
 * <p>A field's ""natural"" type specifically ignores the to() method on the @Bind annotation, is
 * the parameterized type if the field's actual type is a parameterized {@link Provider}, is
 * {@link Optional#absent()} if this field is a non-parameterized {@link Provider} and otherwise
 * is the field's actual type.
 *
 * @return the type this field binds to naturally, or {@link Optional#absent()} if this field is
 *     a non-parameterized {@link Provider}.
 */
 
/**
 * Returns whether a binding supports null values.
 */
 
/**
 * Returns the the object originally passed to {@link BoundFieldModule#of}).
 */
 
/**
 * Returns information about the fields bound by this module.
 *
 * <p>Note this is available immediately after construction, fields with errors won't be included
 * but their error messages will be deferred to configuration time.
 *
 * <p>Fields with invalid null values <em>are</em> included but still cause errors at
 * configuration time.
 */
 
/**
 * Retrieve a {@link BoundFieldInfo}.
 *
 * <p>This returns a {@link BoundFieldInfo} if the field has a {@link Bind} annotation. Otherwise
 * it returns {@link Optional#absent()}.
 */
 
/**
 * Determines if {@code clazz} is a ""transparent provider"".
 *
 * <p>If you have traced through the code and found that what you want to do is failing because of
 * this check, try using {@code @Bind(lazy=true) MyType myField} and lazily assign myField
 * instead.
 *
 * <p>A transparent provider is a {@link com.google.inject.Provider} or {@link
 * javax.inject.Provider} which binds to it's parameterized type when used as the argument to
 * {@link Binder#bind}.
 *
 * <p>A {@link Provider} is transparent if the base class of that object is {@link Provider}. In
 * other words, subclasses of {@link Provider} are not transparent. As a special case, if a {@link
 * Provider} has no parameterized type but is otherwise transparent, then it is considered
 * transparent.
 *
 * <p>Subclasses of {@link Provider} are not considered transparent in order to allow users to
 * bind those subclasses directly, enabling them to inject the providers themselves.
 */
 
/**
 * Returns the field value to bind, throwing for non-{@code @Nullable} fields with null values,
 * and for null ""transparent providers"".
 */
 
","{
    return new BoundFieldModule(instance);
} 
{
    return field;
} 
{
    return fieldType;
} 
{
    return bindAnnotation;
} 
{
    return boundKey;
} 
{
    try {
        return field.get(instance);
    } catch (IllegalAccessException e) {
        // Since we called setAccessible(true) on this field in the constructor, this is a
        // programming error if it occurs.
        throw new AssertionError(e);
    }
} 
{
    if (isTransparentProvider(fieldType.getRawType())) {
        Type providerType = fieldType.getType();
        if (providerType instanceof Class) {
            return Optional.absent();
        }
        Preconditions.checkState(providerType instanceof ParameterizedType);
        Type[] providerTypeArguments = ((ParameterizedType) providerType).getActualTypeArguments();
        Preconditions.checkState(providerTypeArguments.length == 1);
        return Optional.<TypeLiteral<?>>of(TypeLiteral.get(providerTypeArguments[0]));
    } else {
        return Optional.<TypeLiteral<?>>of(fieldType);
    }
} 
{
    return !isTransparentProvider(fieldType.getRawType()) && Nullability.allowsNull(field.getAnnotations());
} 
{
    return instance;
} 
{
    return boundFields;
} 
{
    Bind bindAnnotation = field.getAnnotation(Bind.class);
    if (bindAnnotation == null) {
        return Optional.absent();
    }
    if (hasInject(field)) {
        deferredErrors.add(new Message(field, ""Fields annotated with both @Bind and @Inject are illegal.""));
        return Optional.absent();
    }
    try {
        return Optional.of(new BoundFieldInfo(instance, field, bindAnnotation, containingClassType.getFieldType(field)));
    } catch (ConfigurationException e) {
        // thrown from Key.get, MoreTypes.canonicalizeForKey
        deferredErrors.addAll(e.getErrorMessages());
        return Optional.absent();
    } catch (BoundFieldException e) {
        deferredErrors.add(e.message);
        return Optional.absent();
    }
} 
{
    return com.google.inject.Provider.class == clazz || javax.inject.Provider.class == clazz;
} 
{
    Object fieldValue = fieldInfo.getValue();
    if (fieldValue == null && !fieldInfo.allowsNull()) {
        if (isTransparentProvider(fieldInfo.fieldType.getRawType())) {
            throw new NullBoundFieldValueException(new Message(fieldInfo.field, ""Binding to null is not allowed. Use Providers.of(null) if this is your intended "" + ""behavior.""));
        } else {
            throw new NullBoundFieldValueException(new Message(fieldInfo.field, ""Binding to null values is only allowed for fields that are annotated @Nullable.""));
        }
    }
    return fieldValue;
} 
",,,"/**
 * @see #getBoundKey
 */
 
","Field boundKey
",58,2880
CheckedProviderSubject.java,27,71,0.38028169014084506,"
 * Truth {@link Subject} for use with {@link CheckedProvider} classes.
 *
 * @author eatnumber1@google.com (Russ Harmon)
 ","/**
 * Allows for assertions on the value provided by this provider.
 *
 * <p>The value provided by a checked provider is the object returned by a call to {@link
 * CheckedProvider#get}
 *
 * @return a {@link Subject} for asserting against the return value of {@link CheckedProvider#get}
 */
 
/**
 * Allows for assertions on the exception thrown by this provider.
 *
 * <p>The exception thrown by a checked provider is the {@link Throwable} thrown by a call to
 * {@link CheckedProvider#get}
 *
 * @return a {@link ThrowableSubject} for asserting against the {@link Throwable} thrown by {@link
 *     CheckedProvider#get}
 */
 
","{
    T got;
    try {
        got = provider.get();
    } catch (Exception e) {
        failWithCauseAndMessage(e, ""checked provider was not expected to throw an exception"");
        return ignoreCheck().that(new Object());
    }
    return check(""get()"").that(got);
} 
{
    T got;
    try {
        got = provider.get();
    } catch (Throwable e) {
        return check(""get()'s exception"").that(e);
    }
    failWithoutActual(simpleFact(""expected to throw""), fact(""but provided"", got));
    return ignoreCheck().that(new Throwable());
} 
",,,,,3,116
SingleServiceIntegrationTest.java,6,60,0.1,,,,,,,,1,0
CompositeService.java,27,77,0.35064935064935066,"
 * A service that composes other services together in a fixed order.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ",,,,,"/**
 * Represents the state of this composite service. Will equal FAILED even if only one component
 * service fails to start or stop. In other words, all component services must start successfully
 * for this service to be considered started and similarly for stopped.
 */
 
","Field compositeState
",3,116
Service.java,17,102,0.16666666666666666,"
 * An object with an operational state, asynchronous {@link #start()} and {@link #stop()} lifecycle
 * methods to transition in and out of this state. Example services include http servers, RPC
 * systems and timer tasks.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 | The lifecycle states of a service. ","/**
 * If the service has already been started, this method returns immediately without taking action.
 * A stopped service may not be restarted.
 *
 * @return a future for the startup result, regardless of whether this call initiated startup.
 *     Calling {@link Future#get} will block until the service has finished starting, and returns
 *     the resultant state. If the service fails to start, {@link Future#get} will throw an {@link
 *     ExecutionException}. If it has already finished starting, {@link Future#get} returns
 *     immediately.
 */
 
/**
 * If the service is {@link State#STARTED} initiates service shutdown and returns immediately. If
 * the service has already been stopped, this method returns immediately without taking action.
 *
 * @return a future for the shutdown result, regardless of whether this call initiated shutdown.
 *     Calling {@link Future#get} will block until the service has finished shutting down, and
 *     either returns {@link State#STOPPED} or throws an {@link ExecutionException}. If it has
 *     already finished stopping, {@link Future#get} returns immediately.
 */
 
/**
 * Returns the current state of this service. One of {@link State} possible values, or null if
 * this is a brand new object, i.e., has not been put into any state yet.
 */
 
","start 
stop 
state 
",,,,,6,302
AsyncService.java,33,44,0.75,"
 * An asynchronous implementation of {@link com.google.inject.service.Service} that provides
 * convenience callbacks to create your own services.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ","/**
 * Called back when this service must do its start work. Typically occurs in a background thread.
 * The result of this method is returned to the original caller of {@link Service#start()} and can
 * thus be used to return a status message after start completes (or fails as the case may be).
 */
 
/**
 * Called back when this service must shutdown. Typically occurs in a background thread. The
 * result of this method is returned to the original caller of {@link Service#stop()} and can thus
 * be used to return a status message after stop completes (or fails as the case may be).
 */
 
","onStart 
onStop 
",,,,,4,192
IntoMapTest.java,16,163,0.09815950920245399,,,,,,,,1,0
BindingSubject.java,16,41,0.3902439024390244," TODO(ronshapiro): consider exposing this in a Guice-Truth extension for SPI users?",,,,,,,1,83
OptionalBindingsTest.java,16,37,0.43243243243243246,,,,,,,,1,0
ModuleIncludesTest.java,19,90,0.2111111111111111,,,,,,,,1,0
ModuleSubcomponentsTest.java,16,30,0.5333333333333333,,,,,,,,1,0
DaggerAdapterTest.java,21,225,0.09333333333333334,,,,,,,,1,0
BindsTest.java,16,124,0.12903225806451613,,,,,,,,1,0
MultibindsTest.java,16,54,0.2962962962962963,,,,,,,,1,0
Annotations.java,64,274,0.23357664233576642," Extensions for {@link Annotation}. ",,,,,,,1,36
Keys.java,16,15,1.0666666666666667," Utility methods for creating {@link Key}s. ",,,,,,,1,44
DaggerAdapter.java,66,136,0.4852941176470588,"
 * Adapts classes annotated with {@link @dagger.Module} such that their {@link @dagger.Provides}
 * methods can be properly invoked by Guice to perform their provision operations.
 *
 * <p>Simple example:
 *
 * <pre>{@code
 * Guice.createInjector(
 *   DaggerAdapter.from(SomeDaggerModule.class, new AnotherModuleWithConstructor());
 * }</pre>
 *
 * <p>For modules with no instance binding methods, prefer using a class literal. If there are
 * instance binding methods, an instance of the module must be passed.
 *
 * <p>Any class literals specified by {@code dagger.Module(includes = ...)} transitively will be
 * included. Modules are de-duplicated, though multiple module instances of the same type is an
 * error. Specifying a module instance and a class literal is also an error.
 *
 * <p>Some notes on usage and compatibility.
 *
 * <ul>
 *   <li>Dagger provider methods have a ""SET_VALUES"" provision mode not supported by Guice.
 *   <li>MapBindings are not yet implemented (pending).
 *   <li>Be careful about stateful modules. In contrast to Dagger (where components are expected to
 *       be recreated on-demand with new Module instances), Guice typically has a single injector
 *       with a long lifetime, so your module instance will be used throughout the lifetime of the
 *       entire app.
 *   <li>Dagger 1.x uses {@link @Singleton} for all scopes, including shorter-lived scopes like
 *       per-request or per-activity. Using modules written with Dagger 1.x usage in mind may result
 *       in mis-scoped objects.
 *   <li>Dagger 2.x supports custom scope annotations, but for use in Guice, a custom scope
 *       implementation must be registered in order to support the custom lifetime of that
 *       annotation.
 * </ul>
 *
 * @author cgruber@google.com (Christian Gruber)
 |
   * A Module that adapts Dagger {@code @Module}-annotated types to contribute configuration to an
   * {@link com.google.inject.Injector} using a dagger-specific {@link
   * ModuleAnnotatedMethodScanner}.
   ","/**
 * Creates a new {@link DaggerAdapter} from {@code daggerModuleObjects}.
 */
 
","{
    return new DaggerCompatibilityModule(ImmutableList.copyOf(daggerModuleObjects));
} 
",,,,,39,1940
DaggerMethodScanner.java,34,154,0.22077922077922077,"
 * A scanner to process provider methods on Dagger modules.
 *
 * @author cgruber@google.com (Christian Gruber)
 ",,,,,"/**
 * A single instance is not necessary for the correctness or performance of the scanner, but it
 * does suffice an invariant of {@link com.google.inject.internal.ProviderMethodsModule}, which
 * uses scanner equality in its own equality semantics. If multiple modules use
 * DaggerAdapter.from(FooModule.class) separately, and thus are not deduplicated by DaggerAdapter
 * on their own, Guice will do so as long as this scanner is always equal.
 *
 * <p>If we do away with this singleton instance, we need to be sure that we do so in a way that
 * maintains equality in these cases.
 */
 
","Field INSTANCE
",3,107
SupportedAnnotations.java,7,29,0.2413793103448276," Collections of annotations that are supported by {@link DaggerAdapter}. ","/**
 * Returns all binding annotations supported by {@link DaggerAdapter}.
 */
 
/**
 * Returns true if {@code annotation} is in a dagger package and is supported by {@link
 * DaggerAdapter}.
 */
 
","{
    return BINDING_ANNOTATIONS;
} 
{
    if (ALL_SUPPORTED_ANNOTATIONS.contains(annotation)) {
        return true;
    }
    return annotation.isAnnotationPresent(MapKey.class);
} 
",,,,,1,73
AllTests.java,31,115,0.26956521739130435," @author dhanji@gmail.com (Dhanji R. Prasanna) ",,,,,,,1,47
EdslTest.java,22,66,0.3333333333333333," @author dhanji@google.com (Dhanji R. Prasanna) ",,,,,,,1,48
JpaParentTestEntity.java,21,27,0.7777777777777778,"
 * Created with IntelliJ IDEA. On: 2/06/2007
 *
 * @author Dhanji R. Prasanna (dhanji@gmail.com)
 * @since 1.0
 ",,,,,,,4,104
JpaWorkManagerTest.java,19,83,0.2289156626506024,,,,,,,,1,0
ManagedLocalTransactionsAcrossRequestTest.java,23,174,0.13218390804597702,,,,,,,,1,0
ManualLocalTransactionsConfidenceTest.java,17,61,0.2786885245901639,,,,,,,,1,0
EntityManagerFactoryProvisionTest.java,18,31,0.5806451612903226,,,,,,,,1,0
CustomPropsEntityManagerFactoryProvisionTest.java,18,31,0.5806451612903226,,,,,,,,1,0
EntityManagerPerRequestProvisionTest.java,29,73,0.3972602739726027,,,,,,,,1,0
JpaPersistServiceTest.java,16,38,0.42105263157894735,,,,,,,,1,0
ManualLocalTransactionsTest.java,25,65,0.38461538461538464,,,,,,,,1,0
JpaTestEntity.java,16,46,0.34782608695652173," @author Dhanji R. Prasanna (dhanji@gmail.com) ",,,,,,,1,47
ManualLocalTransactionsWithCustomMatcherTest.java,28,67,0.417910447761194,,,,,,,,1,0
EntityManagerProvisionTest.java,29,71,0.4084507042253521,,,,,,,,1,0
ManagedLocalTransactionsTest.java,31,148,0.20945945945945946,,,,,,,,1,0
JoiningLocalTransactionsTest.java,22,130,0.16923076923076924,,,,,,,,1,0
ClassLevelManagedLocalTransactionsTest.java,31,148,0.20945945945945946,,,,,,,,1,0
DynamicFinderTest.java,24,67,0.3582089552238806,,,,,,,,1,0
EnsureJpaCanTakeObjectsInPropertiesTest.java,15,71,0.2112676056338028,,,,,,,,1,0
Transactional.java,40,13,3.076923076923077,"
 * Any method or class marked with this annotation will be considered for transactionality. Consult
 * the documentation on https://github.com/google/guice/wiki/GuicePersist for detailed semantics.
 * Marking a method {@code @Transactional} will start a new transaction before the method executes
 * and commit it after the method returns.
 *
 * <p>If the method throws an exception, the transaction will be rolled back <em>unless</em> you
 * have specifically requested not to in the {@link #ignore()} clause.
 *
 * <p>Similarly, the set of exceptions that will trigger a rollback can be defined in the {@link
 * #rollbackOn()} clause. By default, only unchecked exceptions trigger a rollback.
 *
 * @author Dhanji R. Prasanna (dhanji@gmail.com)
 ",,,,,,,12,724
JpaPersistService.java,17,102,0.16666666666666666," @author Dhanji R. Prasanna (dhanji@gmail.com) ",,,,,,,1,47
JpaLocalTxnInterceptor.java,44,86,0.5116279069767442," @author Dhanji R. Prasanna (dhanji@gmail.com) ","/**
 * Returns True if rollback DID NOT HAPPEN (i.e. if commit should continue).
 *
 * @param transactional The metadata annotaiton of the method
 * @param e The exception to test for rollback
 * @param txn A JPA Transaction to issue rollbacks on
 */
 
","{
    boolean commit = true;
    // check rollback clauses
    for (Class<? extends Exception> rollBackOn : transactional.rollbackOn()) {
        // if one matched, try to perform a rollback
        if (rollBackOn.isInstance(e)) {
            commit = false;
            // check ignore clauses (supercedes rollback clause)
            for (Class<? extends Exception> exceptOn : transactional.ignore()) {
                // An exception to the rollback clause was found, DON'T rollback
                // (i.e. commit and throw anyway)
                if (exceptOn.isInstance(e)) {
                    commit = true;
                    break;
                }
            }
            // rollback only if nothing matched the ignore check
            if (!commit) {
                txn.rollback();
            }
            // otherwise continue to commit
            break;
        }
    }
    return commit;
} 
",,,,,1,47
JpaPersistModule.java,36,133,0.2706766917293233,"
 * JPA provider for guice persist.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ","/**
 * Configures the JPA persistence provider with a set of properties.
 *
 * @param properties A set of name value pairs that configure a JPA persistence provider as per
 *     the specification.
 * @since 4.0 (since 3.0 with a parameter type of {@code java.util.Properties})
 */
 
/**
 * Adds an interface to this module to use as a dynamic finder.
 *
 * @param iface Any interface type whose methods are all dynamic finders.
 */
 
","{
    this.properties = properties;
    return this;
} 
{
    dynamicFinders.add(iface);
    return this;
} 
",,,,,3,82
Jpa.java,20,7,2.857142857142857,"
 * A binding annotation for internal JPA module properties.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ",,,,,,,3,107
JpaFinderProxy.java,44,201,0.21890547263681592,"
 * TODO(dhanji): Make this work!!
 *
 * @author Dhanji R. Prasanna (dhanji@gmail.com)
 | A wrapper data class that caches information about a finder method. ","/**
 * writes to a chm (used to provide copy-on-write but this is bettah!)
 *
 * @param method The key
 * @param finderDescriptor The descriptor to cache
 */
 
","{
    // write to concurrent map
    finderCache.put(method, finderDescriptor);
} 
",,,,,4,151
PersistFilter.java,50,41,1.2195121951219512,"
 * Apply this filter to enable the HTTP Request unit of work and to have guice-persist manage the
 * lifecycle of active units of work. The filter automatically starts and stops the relevant {@link
 * PersistService} upon {@link javax.servlet.Filter#init(javax.servlet.FilterConfig)} and {@link
 * javax.servlet.Filter#destroy()} respectively.
 *
 * <p>To be able to use the open session-in-view pattern (i.e. work per request), register this
 * filter <b>once</b> in your Guice {@code ServletModule}. It is important that you register this
 * filter before any other filter.
 *
 * <p>For multiple providers, you should register this filter once per provider, inside a private
 * module for each persist module installed (this must be the same private module where the specific
 * persist module is itself installed).
 *
 * <p>Example configuration:
 *
 * <pre>{@code
 * public class MyModule extends ServletModule {
 *   public void configureServlets() {
 *     filter(""/*"").through(PersistFilter.class);
 *
 *     serve(""/index.html"").with(MyHtmlServlet.class);
 *     // Etc.
 *   }
 * }
 * }</pre>
 *
 * <p>This filter is thread safe and allows you to create injectors concurrently and deploy multiple
 * guice-persist modules within the same injector, or even multiple injectors with persist modules
 * withing the same JVM or web app.
 *
 * <p>This filter requires the Guice Servlet extension.
 *
 * @author Dhanji R. Prasanna (dhanji@gmail.com)
 ",,,,,,,33,1386
DynamicFinder.java,25,16,1.5625,"
 * Utility that helps you introspect dynamic finder methods.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ","/**
 * Returns some metadata if the method is annotated {@code @Finder} or null.
 *
 * @param method a method you want to test as a dynamic finder
 */
 
","{
    return method.isAnnotationPresent(Finder.class) ? new DynamicFinder(method) : null;
} 
",,,,,3,108
MaxResults.java,21,8,2.625,"
 * Annotate any dynamic finder method's integer argument with this to pass in the maximum size of
 * returned result window. Usefule for paging result sets. Complement of {@link FirstResult}.
 *
 * @author Dhanji R. Prasanna (dhanji@gmail.com)
 ",,,,,,,4,237
FirstResult.java,22,8,2.75,"
 * Annotate any dynamic finder method's integer argument with this to pass in the index of the first
 * result in the result set you are interested in. Useful for paging result sets. Complemented by
 * {@link MaxResults}.
 *
 * @author Dhanji R. Prasanna (dhanji@gmail.com)
 ",,,,,,,5,265
Finder.java,25,16,1.5625,"
 * Marks a method stub as a dynamic finder. The method is intercepted and replaced with the
 * specified JPAQL query. Provides result auto-boxing and automatic parameter binding.
 *
 * @author Dhanji R. Prasanna (dhanji@gmail.com)
 ",,,,,,,4,224
PersistService.java,17,102,0.16666666666666666,"
 * Persistence provider service. Use this to manage the overall startup and stop of the persistence
 * module(s).
 *
 * <p>TODO(dhanji): Integrate with Service API when appropriate.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ","/**
 * Starts the underlying persistence engine and makes guice-persist ready for use. For instance,
 * with JPA, it creates an EntityManagerFactory and may open connection pools. This method must be
 * called by your code prior to using any guice-persist or JPA artifacts. If already started,
 * calling this method does nothing, if already stopped, it also does nothing.
 */
 
/**
 * Stops the underlying persistence engine. For instance, with JPA, it closes the {@code
 * EntityManagerFactory}. If already stopped, calling this method does nothing. If not yet
 * started, it also does nothing.
 */
 
","start 
stop 
",,,,,6,223
PersistModule.java,36,133,0.2706766917293233,"
 * Install this module to add guice-persist library support for JPA persistence providers.
 *
 * @author dhanji@gmail.com (Dhanji R. Prasanna)
 ",,,,,,,3,138
UnitOfWork.java,48,5,9.6,"
 * This interface is used to gain manual control over the unit of work. This is mostly to do work in
 * non-request, non-transactional threads. Or where more fine-grained control over the unit of work
 * is required. Starting and ending a unit of work directly corresponds to opening and closing a
 * {@code Session}, {@code EntityManager} or {@code ObjectContainer} respectively.
 *
 * <p>The Unit of Work referred to by UnitOfWork will always be local to the calling thread. Be
 * careful to end() in a finally block. Neither JPA, nor Hibernate supports threadsafe sessions
 * (reasoning behind thread-locality of Unit of Work semantics).
 *
 * <ul>
 * <li>Using UnitOfWork with the PersistFilter inside a request is not recommended.
 * <li>Using UnitOfWork with session-per-txn strategy is not terribly clever either.
 * <li>Using UnitOfWork with session-per-request strategy but *outside* a request (i.e. in a
 *     background or bootstrap thread) is probably a good use case.
 * </ul>
 *
 * @author Dhanji R. Prasanna (dhanji@gmail com)
 ","/**
 * Starts a Unit Of Work. Underneath, causes a session to the data layer to be opened. If there is
 * already one open, the invocation will do nothing. In this way, you can define arbitrary
 * units-of-work that nest within one another safely.
 *
 * <p>Transaction semantics are not affected.
 */
 
/**
 * Declares an end to the current Unit of Work. Underneath, causes any open session to the data
 * layer to close. If there is no Unit of work open, then the call returns silently. You can
 * safely invoke end() repeatedly.
 *
 * <p>Transaction semantics are not affected.
 */
 
","begin 
end 
",,,,,17,1008
SpringIntegrationTest.java,16,58,0.27586206896551724," @author crazybob@google.com (Bob Lee) ",,,,,,,1,39
SpringIntegration.java,36,74,0.4864864864864865,"
 * Integrates Guice with Spring.
 *
 * @author crazybob@google.com (Bob Lee)
 ","/**
 * Creates a provider which looks up objects from Spring using the given name. Expects a binding
 * to {@link org.springframework.beans.factory.BeanFactory}. Example usage:
 *
 * <pre>
 * bind(DataSource.class)
 *   .toProvider(fromSpring(DataSource.class, ""dataSource""));
 * </pre>
 */
 
/**
 * Binds all Spring beans from the given factory by name. For a Spring bean named ""foo"", this
 * method creates a binding to the bean's type and {@code @Named(""foo"")}.
 *
 * @see com.google.inject.name.Named
 * @see com.google.inject.name.Names#named(String)
 */
 
","{
    return new InjectableSpringProvider<T>(type, name);
} 
{
    binder = binder.skipSources(SpringIntegration.class);
    for (String name : beanFactory.getBeanDefinitionNames()) {
        Class<?> type = beanFactory.getType(name);
        bindBean(binder, beanFactory, name, type);
    }
} 
",,,,,3,72
Contacts.java,0,4,0.0,,,,,,,,1,0
Phone.java,0,10,0.0,,,,,,,,1,0
FlashMemory.java,0,7,0.0,,,,,,,,1,0
Contact.java,0,2,0.0,,,,,,,,1,0
SimCard.java,0,7,0.0,,,,,,,,1,0
FromSim.java,0,5,0.0,,,,,,,,1,0
Main.java,16,24,0.6666666666666666," ",,,,,,,1,1
FromFlash.java,0,5,0.0,,,,,,,,1,0
XmlBeanModule.java,11,167,0.0658682634730539," Handles ""binding"" elements. | Handles ""property"" elements. ",,,,,,,1,60
Null.java,4,3,1.3333333333333333,"
 * This class is used only as a ""null"" argument for Javadoc when comparing two API files. Javadoc
 * has to have a package, .java or .class file as an argument, even though JDiff doesn't use it.
 ",,,,,,,2,192
StaticInterfaceMethodsTest.java,20,35,0.5714285714285714,"
 * Test static methods in interfaces.
 *
 * @author tavianator@tavianator.com (Tavian Barnes)
 ",,,,,,,3,89
Java8LanguageFeatureBindingTest.java,22,127,0.1732283464566929,"
 * Test bindings to lambdas, method references, etc.
 *
 * @author cgdecker@google.com (Colin Decker)
 ",,,,,,,3,97
DefaultMethodInterceptionTest.java,35,162,0.21604938271604937,"
 * Tests for interception of default methods.
 *
 * @author cgdecker@google.com (Colin Decker)
 | Interface with a default method annotated to be intercepted. | Foo implementation that does not override the default method. | A base class defining a method with the same signature as Foo's default method. | Foo implementation that should use superclass method rather than default method. |
   * A base class defining an intercepted method with the same signature as Foo's default method.
   |
   * Foo implementation that should use intercepted superclass method rather than default method.
   ",,,,,,,7,582
